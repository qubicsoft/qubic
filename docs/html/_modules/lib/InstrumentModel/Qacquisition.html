<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>lib.InstrumentModel.Qacquisition &mdash; qubicsoft  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            qubicsoft
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../lib.html">lib package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">qubicsoft</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">lib.InstrumentModel.Qacquisition</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for lib.InstrumentModel.Qacquisition</h1><div class="highlight"><pre>
<span></span><span class="c1"># QUBIC stuff</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># General stuff</span>
<span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pysm3</span>
<span class="kn">import</span> <span class="nn">qubic</span>

<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">pyoperators</span>
<span class="kn">import</span> <span class="nn">pysm3.units</span> <span class="k">as</span> <span class="nn">u</span>
<span class="kn">from</span> <span class="nn">pyoperators</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AdditionOperator</span><span class="p">,</span>
    <span class="n">BlockColumnOperator</span><span class="p">,</span>
    <span class="n">BlockDiagonalOperator</span><span class="p">,</span>
    <span class="n">BlockRowOperator</span><span class="p">,</span>
    <span class="n">CompositionOperator</span><span class="p">,</span>
    <span class="n">DenseBlockDiagonalOperator</span><span class="p">,</span>
    <span class="n">DenseOperator</span><span class="p">,</span>
    <span class="n">DiagonalOperator</span><span class="p">,</span>
    <span class="n">IdentityOperator</span><span class="p">,</span>
    <span class="n">MPIDistributionIdentityOperator</span><span class="p">,</span>
    <span class="n">Operator</span><span class="p">,</span>
    <span class="n">PackOperator</span><span class="p">,</span>
    <span class="n">ReshapeOperator</span><span class="p">,</span>
    <span class="n">rule_manager</span><span class="p">,</span>
    <span class="n">IntegrationTrapezeOperator</span>
<span class="p">)</span>

<span class="c1"># PyOperators stuff</span>
<span class="kn">from</span> <span class="nn">pysimulators</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pysimulators.interfaces.healpy</span> <span class="kn">import</span> <span class="n">HealpixConvolutionGaussianOperator</span>
<span class="kn">from</span> <span class="nn">pysm3</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">qubic.data</span> <span class="kn">import</span> <span class="n">PATH</span>

<span class="kn">from</span> <span class="nn">.Qinstrument</span> <span class="kn">import</span> <span class="n">compute_freq</span><span class="p">,</span> <span class="n">QubicInstrument</span><span class="p">,</span> <span class="n">QubicMultibandInstrument</span><span class="p">,</span> <span class="n">QubicMultibandInstrumentTrapezoidalIntegration</span>
<span class="kn">from</span> <span class="nn">..Qsamplings</span> <span class="kn">import</span> <span class="n">get_pointing</span>
<span class="kn">from</span> <span class="nn">..Qscene</span> <span class="kn">import</span> <span class="n">QubicScene</span>
<span class="c1">#import Qinstrument as instr</span>

<span class="c1"># FG-Buster packages</span>
<span class="kn">from</span> <span class="nn">fgbuster.mixingmatrix</span> <span class="kn">import</span> <span class="n">MixingMatrix</span>
<span class="c1">#from lib.Qmixing_matrix import MixingMatrix</span>


<div class="viewcode-block" id="arcmin2rad">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.arcmin2rad">[docs]</a>
<span class="k">def</span> <span class="nf">arcmin2rad</span><span class="p">(</span><span class="n">arcmin</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">arcmin</span> <span class="o">*</span> <span class="mf">0.000290888</span></div>



<div class="viewcode-block" id="create_array">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.create_array">[docs]</a>
<span class="k">def</span> <span class="nf">create_array</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">nus</span><span class="p">,</span> <span class="n">nside</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;noise&quot;</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">12</span> <span class="o">*</span> <span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nus</span><span class="p">)</span>
    <span class="n">pkl_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">PATH</span> <span class="o">+</span> <span class="s2">&quot;AllDataSet_Components_MapMaking.pkl&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pkl_file</span><span class="p">)</span>

    <span class="n">myarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nus</span><span class="p">):</span>
        <span class="n">myarray</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">myarray</span></div>



<div class="viewcode-block" id="QubicAcquisition">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition">[docs]</a>
<span class="k">class</span> <span class="nc">QubicAcquisition</span><span class="p">(</span><span class="n">Acquisition</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The QubicAcquisition class, which combines the instrument, sampling and</span>
<span class="sd">    scene models.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">sampling</span><span class="p">,</span> <span class="n">scene</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        acq = QubicAcquisition(instrument, sampling, scene, d)</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        instrument : QubicInstrument, optional</span>
<span class="sd">            The QubicInstrument instance.</span>
<span class="sd">        sampling : pointing</span>
<span class="sd">            Pointing obtained with get_pointing().</span>
<span class="sd">        scene : QubicScene, optional</span>
<span class="sd">            The discretized observed scene (the sky).</span>
<span class="sd">        d : dictionary with lot of parameters:</span>
<span class="sd">            block : tuple of slices, optional</span>
<span class="sd">                Partition of the samplings.</span>
<span class="sd">            effective_duration : float, optional</span>
<span class="sd">                If not None, the noise properties are rescaled so that this</span>
<span class="sd">                acquisition has an effective duration equal to the specified value,</span>
<span class="sd">                in years.</span>
<span class="sd">            photon_noise : boolean, optional</span>
<span class="sd">                If true, the photon noise contribution is included.</span>
<span class="sd">            max_nbytes : int or None, optional</span>
<span class="sd">                Maximum number of bytes to be allocated for the acquisition&#39;s</span>
<span class="sd">                operator.</span>
<span class="sd">            nprocs_instrument : int, optional</span>
<span class="sd">                For a given sampling slice, number of procs dedicated to</span>
<span class="sd">                the instrument.</span>
<span class="sd">            nprocs_sampling : int, optional</span>
<span class="sd">                For a given detector slice, number of procs dedicated to</span>
<span class="sd">                the sampling.</span>
<span class="sd">            comm : mpi4py.MPI.Comm, optional</span>
<span class="sd">                The acquisition&#39;s MPI communicator. Note that it is transformed</span>
<span class="sd">                into a 2d cartesian communicator before being stored as the &#39;comm&#39;</span>
<span class="sd">                attribute. The following relationship must hold:</span>
<span class="sd">                    comm.size = nprocs_instrument * nprocs_sampling</span>
<span class="sd">            psd : array-like, optional</span>
<span class="sd">                The one-sided or two-sided power spectrum density</span>
<span class="sd">                [signal unit/sqrt Hz].</span>
<span class="sd">            bandwidth : float, optional</span>
<span class="sd">                The PSD frequency increment [Hz].</span>
<span class="sd">            twosided : boolean, optional</span>
<span class="sd">                Whether or not the input psd is one-sided (only positive</span>
<span class="sd">                frequencies) or two-sided (positive and negative frequencies).</span>
<span class="sd">            sigma : float</span>
<span class="sd">                Standard deviation of the white noise component.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;block&quot;</span><span class="p">]</span>
        <span class="n">effective_duration</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;effective_duration&quot;</span><span class="p">]</span>
        <span class="n">photon_noise</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;photon_noise&quot;</span><span class="p">]</span>
        <span class="n">max_nbytes</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;max_nbytes&quot;</span><span class="p">]</span>
        <span class="n">nprocs_instrument</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;nprocs_instrument&quot;</span><span class="p">]</span>
        <span class="n">nprocs_sampling</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;nprocs_sampling&quot;</span><span class="p">]</span>
        <span class="n">comm</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;comm&quot;</span><span class="p">]</span>
        <span class="n">psd</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;psd&quot;</span><span class="p">]</span>
        <span class="n">bandwidth</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;bandwidth&quot;</span><span class="p">]</span>
        <span class="n">twosided</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;twosided&quot;</span><span class="p">]</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">]</span>

        <span class="n">Acquisition</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">instrument</span><span class="p">,</span>
            <span class="n">sampling</span><span class="p">,</span>
            <span class="n">scene</span><span class="p">,</span>
            <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">,</span>
            <span class="n">max_nbytes</span><span class="o">=</span><span class="n">max_nbytes</span><span class="p">,</span>
            <span class="n">nprocs_instrument</span><span class="o">=</span><span class="n">nprocs_instrument</span><span class="p">,</span>
            <span class="n">nprocs_sampling</span><span class="o">=</span><span class="n">nprocs_sampling</span><span class="p">,</span>
            <span class="n">comm</span><span class="o">=</span><span class="n">comm</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">photon_noise</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">photon_noise</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">effective_duration</span> <span class="o">=</span> <span class="n">effective_duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span> <span class="o">=</span> <span class="n">bandwidth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psd</span> <span class="o">=</span> <span class="n">psd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">twosided</span> <span class="o">=</span> <span class="n">twosided</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forced_sigma</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># print(&#39;Acq -&gt; &#39;, self.comm)</span>

<div class="viewcode-block" id="QubicAcquisition.get_coverage">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_coverage">[docs]</a>
    <span class="k">def</span> <span class="nf">get_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the acquisition scene coverage as given by H.T(1), normalized</span>
<span class="sd">        so that its integral over the sky is the number of detectors times</span>
<span class="sd">        the duration of the acquisition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_operator</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">))))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s2">&quot;I&quot;</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># to avoid keeping QU in memory</span>
        <span class="n">ndetectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">))</span>
        <span class="n">nsamplings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">))</span>
        <span class="c1"># nsamplings = self.comm.allreduce(len(self.sampling))</span>
        <span class="n">out</span> <span class="o">*=</span> <span class="n">ndetectors</span> <span class="o">*</span> <span class="n">nsamplings</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">period</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="QubicAcquisition.get_hitmap">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_hitmap">[docs]</a>
    <span class="k">def</span> <span class="nf">get_hitmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nside</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a healpy map whose values are the number of times a pointing</span>
<span class="sd">        hits the pixel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nside</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span>
        <span class="n">ipixel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">healpix</span><span class="p">(</span><span class="n">nside</span><span class="p">)</span>
        <span class="n">npixel</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">*</span> <span class="n">nside</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">ipixel</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">npixel</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">npixel</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># self.sampling.comm.Allreduce(MPI.IN_PLACE, as_mpi(hit), op=MPI.SUM)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Allreduce</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">IN_PLACE</span><span class="p">,</span> <span class="n">as_mpi</span><span class="p">(</span><span class="n">hit</span><span class="p">),</span> <span class="n">op</span><span class="o">=</span><span class="n">MPI</span><span class="o">.</span><span class="n">SUM</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hit</span></div>


<div class="viewcode-block" id="QubicAcquisition.get_noise">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_noise">[docs]</a>
    <span class="k">def</span> <span class="nf">get_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">det_noise</span><span class="p">,</span> <span class="n">photon_noise</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">get_noise</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="n">det_noise</span><span class="p">,</span> <span class="n">photon_noise</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective_duration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># nsamplings = self.comm.allreduce(len(self.sampling))</span>
            <span class="n">nsamplings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">))</span>

            <span class="n">out</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="n">nsamplings</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">period</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">effective_duration</span> <span class="o">*</span> <span class="mi">31557600</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


    <span class="n">get_noise</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Acquisition</span><span class="o">.</span><span class="n">get_noise</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="QubicAcquisition.get_aperture_integration_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_aperture_integration_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_aperture_integration_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Integrate flux density in the telescope aperture.</span>
<span class="sd">        Convert signal from W / m^2 / Hz into W / Hz.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">get_aperture_integration_operator</span><span class="p">()</span></div>


<div class="viewcode-block" id="QubicAcquisition.get_convolution_peak_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_convolution_peak_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_convolution_peak_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an operator that convolves the Healpix sky by the gaussian</span>
<span class="sd">        kernel that, if used in conjonction with the peak sampling operator,</span>
<span class="sd">        best approximates the synthetic beam.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">get_convolution_peak_operator</span><span class="p">(</span><span class="o">**</span><span class="n">keywords</span><span class="p">)</span></div>


<div class="viewcode-block" id="QubicAcquisition.get_detector_integration_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_detector_integration_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_detector_integration_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Integrate flux density in detector solid angles.</span>
<span class="sd">        Convert W / sr into W.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">get_detector_integration_operator</span><span class="p">()</span></div>


<div class="viewcode-block" id="QubicAcquisition.get_detector_response_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_detector_response_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_detector_response_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the operator for the bolometer responses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BlockDiagonalOperator</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">get_detector_response_operator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span>
            <span class="p">],</span>
            <span class="n">axisin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QubicAcquisition.get_distribution_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_distribution_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_distribution_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the MPI distribution operator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">MPIDistributionIdentityOperator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span></div>


<div class="viewcode-block" id="QubicAcquisition.get_filter_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_filter_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_filter_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the filter operator.</span>
<span class="sd">        Convert units from W/Hz to W.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">get_filter_operator</span><span class="p">()</span></div>


<div class="viewcode-block" id="QubicAcquisition.get_hwp_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_hwp_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_hwp_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the operator for the bolometer responses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BlockDiagonalOperator</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">get_hwp_operator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span>
            <span class="p">],</span>
            <span class="n">axisin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QubicAcquisition.get_diag_invntt_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_diag_invntt_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_diag_invntt_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Use diagonal noise covariance matrix&quot;</span><span class="p">)</span>

        <span class="n">sigma_detector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">detector</span><span class="o">.</span><span class="n">nep</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">period</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">photon_noise</span><span class="p">:</span>
            <span class="n">sigma_photon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">_get_noise_photon_nep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">period</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sigma_photon</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
            <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">sigma_detector</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sigma_photon</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
            <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span>
            <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">)),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective_duration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nsamplings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">))</span>
            <span class="n">out</span> <span class="o">/=</span> <span class="p">(</span>
                <span class="n">nsamplings</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">period</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">effective_duration</span> <span class="o">*</span> <span class="mi">31557600</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="QubicAcquisition.get_invntt_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_invntt_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_invntt_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">det_noise</span><span class="p">,</span> <span class="n">photon_noise</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the inverse time-time noise correlation matrix as an Operator.</span>

<span class="sd">        The input Power Spectrum Density can either be fully specified by using</span>
<span class="sd">        the &#39;bandwidth&#39; and &#39;psd&#39; keywords, or by providing the parameters of</span>
<span class="sd">        the gaussian distribution:</span>
<span class="sd">        psd = sigma**2 * (1 + (fknee/f)**fslope) / B</span>
<span class="sd">        where B is the sampling bandwidth equal to sampling_frequency / N.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sampling : Sampling</span>
<span class="sd">            The temporal sampling.</span>
<span class="sd">        psd : array-like, optional</span>
<span class="sd">            The one-sided or two-sided power spectrum density</span>
<span class="sd">            [signal unit/sqrt Hz].</span>
<span class="sd">        bandwidth : float, optional</span>
<span class="sd">            The PSD frequency increment [Hz].</span>
<span class="sd">        twosided : boolean, optional</span>
<span class="sd">            Whether or not the input psd is one-sided (only positive</span>
<span class="sd">            frequencies) or two-sided (positive and negative frequencies).</span>
<span class="sd">        sigma : float</span>
<span class="sd">            Standard deviation of the white noise component.</span>
<span class="sd">        sampling_frequency : float</span>
<span class="sd">            The sampling frequency [Hz].</span>
<span class="sd">        fftw_flag : string, optional</span>
<span class="sd">            The flags FFTW_ESTIMATE, FFTW_MEASURE, FFTW_PATIENT and</span>
<span class="sd">            FFTW_EXHAUSTIVE can be used to describe the increasing amount of</span>
<span class="sd">            effort spent during the planning stage to create the fastest</span>
<span class="sd">            possible transform. Usually, FFTW_MEASURE is a good compromise</span>
<span class="sd">            and is the default.</span>
<span class="sd">        nthreads : int, optional</span>
<span class="sd">            Tells how many threads to use when invoking FFTW or MKL. Default is</span>
<span class="sd">            the number of cores.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fftw_flag</span> <span class="o">=</span> <span class="s2">&quot;FFTW_MEASURE&quot;</span>
        <span class="n">nthreads</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># if self.bandwidth is None or self.psd is None:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The bandwidth or the PSD is not specified.&quot;</span><span class="p">)</span>

        <span class="c1"># Get sigma in Watt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">det_noise</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">detector</span><span class="o">.</span><span class="n">nep</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">period</span>
            <span class="p">)</span>
        <span class="c1"># print(self.sigma)</span>
        <span class="k">if</span> <span class="n">photon_noise</span><span class="p">:</span>
            <span class="n">sigma_photon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">_get_noise_photon_nep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">period</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sigma_photon</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># print(sigma_photon[0])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
            <span class="c1"># sigma_photon = 0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The noise model is not specified.&quot;</span><span class="p">)</span>

        <span class="c1"># print(&#39;In acquisition.py: self.forced_sigma={}&#39;.format(self.forced_sigma))</span>
        <span class="c1"># print(&#39;and self.sigma is:{}&#39;.format(self.sigma))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">forced_sigma</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># print(&#39;Using theoretical TES noises&#39;)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># print(&#39;Using self.forced_sigma as TES noises&#39;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forced_sigma</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">shapein</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">detector</span><span class="o">.</span><span class="n">fknee</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># print(&#39;diagonal case&#39;)</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
                <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span>
                <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">)),</span>
            <span class="p">)</span>
            <span class="c1"># print(out.shape)</span>
            <span class="c1"># print(out)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective_duration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># nsamplings = self.comm.allreduce(len(self.sampling))</span>
                <span class="n">nsamplings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">))</span>
                <span class="n">out</span> <span class="o">/=</span> <span class="p">(</span>
                    <span class="n">nsamplings</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">period</span>
                    <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">effective_duration</span> <span class="o">*</span> <span class="mi">31557600</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="n">sampling_frequency</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">period</span>

        <span class="n">nsamples_max</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">)</span>
        <span class="n">fftsize</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">while</span> <span class="n">fftsize</span> <span class="o">&lt;</span> <span class="n">nsamples_max</span><span class="p">:</span>
            <span class="n">fftsize</span> <span class="o">*=</span> <span class="mi">2</span>

        <span class="n">new_bandwidth</span> <span class="o">=</span> <span class="n">sampling_frequency</span> <span class="o">/</span> <span class="n">fftsize</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">twosided</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">psd</span> <span class="o">=</span> <span class="n">_fold_psd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psd</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">fftsize</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">new_bandwidth</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">_unfold_psd</span><span class="p">(</span><span class="n">_logloginterp_psd</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psd</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">_gaussian_psd_1f</span><span class="p">(</span>
                <span class="n">fftsize</span><span class="p">,</span>
                <span class="n">sampling_frequency</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">detector</span><span class="o">.</span><span class="n">fknee</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">detector</span><span class="o">.</span><span class="n">fslope</span><span class="p">,</span>
                <span class="n">twosided</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">p</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">invntt</span> <span class="o">=</span> <span class="n">_psd2invntt</span><span class="p">(</span>
            <span class="n">p</span><span class="p">,</span> <span class="n">new_bandwidth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">detector</span><span class="o">.</span><span class="n">ncorr</span><span class="p">,</span> <span class="n">fftw_flag</span><span class="o">=</span><span class="n">fftw_flag</span>
        <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;non diagonal case&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective_duration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nsamplings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">))</span>
            <span class="n">invntt</span> <span class="o">/=</span> <span class="p">(</span>
                <span class="n">nsamplings</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">period</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">effective_duration</span> <span class="o">*</span> <span class="mi">31557600</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">SymmetricBandToeplitzOperator</span><span class="p">(</span>
            <span class="n">shapein</span><span class="p">,</span> <span class="n">invntt</span><span class="p">,</span> <span class="n">fftw_flag</span><span class="o">=</span><span class="n">fftw_flag</span><span class="p">,</span> <span class="n">nthreads</span><span class="o">=</span><span class="n">nthreads</span>
        <span class="p">)</span></div>


    <span class="n">get_invntt_operator</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">Acquisition</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="o">.</span><span class="vm">__doc__</span>

<div class="viewcode-block" id="QubicAcquisition.get_unit_conversion_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_unit_conversion_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_unit_conversion_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert sky temperature into W / m^2 / Hz.</span>
<span class="sd">        If the scene has been initialised with the &#39;absolute&#39; keyword, the</span>
<span class="sd">        scene is assumed to include the CMB background and the fluctuations</span>
<span class="sd">        (in Kelvin) and the operator follows the non-linear Planck law.</span>
<span class="sd">        Otherwise, the scene only includes the fluctuations (in microKelvin)</span>
<span class="sd">        and the operator is linear (i.e. the output also corresponds to power</span>
<span class="sd">        fluctuations).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">nu</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">get_unit_conversion_operator</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span></div>


<div class="viewcode-block" id="QubicAcquisition.get_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the operator of the acquisition. Note that the operator is only</span>
<span class="sd">        linear if the scene temperature is differential (absolute=False).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">distribution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_distribution_operator</span><span class="p">()</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unit_conversion_operator</span><span class="p">()</span>
        <span class="n">aperture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_aperture_integration_operator</span><span class="p">()</span>
        <span class="nb">filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_operator</span><span class="p">()</span>
        <span class="n">projection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_projection_operator</span><span class="p">()</span>
        <span class="n">hwp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_hwp_operator</span><span class="p">()</span>
        <span class="n">polarizer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_polarizer_operator</span><span class="p">()</span>
        <span class="n">integ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_detector_integration_operator</span><span class="p">()</span>
        <span class="n">trans_inst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">get_transmission_operator</span><span class="p">()</span>
        <span class="n">trans_atm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">atmosphere</span><span class="o">.</span><span class="n">transmission</span>
        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_detector_response_operator</span><span class="p">()</span>

        <span class="k">with</span> <span class="n">rule_manager</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">CompositionOperator</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">response</span><span class="p">,</span>
                    <span class="n">trans_inst</span><span class="p">,</span>
                    <span class="n">integ</span><span class="p">,</span>
                    <span class="n">polarizer</span><span class="p">,</span>
                    <span class="n">hwp</span> <span class="o">*</span> <span class="n">projection</span><span class="p">,</span>
                    <span class="nb">filter</span><span class="p">,</span>
                    <span class="n">aperture</span><span class="p">,</span>
                    <span class="n">trans_atm</span><span class="p">,</span>
                    <span class="n">temp</span><span class="p">,</span>
                    <span class="n">distribution</span><span class="p">,</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span> <span class="o">==</span> <span class="s2">&quot;QU&quot;</span><span class="p">:</span>
            <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_subtract_grid_operator</span><span class="p">()(</span><span class="n">H</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">H</span></div>


<div class="viewcode-block" id="QubicAcquisition.get_polarizer_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_polarizer_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_polarizer_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return operator for the polarizer grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BlockDiagonalOperator</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">get_polarizer_operator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span>
            <span class="p">],</span>
            <span class="n">axisin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QubicAcquisition.get_projection_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_projection_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_projection_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the projection operator for the peak sampling.</span>
<span class="sd">        Convert units from W to W/sr.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If true, display information about the memory allocation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">get_projection_operator</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BlockColumnOperator</span><span class="p">(</span>
                <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">],</span>
                <span class="n">axisout</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># XXX HACK</span>
        <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">p</span>

        <span class="n">shapeouts</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span>
        <span class="p">]</span>
        <span class="n">proxies</span> <span class="o">=</span> <span class="n">proxy_group</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">),</span> <span class="n">callback</span><span class="p">,</span> <span class="n">shapeouts</span><span class="o">=</span><span class="n">shapeouts</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BlockColumnOperator</span><span class="p">(</span><span class="n">proxies</span><span class="p">,</span> <span class="n">axisout</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="QubicAcquisition.get_add_grids_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_add_grids_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_add_grids_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return operator to add signal from detector pairs.&quot;&quot;&quot;</span>
        <span class="n">nd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nd</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Odd number of detectors.&quot;</span><span class="p">)</span>
        <span class="n">partitionin</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">BlockRowOperator</span><span class="p">([</span><span class="n">I</span><span class="p">,</span> <span class="n">I</span><span class="p">],</span> <span class="n">axisin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">partitionin</span><span class="o">=</span><span class="n">partitionin</span><span class="p">)</span></div>


<div class="viewcode-block" id="QubicAcquisition.get_subtract_grids_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_subtract_grids_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_subtract_grids_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return operator to subtract signal from detector pairs.&quot;&quot;&quot;</span>
        <span class="n">nd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nd</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Odd number of detectors.&quot;</span><span class="p">)</span>
        <span class="n">partitionin</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">BlockRowOperator</span><span class="p">([</span><span class="n">I</span><span class="p">,</span> <span class="o">-</span><span class="n">I</span><span class="p">],</span> <span class="n">axisin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">partitionin</span><span class="o">=</span><span class="n">partitionin</span><span class="p">)</span></div>


<div class="viewcode-block" id="QubicAcquisition.get_observation">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_observation">[docs]</a>
    <span class="k">def</span> <span class="nf">get_observation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="n">convolution</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">noiseless</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        tod = map2tod(acquisition, map)</span>
<span class="sd">        tod, convolved_map = map2tod(acquisition, map, convolution=True)</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        map : I, QU or IQU maps</span>
<span class="sd">            Temperature, QU or IQU maps of shapes npix, (npix, 2), (npix, 3)</span>
<span class="sd">            with npix = 12 * nside**2</span>
<span class="sd">        noiseless : boolean, optional</span>
<span class="sd">            If True, no noise is added to the observation.</span>
<span class="sd">        convolution : boolean, optional</span>
<span class="sd">            Set to True to convolve the input map by a gaussian and return it.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tod : array</span>
<span class="sd">            The Time-Ordered-Data of shape (ndetectors, ntimes).</span>
<span class="sd">        convolved_map : array, optional</span>
<span class="sd">            The convolved map, if the convolution keyword is set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">convolution</span><span class="p">:</span>
            <span class="n">convolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_convolution_peak_operator</span><span class="p">()</span>
            <span class="nb">map</span> <span class="o">=</span> <span class="n">convolution</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_operator</span><span class="p">()</span>
        <span class="n">tod</span> <span class="o">=</span> <span class="n">H</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">noiseless</span><span class="p">:</span>
            <span class="n">tod</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_noise</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">convolution</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tod</span><span class="p">,</span> <span class="nb">map</span>

        <span class="k">return</span> <span class="n">tod</span></div>


<div class="viewcode-block" id="QubicAcquisition.get_preconditioner">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicAcquisition.get_preconditioner">[docs]</a>
    <span class="k">def</span> <span class="nf">get_preconditioner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cov</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cov_inv</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">cov</span>
            <span class="n">cov_inv</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">cov_inv</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">preconditioner</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span><span class="n">cov_inv</span><span class="p">,</span> <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">preconditioner</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">preconditioner</span></div>
</div>

<div class="viewcode-block" id="PlanckAcquisition">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.PlanckAcquisition">[docs]</a>
<span class="k">class</span> <span class="nc">PlanckAcquisition</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">scene</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">band</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">143</span><span class="p">,</span> <span class="mi">217</span><span class="p">,</span> <span class="mi">353</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid band &#39;</span><span class="si">{}</span><span class="s2">&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">band</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scene</span> <span class="o">=</span> <span class="n">scene</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">band</span> <span class="o">=</span> <span class="n">band</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span>

        <span class="k">if</span> <span class="n">band</span> <span class="o">==</span> <span class="mi">30</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;Variance_Planck30GHz_Kcmb2_ns256.fits&quot;</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">var</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ud_grade</span><span class="p">(</span>
                    <span class="n">hp</span><span class="o">.</span><span class="n">fitsfunc</span><span class="o">.</span><span class="n">read_map</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span>
                <span class="p">)</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">band</span> <span class="o">==</span> <span class="mi">44</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;Variance_Planck44GHz_Kcmb2_ns256.fits&quot;</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">var</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ud_grade</span><span class="p">(</span>
                    <span class="n">hp</span><span class="o">.</span><span class="n">fitsfunc</span><span class="o">.</span><span class="n">read_map</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span>
                <span class="p">)</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">band</span> <span class="o">==</span> <span class="mi">70</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;Variance_Planck70GHz_Kcmb2_ns256.fits&quot;</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">var</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ud_grade</span><span class="p">(</span>
                    <span class="n">hp</span><span class="o">.</span><span class="n">fitsfunc</span><span class="o">.</span><span class="n">read_map</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span>
                <span class="p">)</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">band</span> <span class="o">==</span> <span class="mi">143</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;Variance_Planck143GHz_Kcmb2_ns256.fits&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">FitsArray</span><span class="p">(</span><span class="n">PATH</span> <span class="o">+</span> <span class="n">filename</span><span class="p">))</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">band</span> <span class="o">==</span> <span class="mi">217</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;Variance_Planck217GHz_Kcmb2_ns256.fits&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">FitsArray</span><span class="p">(</span><span class="n">PATH</span> <span class="o">+</span> <span class="n">filename</span><span class="p">))</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;Variance_Planck353GHz_Kcmb2_ns256.fits&quot;</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">var</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ud_grade</span><span class="p">(</span>
                    <span class="n">hp</span><span class="o">.</span><span class="n">fitsfunc</span><span class="o">.</span><span class="n">read_map</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span>
                <span class="p">)</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scene</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;I&quot;</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">scene</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;QU&quot;</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="o">!=</span> <span class="mi">256</span><span class="p">:</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">ud_grade</span><span class="p">(</span><span class="n">sigma</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="mf">1e6</span>

<div class="viewcode-block" id="PlanckAcquisition.get_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.PlanckAcquisition.get_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nintegr</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">Hp</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
            <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span>
            <span class="n">shapein</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">shapeout</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">nintegr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Hp</span></div>


<div class="viewcode-block" id="PlanckAcquisition.get_invntt_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.PlanckAcquisition.get_invntt_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_invntt_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beam_correction</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seenpix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">beam_correction</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span>
                <span class="mi">4</span>
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                <span class="o">*</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">beam_correction</span><span class="p">)</span>
                    <span class="o">/</span> <span class="mf">2.35</span>
                    <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">nside2resol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="p">))</span>
                <span class="p">)</span>
                <span class="o">**</span> <span class="mi">2</span>
            <span class="p">)</span>
            <span class="c1"># print(f&#39;corrected by {factor}&#39;)</span>
            <span class="n">varnew</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">hp</span><span class="o">.</span><span class="n">smoothing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="n">beam_correction</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">factor</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">varnew</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">myweight</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DiagonalOperator</span><span class="p">(</span><span class="n">myweight</span><span class="p">,</span> <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;leftward&quot;</span><span class="p">,</span> <span class="n">shapein</span><span class="o">=</span><span class="n">myweight</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="PlanckAcquisition.get_noise">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.PlanckAcquisition.get_noise">[docs]</a>
    <span class="k">def</span> <span class="nf">get_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">get_state</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span>
        <span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="PlanckAcquisition.get_map">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.PlanckAcquisition.get_map">[docs]</a>
    <span class="k">def</span> <span class="nf">get_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu_min</span><span class="p">,</span> <span class="n">nu_max</span><span class="p">,</span> <span class="n">Nintegr</span><span class="p">,</span> <span class="n">sky_config</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Integration from </span><span class="si">{</span><span class="n">nu_min</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">nu_max</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> GHz with </span><span class="si">{</span><span class="n">Nintegr</span><span class="si">}</span><span class="s2"> steps&quot;</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">QubicIntegrated</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Nsub</span><span class="o">=</span><span class="n">Nintegr</span><span class="p">,</span> <span class="n">Nrec</span><span class="o">=</span><span class="n">Nintegr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Nintegr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">allnus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">nu_min</span><span class="p">,</span> <span class="n">nu_max</span><span class="p">])])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">allnus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">nu_min</span><span class="p">,</span> <span class="n">nu_max</span><span class="p">,</span> <span class="n">Nintegr</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">get_PySM_maps</span><span class="p">(</span><span class="n">sky_config</span><span class="p">,</span> <span class="n">nus</span><span class="o">=</span><span class="n">allnus</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fwhm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fwhm</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Nintegr</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nintegr</span><span class="p">):</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">HealpixConvolutionGaussianOperator</span><span class="p">(</span><span class="n">fwhm</span><span class="o">=</span><span class="n">fwhm</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">)</span>
            <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="QubicMultiAcquisitions">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicMultiAcquisitions">[docs]</a>
<span class="k">class</span> <span class="nc">QubicMultiAcquisitions</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Instance to define the multi-frequency instrument.</span>

<span class="sd">    Input : - dictionary : contains QUBIC informations</span>
<span class="sd">            - Nsub : Number of sub-bands for integrating the physical bandwidth</span>
<span class="sd">            - Nrec : Number of reconstructed maps (in the case of FMM)</span>
<span class="sd">            - comps : List of astrophysical components (CMB, Dust, ...)</span>
<span class="sd">            - H : List of pointing matrix if not already computed</span>
<span class="sd">            - nu_co : Frequency of a line emission</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">nsub</span><span class="p">,</span> <span class="n">nrec</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">comps</span><span class="o">=</span><span class="p">[],</span> <span class="n">H</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nu_co</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1">### Define class arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="o">=</span> <span class="n">dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsub</span> <span class="o">=</span> <span class="n">nsub</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrec</span> <span class="o">=</span> <span class="n">nrec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s2">&quot;nf_sub&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsub</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comps</span> <span class="o">=</span> <span class="n">comps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fsub</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsub</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrec</span><span class="p">)</span>

        <span class="c1">### Compute frequencies on the edges</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">allnus_edges_150</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_freq</span><span class="p">(</span>
            <span class="mi">150</span><span class="p">,</span>
            <span class="n">Nfreq</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsub</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">relative_bandwidth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s2">&quot;filter_relative_bandwidth&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">allnus_edges_220</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_freq</span><span class="p">(</span>
            <span class="mi">220</span><span class="p">,</span>
            <span class="n">Nfreq</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsub</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">relative_bandwidth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s2">&quot;filter_relative_bandwidth&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1">### Compute the effective reconstructed frequencies if FMM is applied</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">nus150</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_freq</span><span class="p">(</span>
            <span class="mi">150</span><span class="p">,</span>
            <span class="n">Nfreq</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
            <span class="n">relative_bandwidth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s2">&quot;filter_relative_bandwidth&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">nus220</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_freq</span><span class="p">(</span>
            <span class="mi">220</span><span class="p">,</span>
            <span class="n">Nfreq</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
            <span class="n">relative_bandwidth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s2">&quot;filter_relative_bandwidth&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1">### Joint 150 and 220 GHz band</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allnus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">allnus_edges_150</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">allnus_edges_220</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allnus_rec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nus150</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">nus220</span><span class="p">))</span>

        <span class="c1">### Multi-frequency instrument</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span> <span class="o">=</span> <span class="n">QubicMultibandInstrumentTrapezoidalIntegration</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dict</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span> <span class="o">=</span> <span class="n">get_pointing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scene</span> <span class="o">=</span> <span class="n">QubicScene</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npix</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1">### Compute pointing matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">QubicAcquisition</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="c1">### CO line emission</span>
        <span class="k">if</span> <span class="n">nu_co</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dmono</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">dmono</span><span class="p">[</span><span class="s1">&#39;filter_nu&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nu_co</span> <span class="o">*</span> <span class="mf">1e9</span>

            <span class="n">w</span> <span class="o">=</span> <span class="n">IntegrationTrapezeOperator</span><span class="p">(</span><span class="n">allnus_edges_220</span><span class="p">)</span>
            <span class="n">deltas_trap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">w</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">todense</span><span class="p">(</span><span class="n">shapein</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">allnus_edges_220</span><span class="p">))])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="n">dmono</span><span class="p">[</span><span class="s1">&#39;filter_relative_bandwidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.05</span><span class="c1">#deltas_trap / nu_co</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">nu_co</span><span class="p">,</span> <span class="n">deltas_trap</span><span class="p">,</span> <span class="n">deltas_trap</span> <span class="o">/</span> <span class="n">nu_co</span><span class="p">)</span>

            <span class="n">instrument_co</span> <span class="o">=</span> <span class="n">QubicInstrument</span><span class="p">(</span><span class="n">dmono</span><span class="p">,</span> <span class="n">FRBW</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span><span class="c1">#dmono[&#39;filter_relative_bandwidth&#39;])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="o">.</span><span class="n">subinstruments</span> <span class="o">+=</span> <span class="p">[</span><span class="n">instrument_co</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">QubicAcquisition</span><span class="p">(</span><span class="n">instrument_co</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="n">dmono</span><span class="p">)]</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">allnus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allnus</span><span class="p">,</span> <span class="n">nu_co</span><span class="p">)</span>
        <span class="c1">#print(self.allnus)</span>
        <span class="c1">#stop</span>
        <span class="c1">### Angular resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allfwhm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">allfwhm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_convolution_peak_operator</span><span class="p">()</span><span class="o">.</span><span class="n">fwhm</span>

        <span class="c1">### Compute the pointing matrix if not already done</span>
        <span class="k">if</span> <span class="n">H</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_operator</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="n">H</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coverage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">shapein</span><span class="p">))[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1">### Save MPI communicator</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s2">&quot;nprocs_instrument&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpidist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpidist</span>

        <span class="c1">### Define the number of detector and sampling (for each processors)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">instrument</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_mixing_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nus</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Method to return mixing matrix.</span>

<span class="sd">        If beta has shape (ncomp), then the mixing matrix will have shape (nfreq, ncomp).</span>
<span class="sd">        If beta has shape (npix, ncomp), the the elements of the mxing matrix vary across the sky, it will have shape (npix, nfreq, ncomp)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">### Define Mixing Matrix with FGB classes</span>
        <span class="n">mm</span> <span class="o">=</span> <span class="n">MixingMatrix</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">comps</span><span class="p">)</span>

        <span class="c1">### Compute them using the eval method at each frequency nus</span>
        <span class="n">mixing_matrix_elements</span> <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">nus</span><span class="p">,</span> <span class="o">*</span><span class="n">beta</span><span class="p">)</span>

        <span class="n">_sh</span> <span class="o">=</span> <span class="n">mixing_matrix_elements</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">_sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">beta</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ud_grade</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="p">)</span>
            <span class="n">mixing_matrix_elements</span> <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">nus</span><span class="p">,</span> <span class="o">*</span><span class="n">beta</span><span class="p">)</span>

            <span class="n">mixing_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">mixing_matrix_elements</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mixing_matrix</span> <span class="o">=</span> <span class="n">mixing_matrix_elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">mixing_matrix</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_mixing_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Method to define an operator like object for a given frequency nu, the input A should be for one frequency.</span>
<span class="sd">        The type of operator depends on the shape of input A.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1">### If constant beta across the sky</span>

            <span class="n">r</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">DenseOperator</span><span class="p">(</span>
                <span class="n">A</span><span class="p">,</span>
                <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span>
                <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                <span class="n">shapeout</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1">### If varying beta across the sky</span>

            <span class="n">r</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>

            <span class="k">def</span> <span class="nf">reshape_fct</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">T</span>

            <span class="n">R</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">(</span>
                <span class="n">direct</span><span class="o">=</span><span class="n">reshape_fct</span><span class="p">,</span>
                <span class="n">transpose</span><span class="o">=</span><span class="n">reshape_fct</span><span class="p">,</span>
                <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                <span class="n">shapeout</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="n">nc</span><span class="p">),</span>
                <span class="n">flags</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1">### if pixelization of A is lower than the one of components</span>
            <span class="k">if</span> <span class="n">hp</span><span class="o">.</span><span class="n">npix2nside</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="p">:</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ud_grade</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="n">d</span> <span class="o">=</span> <span class="n">DenseBlockDiagonalOperator</span><span class="p">(</span>
                <span class="n">A</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span> <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="n">nc</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1">### Multiply by 3 to create A matrix for I, Q and U</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">BlockDiagonalOperator</span><span class="p">([</span><span class="n">d</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">new_axisout</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">R</span>

        <span class="k">return</span> <span class="n">D</span></div>

<div class="viewcode-block" id="QubicDualBand">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicDualBand">[docs]</a>
<span class="k">class</span> <span class="nc">QubicDualBand</span><span class="p">(</span><span class="n">QubicMultiAcquisitions</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">nsub</span><span class="p">,</span> <span class="n">nrec</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">comps</span><span class="o">=</span><span class="p">[],</span> <span class="n">H</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nu_co</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">QubicMultiAcquisitions</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">nsub</span><span class="o">=</span><span class="n">nsub</span><span class="p">,</span> <span class="n">nrec</span><span class="o">=</span><span class="n">nrec</span><span class="p">,</span> <span class="n">comps</span><span class="o">=</span><span class="n">comps</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">nu_co</span><span class="o">=</span><span class="n">nu_co</span>
        <span class="p">)</span>

<div class="viewcode-block" id="QubicDualBand.sum_over_band">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicDualBand.sum_over_band">[docs]</a>
    <span class="k">def</span> <span class="nf">sum_over_band</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">algo</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Perform sum over sub-operators depending on the reconstruction algorithms (FMM or CMM)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">op_sum</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsub</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrec</span><span class="p">)</span>

        <span class="c1">### Frequency Map-Making</span>
        <span class="k">if</span> <span class="n">algo</span> <span class="o">==</span> <span class="s2">&quot;FMM&quot;</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">irec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrec</span><span class="p">):</span>
                <span class="n">imin</span> <span class="o">=</span> <span class="n">irec</span> <span class="o">*</span> <span class="n">f</span>
                <span class="n">imax</span> <span class="o">=</span> <span class="p">(</span><span class="n">irec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">op_sum</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="n">h</span><span class="p">[</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allnus</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allnus</span><span class="p">[</span><span class="n">imin</span><span class="p">])</span>
                        <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allnus</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allnus</span><span class="p">[</span><span class="n">imax</span><span class="p">])</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrec</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BlockDiagonalOperator</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">BlockRowOperator</span><span class="p">(</span><span class="n">op_sum</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                        <span class="n">BlockRowOperator</span><span class="p">(</span>
                            <span class="n">op_sum</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrec</span><span class="p">)],</span> <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span>
                        <span class="p">),</span>
                    <span class="p">],</span>
                    <span class="n">axisout</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ReshapeOperator</span><span class="p">(</span>
                    <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndets</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>
                <span class="p">)</span> <span class="o">*</span> <span class="n">BlockDiagonalOperator</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">BlockRowOperator</span><span class="p">(</span><span class="n">op_sum</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                        <span class="n">BlockRowOperator</span><span class="p">(</span>
                            <span class="n">op_sum</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrec</span><span class="p">)],</span> <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span>
                        <span class="p">),</span>
                    <span class="p">],</span>
                    <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1">### Components Map-Making</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">G150</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">),</span>
                    <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span>
                    <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="n">G220</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">),</span>
                    <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span>
                    <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G150</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
                    <span class="n">gain</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span>
                    <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="n">G220</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
                    <span class="n">gain</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                    <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span>
                    <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">BlockColumnOperator</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">G150</span> <span class="o">*</span> <span class="n">AdditionOperator</span><span class="p">(</span><span class="n">h</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsub</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)]),</span>
                    <span class="n">G220</span> <span class="o">*</span> <span class="n">AdditionOperator</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsub</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">:]),</span>
                <span class="p">],</span>
                <span class="n">axisout</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="QubicDualBand.get_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicDualBand.get_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seenpix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Method to generate the pointing matrix.</span>

<span class="sd">        mixing_matrix : array like containing mixing matrix elements. If the elements of the mixing matrix are constant across the sky,</span>
<span class="sd">                        mixing_matrix.shape = (nfreq, ncomp)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">isub</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsub</span><span class="p">):</span>

            <span class="c1">### Compute mixing matrix operator if mixing matrix is provided</span>
            <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Acomp</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">()</span>
                <span class="n">algo</span> <span class="o">=</span> <span class="s2">&quot;FMM&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Acomp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mixing_operator</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">isub</span><span class="p">])</span>
                <span class="n">algo</span> <span class="o">=</span> <span class="s2">&quot;CMM&quot;</span>

            <span class="c1">### Compute gaussian kernel to account for angular resolution</span>
            <span class="k">if</span> <span class="n">fwhm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">convolution</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">convolution</span> <span class="o">=</span> <span class="n">HealpixConvolutionGaussianOperator</span><span class="p">(</span>
                    <span class="n">fwhm</span><span class="o">=</span><span class="n">fwhm</span><span class="p">[</span><span class="n">isub</span><span class="p">],</span> <span class="n">lmax</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span>
                <span class="p">)</span>

            <span class="c1">### Compose operator as H = Proj * C * A</span>
            <span class="k">with</span> <span class="n">rule_manager</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">hi</span> <span class="o">=</span> <span class="n">CompositionOperator</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">isub</span><span class="p">],</span> <span class="n">convolution</span><span class="p">,</span> <span class="n">Acomp</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hi</span><span class="p">)</span>

        <span class="c1">### Do the sum over operators depending on the reconstruction model</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_over_band</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">algo</span><span class="o">=</span><span class="n">algo</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="n">gain</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">H</span></div>


<div class="viewcode-block" id="QubicDualBand.get_invntt_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicDualBand.get_invntt_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_invntt_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Method to compute the inverse noise covariance matrix in time-domain.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">d150</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d150</span><span class="p">[</span><span class="s2">&quot;filter_nu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">150</span> <span class="o">*</span> <span class="mf">1e9</span>
        <span class="n">d150</span><span class="p">[</span><span class="s2">&quot;effective_duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s2">&quot;effective_duration150&quot;</span><span class="p">]</span>
        <span class="n">ins150</span> <span class="o">=</span> <span class="n">QubicInstrument</span><span class="p">(</span><span class="n">d150</span><span class="p">)</span>

        <span class="n">d220</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d220</span><span class="p">[</span><span class="s2">&quot;effective_duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s2">&quot;effective_duration220&quot;</span><span class="p">]</span>
        <span class="n">d220</span><span class="p">[</span><span class="s2">&quot;filter_nu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">220</span> <span class="o">*</span> <span class="mf">1e9</span>

        <span class="n">ins220</span> <span class="o">=</span> <span class="n">QubicInstrument</span><span class="p">(</span><span class="n">d220</span><span class="p">)</span>

        <span class="n">subacq150</span> <span class="o">=</span> <span class="n">QubicAcquisition</span><span class="p">(</span><span class="n">ins150</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="n">d150</span><span class="p">)</span>
        <span class="n">subacq220</span> <span class="o">=</span> <span class="n">QubicAcquisition</span><span class="p">(</span><span class="n">ins220</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="n">d220</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">invn150</span> <span class="o">=</span> <span class="n">subacq150</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">(</span><span class="n">det_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">photon_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invn220</span> <span class="o">=</span> <span class="n">subacq220</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">(</span><span class="n">det_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">photon_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">BlockDiagonalOperator</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">invn150</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">invn220</span><span class="p">],</span> <span class="n">axisout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>
</div>

<div class="viewcode-block" id="QubicUltraWideBand">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicUltraWideBand">[docs]</a>
<span class="k">class</span> <span class="nc">QubicUltraWideBand</span><span class="p">(</span><span class="n">QubicMultiAcquisitions</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">nsub</span><span class="p">,</span> <span class="n">nrec</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">comps</span><span class="o">=</span><span class="p">[],</span> <span class="n">H</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nu_co</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">QubicMultiAcquisitions</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">nsub</span><span class="o">=</span><span class="n">nsub</span><span class="p">,</span> <span class="n">nrec</span><span class="o">=</span><span class="n">nrec</span><span class="p">,</span> <span class="n">comps</span><span class="o">=</span><span class="n">comps</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">nu_co</span><span class="o">=</span><span class="n">nu_co</span>
        <span class="p">)</span>

<div class="viewcode-block" id="QubicUltraWideBand.sum_over_band">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicUltraWideBand.sum_over_band">[docs]</a>
    <span class="k">def</span> <span class="nf">sum_over_band</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">algo</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Perform sum over sub-operators depending on the reconstruction algorithms (FMM or CMM)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">op_sum</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsub</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrec</span><span class="p">)</span>

        <span class="c1">### Frequency Map-Making</span>
        <span class="k">if</span> <span class="n">algo</span> <span class="o">==</span> <span class="s2">&quot;FMM&quot;</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">irec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrec</span><span class="p">):</span>
                <span class="n">imin</span> <span class="o">=</span> <span class="n">irec</span> <span class="o">*</span> <span class="n">f</span>
                <span class="n">imax</span> <span class="o">=</span> <span class="p">(</span><span class="n">irec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">op_sum</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="n">h</span><span class="p">[</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allnus</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allnus</span><span class="p">[</span><span class="n">imin</span><span class="p">])</span>
                        <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allnus</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allnus</span><span class="p">[</span><span class="n">imax</span><span class="p">])</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">]</span>

            <span class="k">return</span> <span class="n">BlockRowOperator</span><span class="p">(</span><span class="n">op_sum</span><span class="p">,</span> <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1">### Components Map-Making</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">G</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">),</span>
                    <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span>
                    <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
                    <span class="n">gain</span><span class="p">,</span> <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span> <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">G</span> <span class="o">*</span> <span class="n">AdditionOperator</span><span class="p">(</span><span class="n">h</span><span class="p">)</span></div>


<div class="viewcode-block" id="QubicUltraWideBand.get_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicUltraWideBand.get_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Method to generate the pointing matrix.</span>

<span class="sd">        mixing_matrix : array like containing mixing matrix elements. If the elements of the mixing matrix are constant across the sky,</span>
<span class="sd">                        mixing_matrix.shape = (nfreq, ncomp)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">isub</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsub</span><span class="p">):</span>

            <span class="c1">### Compute mixing matrix operator if mixing matrix is provided</span>
            <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Acomp</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">()</span>
                <span class="n">algo</span> <span class="o">=</span> <span class="s2">&quot;FMM&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Acomp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mixing_operator</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">isub</span><span class="p">])</span>
                <span class="n">algo</span> <span class="o">=</span> <span class="s2">&quot;CMM&quot;</span>

            <span class="c1">### Compute gaussian kernel to account for angular resolution</span>
            <span class="k">if</span> <span class="n">fwhm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">convolution</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">convolution</span> <span class="o">=</span> <span class="n">HealpixConvolutionGaussianOperator</span><span class="p">(</span>
                    <span class="n">fwhm</span><span class="o">=</span><span class="n">fwhm</span><span class="p">[</span><span class="n">isub</span><span class="p">],</span> <span class="n">lmax</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s2">&quot;nside&quot;</span><span class="p">]</span>
                <span class="p">)</span>

            <span class="c1">### Compose operator as H = Proj * C * A</span>
            <span class="k">with</span> <span class="n">rule_manager</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">hi</span> <span class="o">=</span> <span class="n">CompositionOperator</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">isub</span><span class="p">],</span> <span class="n">convolution</span><span class="p">,</span> <span class="n">Acomp</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hi</span><span class="p">)</span>

        <span class="c1">### Do the sum over operators depending on the reconstruction model</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_over_band</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span> <span class="n">algo</span><span class="o">=</span><span class="n">algo</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">H</span></div>


<div class="viewcode-block" id="QubicUltraWideBand.get_invntt_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicUltraWideBand.get_invntt_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_invntt_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Method to compute the inverse noise covariance matrix in time-domain.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">d150</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d150</span><span class="p">[</span><span class="s2">&quot;filter_nu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">150</span> <span class="o">*</span> <span class="mf">1e9</span>
        <span class="n">d150</span><span class="p">[</span><span class="s2">&quot;effective_duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s2">&quot;effective_duration150&quot;</span><span class="p">]</span>
        <span class="n">ins150</span> <span class="o">=</span> <span class="n">QubicInstrument</span><span class="p">(</span><span class="n">d150</span><span class="p">)</span>

        <span class="n">d220</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d220</span><span class="p">[</span><span class="s2">&quot;effective_duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="s2">&quot;effective_duration220&quot;</span><span class="p">]</span>
        <span class="n">d220</span><span class="p">[</span><span class="s2">&quot;filter_nu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">220</span> <span class="o">*</span> <span class="mf">1e9</span>

        <span class="n">ins220</span> <span class="o">=</span> <span class="n">QubicInstrument</span><span class="p">(</span><span class="n">d220</span><span class="p">)</span>

        <span class="n">subacq150</span> <span class="o">=</span> <span class="n">QubicAcquisition</span><span class="p">(</span><span class="n">ins150</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="n">d150</span><span class="p">)</span>
        <span class="n">subacq220</span> <span class="o">=</span> <span class="n">QubicAcquisition</span><span class="p">(</span><span class="n">ins220</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="n">d220</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">invn150</span> <span class="o">=</span> <span class="n">subacq150</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">(</span><span class="n">det_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">photon_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invn220</span> <span class="o">=</span> <span class="n">subacq220</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">(</span><span class="n">det_noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">photon_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">invn150</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">invn220</span></div>
</div>


<div class="viewcode-block" id="OtherDataParametric">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.OtherDataParametric">[docs]</a>
<span class="k">class</span> <span class="nc">OtherDataParametric</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nus</span><span class="p">,</span> <span class="n">nside</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">nintegr</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>

        <span class="c1"># if nintegr == 1:</span>
        <span class="c1">#    raise TypeError(&#39;The integration of external data should be greater than 1&#39;)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nintegr</span> <span class="o">=</span> <span class="n">nintegr</span>
        <span class="n">pkl_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">PATH</span> <span class="o">+</span> <span class="s2">&quot;AllDataSet_Components_MapMaking.pkl&quot;</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">pkl_file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nus</span> <span class="o">=</span> <span class="n">nus</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="o">=</span> <span class="n">nside</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npix</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bw</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nus</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nintegr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;bw</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span> <span class="o">=</span> <span class="n">arcmin2rad</span><span class="p">(</span><span class="n">create_array</span><span class="p">(</span><span class="s2">&quot;fwhm&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nus</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comps</span> <span class="o">=</span> <span class="n">comps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comps</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nintegr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">allnus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nus</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">allnus</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">inu</span><span class="p">,</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nus</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">allnus</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                        <span class="n">nu</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">bw</span><span class="p">[</span><span class="n">inu</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">nu</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">bw</span><span class="p">[</span><span class="n">inu</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nintegr</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">allnus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allnus</span><span class="p">)</span>
        <span class="c1">### Compute all external nus</span>

    <span class="k">def</span> <span class="nf">_get_mixing_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nus</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Method to return mixing matrix.</span>

<span class="sd">        If beta has shape (ncomp), then the mixing matrix will have shape (nfreq, ncomp).</span>
<span class="sd">        If beta has shape (npix, ncomp), the the elements of the mxing matrix vary across the sky, it will have shape (npix, nfreq, ncomp)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">### Define Mixing Matrix with FGB classes</span>
        <span class="n">mm</span> <span class="o">=</span> <span class="n">MixingMatrix</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">comps</span><span class="p">)</span>

        <span class="c1">### Compute them using the eval method at each frequency nus</span>
        <span class="n">mixing_matrix_elements</span> <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">nus</span><span class="p">,</span> <span class="o">*</span><span class="n">beta</span><span class="p">)</span>

        <span class="n">_sh</span> <span class="o">=</span> <span class="n">mixing_matrix_elements</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">_sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">beta</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ud_grade</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">)</span>
            <span class="n">mixing_matrix_elements</span> <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">nus</span><span class="p">,</span> <span class="o">*</span><span class="n">beta</span><span class="p">)</span>

            <span class="n">mixing_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">mixing_matrix_elements</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mixing_matrix</span> <span class="o">=</span> <span class="n">mixing_matrix_elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">mixing_matrix</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_mixing_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Method to define an operator like object for a given frequency nu, the input A should be for one frequency.</span>
<span class="sd">        The type of operator depends on the shape of input A.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1">### If constant beta across the sky</span>

            <span class="n">r</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">DenseOperator</span><span class="p">(</span>
                <span class="n">A</span><span class="p">,</span>
                <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span>
                <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                <span class="n">shapeout</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1">### If varying beta across the sky</span>

            <span class="n">r</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span>

            <span class="k">def</span> <span class="nf">reshape_fct</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
                <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">T</span>

            <span class="n">R</span> <span class="o">=</span> <span class="n">Operator</span><span class="p">(</span>
                <span class="n">direct</span><span class="o">=</span><span class="n">reshape_fct</span><span class="p">,</span>
                <span class="n">transpose</span><span class="o">=</span><span class="n">reshape_fct</span><span class="p">,</span>
                <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                <span class="n">shapeout</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="n">nc</span><span class="p">),</span>
                <span class="n">flags</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1">### if pixelization of A is lower than the one of components</span>
            <span class="k">if</span> <span class="n">hp</span><span class="o">.</span><span class="n">npix2nside</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">:</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ud_grade</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="n">d</span> <span class="o">=</span> <span class="n">DenseBlockDiagonalOperator</span><span class="p">(</span>
                <span class="n">A</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span> <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="n">nc</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1">### Multiply by 3 to create A matrix for I, Q and U</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">BlockDiagonalOperator</span><span class="p">([</span><span class="n">d</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">new_axisout</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">R</span>

        <span class="k">return</span> <span class="n">D</span>

<div class="viewcode-block" id="OtherDataParametric.get_invntt_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.OtherDataParametric.get_invntt_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_invntt_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fact</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Create an empty array to store the values of sigma</span>
        <span class="n">allsigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="c1"># Iterate through the frequency values</span>
        <span class="k">for</span> <span class="n">inu</span><span class="p">,</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nus</span><span class="p">):</span>
            <span class="c1"># Determine the scaling factor for the noise</span>
            <span class="k">if</span> <span class="n">fact</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">fact</span><span class="p">[</span><span class="n">inu</span><span class="p">]</span>

            <span class="c1"># Get the noise value for the current frequency and upsample to the desired nside</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">hp</span><span class="o">.</span><span class="n">ud_grade</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;noise</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nu</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sigma</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

            <span class="c1"># Append the noise value to the list of all sigmas</span>
            <span class="n">allsigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">allsigma</span><span class="p">,</span> <span class="n">sigma</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

        <span class="c1"># Flatten the list of sigmas and create a diagonal operator</span>
        <span class="n">allsigma</span> <span class="o">=</span> <span class="n">allsigma</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">invN</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
            <span class="mi">1</span> <span class="o">/</span> <span class="n">allsigma</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;leftward&quot;</span><span class="p">,</span>
            <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nus</span><span class="p">)</span> <span class="o">*</span> <span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Create reshape operator and apply it to the diagonal operator</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">(</span><span class="n">invN</span><span class="o">.</span><span class="n">shapeout</span><span class="p">,</span> <span class="n">invN</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">R</span><span class="p">(</span><span class="n">invN</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">))</span></div>


<div class="viewcode-block" id="OtherDataParametric.get_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.OtherDataParametric.get_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">convolution</span><span class="p">,</span> <span class="n">myfwhm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nu_co</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">R2tod</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">((</span><span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

        <span class="n">Operator</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nus</span><span class="p">):</span>
            <span class="n">ope_i</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nintegr</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">convolution</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">myfwhm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">fwhm</span> <span class="o">=</span> <span class="n">myfwhm</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fwhm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fwhm</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fwhm</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># fwhm = fwhm_max if convolution and fwhm_max is not None else (self.fwhm[ii] if convolution else 0)</span>
                <span class="n">C</span> <span class="o">=</span> <span class="n">HealpixConvolutionGaussianOperator</span><span class="p">(</span><span class="n">fwhm</span><span class="o">=</span><span class="n">fwhm</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">)</span>

                <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mixing_operator</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

                <span class="n">ope_i</span> <span class="o">+=</span> <span class="p">[</span><span class="n">C</span> <span class="o">*</span> <span class="n">D</span><span class="p">]</span>

                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># if i == 217:</span>
            <span class="c1">#    #print(&#39;co line&#39;)</span>
            <span class="c1">#    if nu_co is not None:</span>
            <span class="c1">#        Dco = get_mixing_operator(beta, np.array([nu_co]), comp=self.comp, nside=self.nside, active=True)</span>
            <span class="c1">#        ope_i += [C * R * Dco]</span>

            <span class="k">if</span> <span class="n">comm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Operator</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">comm</span> <span class="o">*</span> <span class="n">R2tod</span><span class="p">(</span><span class="n">AdditionOperator</span><span class="p">(</span><span class="n">ope_i</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nintegr</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Operator</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">R2tod</span><span class="p">(</span><span class="n">AdditionOperator</span><span class="p">(</span><span class="n">ope_i</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nintegr</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">BlockColumnOperator</span><span class="p">(</span><span class="n">Operator</span><span class="p">,</span> <span class="n">axisout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="OtherDataParametric.get_noise">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.OtherDataParametric.get_noise">[docs]</a>
    <span class="k">def</span> <span class="nf">get_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fact</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seenpix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">get_state</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nus</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">R2tod</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nus</span><span class="p">),</span> <span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nus</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">inu</span><span class="p">,</span> <span class="n">nu</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nus</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fact</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">fact</span><span class="p">[</span><span class="n">inu</span><span class="p">]</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">hp</span><span class="o">.</span><span class="n">ud_grade</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;noise</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nu</span><span class="p">)]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">out</span><span class="p">[</span><span class="n">inu</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">*</span> <span class="n">sigma</span>
        <span class="k">if</span> <span class="n">seenpix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:,</span> <span class="n">seenpix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">R2tod</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="JointAcquisitionFrequencyMapMaking">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.JointAcquisitionFrequencyMapMaking">[docs]</a>
<span class="k">class</span> <span class="nc">JointAcquisitionFrequencyMapMaking</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">Nrec</span><span class="p">,</span> <span class="n">Nsub</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">=</span> <span class="n">kind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">=</span> <span class="n">Nrec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span> <span class="o">=</span> <span class="n">Nsub</span>
        <span class="c1"># self.qubic = qubic</span>

        <span class="c1">### Select the instrument model</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;DB&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span> <span class="o">=</span> <span class="n">QubicDualBand</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span><span class="p">,</span> <span class="n">comps</span><span class="o">=</span><span class="p">[],</span> <span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">nu_co</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;UWB&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span> <span class="o">=</span> <span class="n">QubicUltraWideBand</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span><span class="p">,</span> <span class="n">comps</span><span class="o">=</span><span class="p">[],</span> <span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">nu_co</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="si">}</span><span class="s2"> is not implemented...&quot;</span><span class="p">)</span>
        <span class="c1"># self.qubic = QubicFullBandSystematic(self.d, comp=[], Nsub=self.Nsub, Nrec=self.Nrec, kind=self.kind, H=H)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scene</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span><span class="o">.</span><span class="n">scene</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pl143</span> <span class="o">=</span> <span class="n">PlanckAcquisition</span><span class="p">(</span><span class="mi">143</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pl217</span> <span class="o">=</span> <span class="n">PlanckAcquisition</span><span class="p">(</span><span class="mi">217</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">)</span>

<div class="viewcode-block" id="JointAcquisitionFrequencyMapMaking.get_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.JointAcquisitionFrequencyMapMaking.get_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seenpix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">seenpix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">U</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">ReshapeOperator</span><span class="p">((</span><span class="nb">sum</span><span class="p">(</span><span class="n">seenpix</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">seenpix</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
                <span class="o">*</span> <span class="n">PackOperator</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">seenpix</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">(</span><span class="n">seenpix</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;UWB&quot;</span><span class="p">:</span>  <span class="c1"># WideBand intrument</span>

            <span class="c1"># Get QUBIC operator</span>
            <span class="n">H_qubic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span><span class="o">.</span><span class="n">get_operator</span><span class="p">(</span><span class="n">fwhm</span><span class="o">=</span><span class="n">fwhm</span><span class="p">)</span>
            <span class="n">R_qubic</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">(</span>
                <span class="n">H_qubic</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shapeout</span><span class="p">,</span> <span class="n">H_qubic</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="n">R_planck</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">(</span>
                <span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                <span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span><span class="p">),</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">operator</span> <span class="o">=</span> <span class="p">[</span><span class="n">R_qubic</span><span class="p">(</span><span class="n">H_qubic</span><span class="p">),</span> <span class="n">R_planck</span><span class="p">,</span> <span class="n">R_planck</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">BlockColumnOperator</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">axisout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">full_operator</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">irec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span><span class="p">):</span>
                    <span class="n">operator</span> <span class="o">=</span> <span class="p">[</span><span class="n">R_qubic</span><span class="p">(</span><span class="n">H_qubic</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">irec</span><span class="p">])]</span>
                    <span class="k">for</span> <span class="n">jrec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">irec</span> <span class="o">==</span> <span class="n">jrec</span><span class="p">:</span>
                            <span class="n">operator</span> <span class="o">+=</span> <span class="p">[</span><span class="n">R_planck</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">operator</span> <span class="o">+=</span> <span class="p">[</span><span class="n">R_planck</span> <span class="o">*</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">full_operator</span> <span class="o">+=</span> <span class="p">[</span><span class="n">BlockColumnOperator</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">axisout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">U</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">BlockRowOperator</span><span class="p">(</span><span class="n">full_operator</span><span class="p">,</span> <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;DB&quot;</span><span class="p">:</span>

            <span class="c1"># Get QUBIC operator</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">H_qubic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span><span class="o">.</span><span class="n">get_operator</span><span class="p">(</span><span class="n">fwhm</span><span class="o">=</span><span class="n">fwhm</span><span class="p">)</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">H_qubic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span><span class="o">.</span><span class="n">get_operator</span><span class="p">(</span><span class="n">fwhm</span><span class="o">=</span><span class="n">fwhm</span><span class="p">)</span>
            <span class="n">R_qubic</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">(</span>
                <span class="n">H_qubic</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shapeout</span><span class="p">,</span> <span class="n">H_qubic</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">R_planck</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">(</span>
                <span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                <span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">opefull</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ifp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">ope_per_fp</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">irec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">operator</span> <span class="o">=</span> <span class="p">[</span><span class="n">R_qubic</span> <span class="o">*</span> <span class="n">H_qubic</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">ifp</span><span class="p">]</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">irec</span><span class="p">]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">operator</span> <span class="o">=</span> <span class="p">[</span><span class="n">R_qubic</span> <span class="o">*</span> <span class="n">H_qubic</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">ifp</span><span class="p">]]</span>
                    <span class="k">for</span> <span class="n">jrec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">irec</span> <span class="o">==</span> <span class="n">jrec</span><span class="p">:</span>
                            <span class="n">operator</span> <span class="o">+=</span> <span class="p">[</span><span class="n">R_planck</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">operator</span> <span class="o">+=</span> <span class="p">[</span><span class="n">R_planck</span> <span class="o">*</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">ope_per_fp</span> <span class="o">+=</span> <span class="p">[</span><span class="n">BlockColumnOperator</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">axisout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">U</span><span class="p">]</span>
                <span class="n">opefull</span> <span class="o">+=</span> <span class="p">[</span><span class="n">BlockRowOperator</span><span class="p">(</span><span class="n">ope_per_fp</span><span class="p">,</span> <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">BlockDiagonalOperator</span><span class="p">(</span><span class="n">opefull</span><span class="p">,</span> <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">_r</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">shapeout</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h</span><span class="o">.</span><span class="n">shapeout</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">shapeout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">h</span><span class="o">.</span><span class="n">shapeout</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">_r</span> <span class="o">*</span> <span class="n">h</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BlockDiagonalOperator</span><span class="p">(</span><span class="n">opefull</span><span class="p">,</span> <span class="n">axisout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Instrument type </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="si">}</span><span class="s2"> is not recognize&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="JointAcquisitionFrequencyMapMaking.get_invntt_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.JointAcquisitionFrequencyMapMaking.get_invntt_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_invntt_operator</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">weight_planck</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">beam_correction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seenpix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>

        <span class="k">if</span> <span class="n">beam_correction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">beam_correction</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;UWB&quot;</span><span class="p">:</span>

            <span class="n">invn_q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">()</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">(</span><span class="n">invn_q</span><span class="o">.</span><span class="n">shapeout</span><span class="p">,</span> <span class="n">invn_q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">invn_q</span> <span class="o">=</span> <span class="p">[</span><span class="n">R</span><span class="p">(</span><span class="n">invn_q</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">))]</span>

            <span class="n">invntt_planck143</span> <span class="o">=</span> <span class="n">weight_planck</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pl143</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">(</span>
                <span class="n">beam_correction</span><span class="o">=</span><span class="n">beam_correction</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">seenpix</span><span class="o">=</span><span class="n">seenpix</span>
            <span class="p">)</span>
            <span class="n">invntt_planck217</span> <span class="o">=</span> <span class="n">weight_planck</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pl217</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">(</span>
                <span class="n">beam_correction</span><span class="o">=</span><span class="n">beam_correction</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">seenpix</span><span class="o">=</span><span class="n">seenpix</span>
            <span class="p">)</span>
            <span class="n">R_planck</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">(</span>
                <span class="n">invntt_planck143</span><span class="o">.</span><span class="n">shapeout</span><span class="p">,</span> <span class="n">invntt_planck143</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">invN_143</span> <span class="o">=</span> <span class="n">R_planck</span><span class="p">(</span><span class="n">invntt_planck143</span><span class="p">(</span><span class="n">R_planck</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
            <span class="n">invN_217</span> <span class="o">=</span> <span class="n">R_planck</span><span class="p">(</span><span class="n">invntt_planck217</span><span class="p">(</span><span class="n">R_planck</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">invNe</span> <span class="o">=</span> <span class="p">[</span><span class="n">invN_143</span><span class="p">,</span> <span class="n">invN_217</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">invNe</span> <span class="o">=</span> <span class="p">[</span><span class="n">invN_143</span><span class="p">]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">invN_217</span><span class="p">]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="p">)</span>
            <span class="n">invN</span> <span class="o">=</span> <span class="n">invn_q</span> <span class="o">+</span> <span class="n">invNe</span>
            <span class="k">return</span> <span class="n">BlockDiagonalOperator</span><span class="p">(</span><span class="n">invN</span><span class="p">,</span> <span class="n">axisout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;DB&quot;</span><span class="p">:</span>

            <span class="n">invn_q_150</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">()</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">invn_q_220</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">()</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">(</span><span class="n">invn_q_150</span><span class="o">.</span><span class="n">shapeout</span><span class="p">,</span> <span class="n">invn_q_150</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">invntt_planck143</span> <span class="o">=</span> <span class="n">weight_planck</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pl143</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">(</span>
                <span class="n">beam_correction</span><span class="o">=</span><span class="n">beam_correction</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">seenpix</span><span class="o">=</span><span class="n">seenpix</span>
            <span class="p">)</span>
            <span class="n">invntt_planck217</span> <span class="o">=</span> <span class="n">weight_planck</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pl217</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">(</span>
                <span class="n">beam_correction</span><span class="o">=</span><span class="n">beam_correction</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">seenpix</span><span class="o">=</span><span class="n">seenpix</span>
            <span class="p">)</span>
            <span class="n">R_planck</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">(</span>
                <span class="n">invntt_planck143</span><span class="o">.</span><span class="n">shapeout</span><span class="p">,</span> <span class="n">invntt_planck143</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">invN_143</span> <span class="o">=</span> <span class="n">R_planck</span><span class="p">(</span><span class="n">invntt_planck143</span><span class="p">(</span><span class="n">R_planck</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
            <span class="n">invN_217</span> <span class="o">=</span> <span class="n">R_planck</span><span class="p">(</span><span class="n">invntt_planck217</span><span class="p">(</span><span class="n">R_planck</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
            <span class="n">invN</span> <span class="o">=</span> <span class="p">[</span><span class="n">R</span><span class="p">(</span><span class="n">invn_q_150</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">))]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)):</span>
                <span class="n">invN</span> <span class="o">+=</span> <span class="p">[</span><span class="n">R_planck</span><span class="p">(</span><span class="n">invntt_planck143</span><span class="p">(</span><span class="n">R_planck</span><span class="o">.</span><span class="n">T</span><span class="p">))]</span>  <span class="c1"># ,</span>
                <span class="c1"># R(invn_q_220(R.T)), R_planck(invntt_planck217(R_planck.T))]</span>

            <span class="n">invN</span> <span class="o">+=</span> <span class="p">[</span><span class="n">R</span><span class="p">(</span><span class="n">invn_q_220</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">))]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)):</span>
                <span class="n">invN</span> <span class="o">+=</span> <span class="p">[</span><span class="n">R_planck</span><span class="p">(</span><span class="n">invntt_planck217</span><span class="p">(</span><span class="n">R_planck</span><span class="o">.</span><span class="n">T</span><span class="p">))]</span>

            <span class="k">return</span> <span class="n">BlockDiagonalOperator</span><span class="p">(</span><span class="n">invN</span><span class="p">,</span> <span class="n">axisout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        elif self.kind == &#39;QubicIntegrated&#39;:</span>
<span class="sd">            if beam_correction is None :</span>
<span class="sd">                beam_correction = [0]*self.Nrec</span>
<span class="sd">            else:</span>
<span class="sd">                if type(beam_correction) is not list:</span>
<span class="sd">                    raise TypeError(&#39;Beam correction should be a list&#39;)</span>
<span class="sd">                if len(beam_correction) != self.Nrec:</span>
<span class="sd">                    raise TypeError(&#39;List of beam correction should have Nrec elements&#39;)</span>


<span class="sd">            invntt_qubic = self.qubic.get_invntt_operator(det_noise, photon_noise)</span>
<span class="sd">            R_qubic = ReshapeOperator(invntt_qubic.shapeout, invntt_qubic.shape[0])</span>
<span class="sd">            Operator = [R_qubic(invntt_qubic(R_qubic.T))]</span>

<span class="sd">            for i in range(self.Nrec):</span>
<span class="sd">                invntt_planck = weight_planck*self.planck.get_invntt_operator(beam_correction=beam_correction[i], mask=mask, seenpix=seenpix)</span>
<span class="sd">                R_planck = ReshapeOperator(invntt_planck.shapeout, invntt_planck.shape[0])</span>
<span class="sd">                Operator.append(R_planck(invntt_planck(R_planck.T)))</span>

<span class="sd">            return BlockDiagonalOperator(Operator, axisout=0)</span>
<span class="sd">        &quot;&quot;&quot;</span></div>
</div>

<div class="viewcode-block" id="JointAcquisitionComponentsMapMaking">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.JointAcquisitionComponentsMapMaking">[docs]</a>
<span class="k">class</span> <span class="nc">JointAcquisitionComponentsMapMaking</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">Nsub</span><span class="p">,</span> <span class="n">nus_external</span><span class="p">,</span> <span class="n">nintegr</span><span class="p">,</span> <span class="n">nu_co</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">=</span> <span class="n">kind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span> <span class="o">=</span> <span class="n">Nsub</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp</span> <span class="o">=</span> <span class="n">comp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nus_external</span> <span class="o">=</span> <span class="n">nus_external</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nintegr</span> <span class="o">=</span> <span class="n">nintegr</span>
        <span class="c1"># self.qubic = qubic</span>
        <span class="c1">### Select the instrument model</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;DB&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span> <span class="o">=</span> <span class="n">QubicDualBand</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span><span class="p">,</span> <span class="n">nrec</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">comps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">nu_co</span><span class="o">=</span><span class="n">nu_co</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;UWB&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span> <span class="o">=</span> <span class="n">QubicUltraWideBand</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span><span class="p">,</span> <span class="n">nrec</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">comps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">nu_co</span><span class="o">=</span><span class="n">nu_co</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="si">}</span><span class="s2"> is not implemented...&quot;</span><span class="p">)</span>
        <span class="c1"># self.qubic = QubicFullBandSystematic(self.d, comp=self.comp, Nsub=self.Nsub, Nrec=1, kind=self.kind, nu_co=nu_co, H=H, effective_duration150=ef150, effective_duration220=ef220)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scene</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span><span class="o">.</span><span class="n">scene</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">external</span> <span class="o">=</span> <span class="n">OtherDataParametric</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nus_external</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nintegr</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allnus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubic</span><span class="o">.</span><span class="n">allnus</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">external</span><span class="o">.</span><span class="n">allnus</span><span class="p">))</span>

<div class="viewcode-block" id="JointAcquisitionComponentsMapMaking.get_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.JointAcquisitionComponentsMapMaking.get_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nu_co</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">Aq</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span><span class="p">]</span>
        <span class="n">Ap</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span> <span class="p">:]</span>

        <span class="n">Hq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span><span class="o">.</span><span class="n">get_operator</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">Aq</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="n">fwhm</span><span class="p">)</span>
        <span class="n">Rq</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">(</span><span class="n">Hq</span><span class="o">.</span><span class="n">shapeout</span><span class="p">,</span> <span class="p">(</span><span class="n">Hq</span><span class="o">.</span><span class="n">shapeout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">Hq</span><span class="o">.</span><span class="n">shapeout</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">mpidist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span><span class="o">.</span><span class="n">mpidist</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">mpidist</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">He</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external</span><span class="o">.</span><span class="n">get_operator</span><span class="p">(</span>
            <span class="n">A</span><span class="o">=</span><span class="n">Ap</span><span class="p">,</span> <span class="n">convolution</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">comm</span><span class="o">=</span><span class="n">mpidist</span><span class="p">,</span> <span class="n">nu_co</span><span class="o">=</span><span class="n">nu_co</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">BlockColumnOperator</span><span class="p">([</span><span class="n">Rq</span> <span class="o">*</span> <span class="n">Hq</span><span class="p">,</span> <span class="n">He</span><span class="p">],</span> <span class="n">axisout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="JointAcquisitionComponentsMapMaking.get_invntt_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.JointAcquisitionComponentsMapMaking.get_invntt_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_invntt_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fact</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">invNq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">()</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">(</span><span class="n">invNq</span><span class="o">.</span><span class="n">shapeout</span><span class="p">,</span> <span class="n">invNq</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">invNe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">external</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">(</span><span class="n">fact</span><span class="o">=</span><span class="n">fact</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">BlockDiagonalOperator</span><span class="p">([</span><span class="n">R</span><span class="p">(</span><span class="n">invNq</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span> <span class="n">invNe</span><span class="p">],</span> <span class="n">axisout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>
</div>



<span class="c1">### Old version</span>

<div class="viewcode-block" id="QubicPolyAcquisition">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicPolyAcquisition">[docs]</a>
<span class="k">class</span> <span class="nc">QubicPolyAcquisition</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiinstrument</span><span class="p">,</span> <span class="n">sampling</span><span class="p">,</span> <span class="n">scene</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        acq = QubicPolyAcquisition(QubicMultibandInstrument, sampling, scene)</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        multiinstrument : QubicMultibandInstrument</span>
<span class="sd">            The sub-frequencies are set there</span>
<span class="sd">        sampling :</span>
<span class="sd">            QubicSampling instance</span>
<span class="sd">        scene :</span>
<span class="sd">            QubicScene instance</span>
<span class="sd">        For other parameters see documentation for the QubicAcquisition class</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">weights</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;weights&quot;</span><span class="p">]</span>

        <span class="c1"># self.warnings(d)</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;MultiBand&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;nf_sub&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">QubicAcquisition</span><span class="p">(</span><span class="n">multiinstrument</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sampling</span><span class="p">,</span> <span class="n">scene</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">multiinstrument</span><span class="p">))</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If you do not use a multiband instrument,&quot;</span>
                <span class="s2">&quot;you should use the QubicAcquisition class&quot;</span>
                <span class="s2">&quot;which is done for the monochromatic case.&quot;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">comm</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">comm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scene</span> <span class="o">=</span> <span class="n">scene</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>  <span class="c1"># / len(self)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">)</span>

<div class="viewcode-block" id="QubicPolyAcquisition.warnings">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicPolyAcquisition.warnings">[docs]</a>
    <span class="k">def</span> <span class="nf">warnings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method prevent to you that beam is not a good</span>
<span class="sd">        approximation in the 220 GHz band.</span>
<span class="sd">        Also can be used to add new warnings when acquisition is created in</span>
<span class="sd">        specific configuration.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;filter_nu&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mf">220e9</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;beam_shape&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;The nu dependency of the gausian beam FWHM &quot;</span>
                    <span class="s2">&quot;is not a good approximation in the 220 GHz band.&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;beam_shape&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;fitted_beam&quot;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Beam and solid angle frequency dependence implementation &quot;</span>
                    <span class="s2">&quot;in the 220 GHz band for the fitted beam does not correctly describe &quot;</span>
                    <span class="s2">&quot;the true behavior&quot;</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="QubicPolyAcquisition.get_coverage">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicPolyAcquisition.get_coverage">[docs]</a>
    <span class="k">def</span> <span class="nf">get_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array of monochromatic coverage maps, one for each of subacquisitions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_coverage</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_coverage</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))])</span></div>


<div class="viewcode-block" id="QubicPolyAcquisition.get_coverage_mask">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicPolyAcquisition.get_coverage_mask">[docs]</a>
    <span class="k">def</span> <span class="nf">get_coverage_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coverages</span><span class="p">,</span> <span class="n">covlim</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a healpix boolean map with True on the pixels where ALL the</span>
<span class="sd">            subcoverages are above covlim * subcoverage.max()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coverages</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Use QubicMultibandAcquisition.get_coverage method to create input&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="n">coverages</span>
            <span class="k">return</span> <span class="n">cov</span> <span class="o">&gt;</span> <span class="n">covlim</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
        <span class="n">observed</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">coverages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">covlim</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coverages</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">observed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))))</span>
        <span class="k">return</span> <span class="n">obs</span></div>


    <span class="k">def</span> <span class="nf">_get_average_instrument_acq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create and return a QubicAcquisition instance of a monochromatic</span>
<span class="sd">            instrument with frequency correspondent to the mean of the</span>
<span class="sd">            frequency range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">q0</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">instrument</span>
        <span class="n">nu_min</span> <span class="o">=</span> <span class="n">q0</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">nu</span>
        <span class="n">nu_max</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">nu</span>
        <span class="n">nep</span> <span class="o">=</span> <span class="n">q0</span><span class="o">.</span><span class="n">detector</span><span class="o">.</span><span class="n">nep</span>
        <span class="n">fknee</span> <span class="o">=</span> <span class="n">q0</span><span class="o">.</span><span class="n">detector</span><span class="o">.</span><span class="n">fknee</span>
        <span class="n">fslope</span> <span class="o">=</span> <span class="n">q0</span><span class="o">.</span><span class="n">detector</span><span class="o">.</span><span class="n">fslope</span>

        <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;filter_nu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nu_max</span> <span class="o">+</span> <span class="n">nu_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;filter_relative_bandwidth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">nu_max</span> <span class="o">-</span> <span class="n">nu_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">nu_max</span> <span class="o">+</span> <span class="n">nu_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;detector_nep&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nep</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;detector_fknee&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fknee</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;detector_fslope&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fslope</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">qubic</span><span class="o">.</span><span class="n">QubicInstrument</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">FRBW</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">FRBW</span><span class="p">)</span>
        <span class="n">q</span><span class="o">.</span><span class="n">detector</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">detector</span>
        <span class="n">s_</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sampling</span>
        <span class="n">nsamplings</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s_</span><span class="p">))</span>

        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;random_pointing&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;sweeping_pointing&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;repeat_pointing&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;RA_center&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;DEC_center&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;npointings&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nsamplings</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;dtheta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_</span><span class="o">.</span><span class="n">period</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">get_pointing</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span>
        <span class="c1"># s = create_random_pointings([0., 0.], nsamplings, 10., period=s_.period)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">QubicAcquisition</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="n">d1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span>

<div class="viewcode-block" id="QubicPolyAcquisition.get_noise">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicPolyAcquisition.get_noise">[docs]</a>
    <span class="k">def</span> <span class="nf">get_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_average_instrument_acq</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">get_noise</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_get_array_of_operators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">get_operator</span><span class="p">()</span> <span class="o">*</span> <span class="n">w</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">)]</span>

<div class="viewcode-block" id="QubicPolyAcquisition.get_operator_to_make_TOD">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicPolyAcquisition.get_operator_to_make_TOD">[docs]</a>
    <span class="k">def</span> <span class="nf">get_operator_to_make_TOD</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a BlockRowOperator of subacquisition operators</span>
<span class="sd">        In polychromatic mode it is only applied to produce the TOD</span>
<span class="sd">        To reconstruct maps one should use the get_operator function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_operator</span><span class="p">()</span>
        <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_array_of_operators</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">BlockRowOperator</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="QubicPolyAcquisition.get_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicPolyAcquisition.get_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an sum of operators for subacquisitions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_operator</span><span class="p">()</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_array_of_operators</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="QubicPolyAcquisition.get_invntt_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicPolyAcquisition.get_invntt_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_invntt_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the inverse noise covariance matrix as operator</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">()</span></div>
</div>

<div class="viewcode-block" id="QubicFullBandSystematic">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicFullBandSystematic">[docs]</a>
<span class="k">class</span> <span class="nc">QubicFullBandSystematic</span><span class="p">(</span><span class="n">QubicPolyAcquisition</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Instance to compute QUBIC operator.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">d</span><span class="p">,</span>
        <span class="n">Nsub</span><span class="p">,</span>
        <span class="n">Nrec</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">comp</span><span class="o">=</span><span class="p">[],</span>
        <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;DB&quot;</span><span class="p">,</span>
        <span class="n">nu_co</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">H</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">effective_duration150</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">effective_duration220</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">            - d : QUBIC dictionary</span>
<span class="sd">            - Nsub : Number of sub-acquisitions</span>
<span class="sd">            - comp : list of components</span>
<span class="sd">            - kind : `DB` or `UWB` to define instrumental design</span>
<span class="sd">            - nu_co : float -&gt; frequency of the CO line emission</span>
<span class="sd">            - H : pre-existing QUBIC operators, if None -&gt; operators will be recomputed</span>
<span class="sd">            - effective_duration150 : effective observation time at 150 GHz</span>
<span class="sd">            - effective_duration220 : effective observation time at 220 GHz</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">Nrec</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;For Components Map-Making, there must be Nrec = 1&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp</span> <span class="o">=</span> <span class="n">comp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Nsub</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">=</span> <span class="n">kind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">=</span> <span class="n">Nrec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nu_co</span> <span class="o">=</span> <span class="n">nu_co</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">effective_duration150</span> <span class="o">=</span> <span class="n">effective_duration150</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">effective_duration220</span> <span class="o">=</span> <span class="n">effective_duration220</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;DB&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Dual band instrument can not reconstruct one band&quot;</span><span class="p">)</span>

        <span class="c1">### Number of focal plane</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;DB&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">number_FP</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;UWB&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">number_FP</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">Nsub</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;You should use Nsub &gt; 1&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;nf_sub&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;nf_recon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nu_down</span> <span class="o">=</span> <span class="mf">131.25</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nu_up</span> <span class="o">=</span> <span class="mf">247.5</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nu_average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nu_down</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nu_up</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;filter_nu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nu_average</span> <span class="o">*</span> <span class="mf">1e9</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">allnus150</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_freq</span><span class="p">(</span>
            <span class="mi">150</span><span class="p">,</span> <span class="n">Nfreq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">relative_bandwidth</span><span class="o">=</span><span class="mf">0.25</span>
        <span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">allnus220</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_freq</span><span class="p">(</span>
            <span class="mi">220</span><span class="p">,</span> <span class="n">Nfreq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">relative_bandwidth</span><span class="o">=</span><span class="mf">0.25</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allnus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">allnus150</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">allnus220</span><span class="p">))</span>

        <span class="c1">### Multi-frequency instrument</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span> <span class="o">=</span> <span class="n">QubicMultibandInstrument</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span> <span class="o">=</span> <span class="n">get_pointing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scene</span> <span class="o">=</span> <span class="n">QubicScene</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Proj</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">QubicAcquisition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">))</span>
        <span class="p">]</span>

        <span class="c1">### Angular resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allfwhm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">allfwhm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_convolution_peak_operator</span><span class="p">()</span><span class="o">.</span><span class="n">fwhm</span>

        <span class="c1">### CO line emission</span>
        <span class="k">if</span> <span class="n">nu_co</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># dmono = self.d.copy()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;filter_nu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nu_co</span> <span class="o">*</span> <span class="mf">1e9</span>
            <span class="n">sampling</span> <span class="o">=</span> <span class="n">get_pointing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
            <span class="n">scene</span> <span class="o">=</span> <span class="n">QubicScene</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
            <span class="n">instrument_co</span> <span class="o">=</span> <span class="n">QubicInstrument</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="o">.</span><span class="n">subinstruments</span> <span class="o">+=</span> <span class="p">[</span><span class="n">instrument_co</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Proj</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">QubicAcquisition</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sampling</span><span class="p">,</span> <span class="n">scene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span>
                <span class="p">)</span><span class="o">.</span><span class="n">get_projection_operator</span><span class="p">()</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">QubicAcquisition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sampling</span><span class="p">,</span> <span class="n">scene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="n">QubicPolyAcquisition</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span>
        <span class="p">)</span>

        <span class="c1">### Pointing matrix</span>
        <span class="k">if</span> <span class="n">H</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_operator</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="n">H</span>
        <span class="c1"># print(self.d[&#39;nprocs_instrument&#39;])</span>
        <span class="c1"># stop</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;nprocs_instrument&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpidist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ndets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">instrument</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coverage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_coverage</span><span class="p">()</span>

<div class="viewcode-block" id="QubicFullBandSystematic.get_hwp_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicFullBandSystematic.get_hwp_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_hwp_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle_hwp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the rotation matrix for the half-wave plate.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Rotation3dOperator</span><span class="p">(</span>
            <span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span> <span class="o">*</span> <span class="n">angle_hwp</span><span class="p">,</span> <span class="n">degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shapein</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Proj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shapeout</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QubicFullBandSystematic.get_components_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicFullBandSystematic.get_components_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_components_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">Amm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Create a mixing matrix operator for a given value of spectral index</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">beta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">beta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">beta</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">(</span>
                <span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">ReshapeOperator</span><span class="p">(</span>
                <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">(</span>
            <span class="n">get_mixing_operator</span><span class="p">(</span>
                <span class="n">beta</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="n">Amm</span><span class="o">=</span><span class="n">Amm</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="n">active</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="QubicFullBandSystematic.sum_over_band">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicFullBandSystematic.sum_over_band">[docs]</a>
    <span class="k">def</span> <span class="nf">sum_over_band</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Perform sum over sub-operators depending on the reconstruction algorithms (FMM or CMM)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">op_sum</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span><span class="p">)</span>

        <span class="c1">### Frequency Map-Making</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">irec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span><span class="p">):</span>
                <span class="n">imin</span> <span class="o">=</span> <span class="n">irec</span> <span class="o">*</span> <span class="n">f</span>
                <span class="n">imax</span> <span class="o">=</span> <span class="p">(</span><span class="n">irec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">op_sum</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="n">h</span><span class="p">[</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allnus</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allnus</span><span class="p">[</span><span class="n">imin</span><span class="p">])</span>
                        <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allnus</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allnus</span><span class="p">[</span><span class="n">imax</span><span class="p">])</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;UWB&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BlockRowOperator</span><span class="p">(</span><span class="n">op_sum</span><span class="p">,</span> <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">BlockDiagonalOperator</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">BlockRowOperator</span><span class="p">(</span>
                                <span class="n">op_sum</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span>
                            <span class="p">),</span>
                            <span class="n">BlockRowOperator</span><span class="p">(</span>
                                <span class="n">op_sum</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span><span class="p">)],</span>
                                <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="p">),</span>
                        <span class="p">],</span>
                        <span class="n">axisout</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">ReshapeOperator</span><span class="p">(</span>
                        <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>
                    <span class="p">)</span> <span class="o">*</span> <span class="n">BlockDiagonalOperator</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">BlockRowOperator</span><span class="p">(</span>
                                <span class="n">op_sum</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span>
                            <span class="p">),</span>
                            <span class="n">BlockRowOperator</span><span class="p">(</span>
                                <span class="n">op_sum</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span><span class="p">)],</span>
                                <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="p">),</span>
                        <span class="p">],</span>
                        <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="c1">### Components Map-Making</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;UWB&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">gain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">G</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">),</span>
                        <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span>
                        <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">G</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
                        <span class="n">gain</span><span class="p">,</span> <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span> <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">G</span> <span class="o">*</span> <span class="n">AdditionOperator</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">gain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">G150</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">),</span>
                        <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span>
                        <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="n">G220</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">),</span>
                        <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span>
                        <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">G150</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
                        <span class="n">gain</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                        <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span>
                        <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="n">G220</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
                        <span class="n">gain</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span>
                        <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsamples</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">BlockColumnOperator</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">G150</span> <span class="o">*</span> <span class="n">AdditionOperator</span><span class="p">(</span><span class="n">h</span><span class="p">[:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span><span class="p">)]),</span>
                        <span class="n">G220</span> <span class="o">*</span> <span class="n">AdditionOperator</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span><span class="p">)</span> <span class="p">:]),</span>
                    <span class="p">],</span>
                    <span class="n">axisout</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="QubicFullBandSystematic.get_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicFullBandSystematic.get_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Amm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">angle_hwp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">angle_hwp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">angle_hwp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">angle_hwp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">angle_hwp</span> <span class="o">=</span> <span class="n">fill_hwp_position</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Proj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shapeout</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">angle_hwp</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">isub</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span> <span class="o">*</span> <span class="mi">2</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">beta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Acomp</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">Amm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">Acomp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_components_operator</span><span class="p">(</span>
                        <span class="n">beta</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">allnus</span><span class="p">[</span><span class="n">isub</span><span class="p">]]),</span> <span class="n">Amm</span><span class="o">=</span><span class="n">Amm</span><span class="p">[</span><span class="n">isub</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Acomp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_components_operator</span><span class="p">(</span>
                        <span class="n">beta</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">allnus</span><span class="p">[</span><span class="n">isub</span><span class="p">]])</span>
                    <span class="p">)</span>

            <span class="k">if</span> <span class="n">fwhm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">convolution</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">convolution</span> <span class="o">=</span> <span class="n">HealpixConvolutionGaussianOperator</span><span class="p">(</span>
                    <span class="n">fwhm</span><span class="o">=</span><span class="n">fwhm</span><span class="p">[</span><span class="n">isub</span><span class="p">],</span> <span class="n">lmax</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;nside&quot;</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">with</span> <span class="n">rule_manager</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">hi</span> <span class="o">=</span> <span class="n">CompositionOperator</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="p">[</span><span class="n">isub</span><span class="p">],</span> <span class="n">convolution</span><span class="p">,</span> <span class="n">Acomp</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hi</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nu_co</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">beta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Acomp</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Acomp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_components_operator</span><span class="p">(</span>
                    <span class="n">beta</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nu_co</span><span class="p">]),</span> <span class="n">active</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
            <span class="n">distribution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_distribution_operator</span><span class="p">()</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_unit_conversion_operator</span><span class="p">()</span>
            <span class="n">aperture</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_aperture_integration_operator</span><span class="p">()</span>
            <span class="nb">filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_filter_operator</span><span class="p">()</span>
            <span class="n">projection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Proj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># hwp = self.get_hwp_operator(angle_hwp)</span>
            <span class="n">hwp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_hwp_operator</span><span class="p">()</span>
            <span class="n">polarizer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_polarizer_operator</span><span class="p">()</span>
            <span class="n">integ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_detector_integration_operator</span><span class="p">()</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_transmission_operator</span><span class="p">()</span>
            <span class="n">trans_atm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">atmosphere</span><span class="o">.</span><span class="n">transmission</span>
            <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_detector_response_operator</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">fwhm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">convolution</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">convolution</span> <span class="o">=</span> <span class="n">HealpixConvolutionGaussianOperator</span><span class="p">(</span>
                    <span class="n">fwhm</span><span class="o">=</span><span class="n">fwhm</span><span class="p">[</span><span class="n">isub</span><span class="p">],</span> <span class="n">lmax</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;nside&quot;</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">with</span> <span class="n">rule_manager</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">hi</span> <span class="o">=</span> <span class="n">CompositionOperator</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">HomothetyOperator</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span><span class="p">)),</span>
                        <span class="n">response</span><span class="p">,</span>
                        <span class="n">trans_atm</span><span class="p">,</span>
                        <span class="n">trans</span><span class="p">,</span>
                        <span class="n">integ</span><span class="p">,</span>
                        <span class="n">polarizer</span><span class="p">,</span>
                        <span class="p">(</span><span class="n">hwp</span> <span class="o">*</span> <span class="n">projection</span><span class="p">),</span>
                        <span class="nb">filter</span><span class="p">,</span>
                        <span class="n">aperture</span><span class="p">,</span>
                        <span class="n">temp</span><span class="p">,</span>
                        <span class="n">distribution</span><span class="p">,</span>
                        <span class="n">convolution</span><span class="p">,</span>
                        <span class="n">Acomp</span><span class="p">,</span>
                    <span class="p">]</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hi</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_over_band</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="n">gain</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">H</span></div>


<div class="viewcode-block" id="QubicFullBandSystematic.get_invntt_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicFullBandSystematic.get_invntt_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_invntt_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Method to compute the inverse noise covariance matrix in time-domain.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d150</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d150</span><span class="p">[</span><span class="s2">&quot;filter_nu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">150</span> <span class="o">*</span> <span class="mf">1e9</span>
        <span class="n">d150</span><span class="p">[</span><span class="s2">&quot;effective_duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective_duration150</span>
        <span class="n">ins150</span> <span class="o">=</span> <span class="n">QubicInstrument</span><span class="p">(</span><span class="n">d150</span><span class="p">)</span>

        <span class="n">d220</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d220</span><span class="p">[</span><span class="s2">&quot;effective_duration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective_duration220</span>
        <span class="n">d220</span><span class="p">[</span><span class="s2">&quot;filter_nu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">220</span> <span class="o">*</span> <span class="mf">1e9</span>

        <span class="n">ins220</span> <span class="o">=</span> <span class="n">QubicInstrument</span><span class="p">(</span><span class="n">d220</span><span class="p">)</span>

        <span class="n">subacq150</span> <span class="o">=</span> <span class="n">QubicAcquisition</span><span class="p">(</span><span class="n">ins150</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="n">d150</span><span class="p">)</span>
        <span class="n">subacq220</span> <span class="o">=</span> <span class="n">QubicAcquisition</span><span class="p">(</span><span class="n">ins220</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="n">d220</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;DB&quot;</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">invn150</span> <span class="o">=</span> <span class="n">subacq150</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">(</span>
                <span class="n">det_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">photon_noise</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">invn220</span> <span class="o">=</span> <span class="n">subacq220</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">(</span>
                <span class="n">det_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">photon_noise</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="n">BlockDiagonalOperator</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">invn150</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">invn220</span><span class="p">],</span> <span class="n">axisout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;UWB&quot;</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">invn150</span> <span class="o">=</span> <span class="n">subacq150</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">(</span>
                <span class="n">det_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">photon_noise</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">invn220</span> <span class="o">=</span> <span class="n">subacq220</span><span class="o">.</span><span class="n">get_invntt_operator</span><span class="p">(</span>
                <span class="n">det_noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">photon_noise</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">invn150</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">invn220</span></div>


<div class="viewcode-block" id="QubicFullBandSystematic.get_PySM_maps">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicFullBandSystematic.get_PySM_maps">[docs]</a>
    <span class="k">def</span> <span class="nf">get_PySM_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Alens</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Read configuration dictionary which contains every components adn the model.</span>

<span class="sd">        Example : d = {&#39;cmb&#39;:42, &#39;dust&#39;:&#39;d0&#39;, &#39;synchrotron&#39;:&#39;s0&#39;}</span>

<span class="sd">        The CMB is randomly generated fram specific seed. Astrophysical foregrounds come from PySM 3.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">allmaps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">),</span> <span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">ell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">mycls</span> <span class="o">=</span> <span class="n">give_cl_cmb</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="p">,</span> <span class="n">Alens</span><span class="o">=</span><span class="n">Alens</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">kconf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">config</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">kconf</span> <span class="o">==</span> <span class="s2">&quot;cmb&quot;</span><span class="p">:</span>

                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="n">kconf</span><span class="p">])</span>
                <span class="n">cmb</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">synfast</span><span class="p">(</span><span class="n">mycls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

                <span class="n">allmaps</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmb</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">elif</span> <span class="n">kconf</span> <span class="o">==</span> <span class="s2">&quot;dust&quot;</span><span class="p">:</span>

                <span class="n">nu0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_fixed_params&quot;</span><span class="p">][</span><span class="s2">&quot;nu0&quot;</span><span class="p">]</span>
                <span class="n">sky</span> <span class="o">=</span> <span class="n">pysm3</span><span class="o">.</span><span class="n">Sky</span><span class="p">(</span>
                    <span class="n">nside</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span>
                    <span class="n">preset_strings</span><span class="o">=</span><span class="p">[</span><span class="n">config</span><span class="p">[</span><span class="n">kconf</span><span class="p">]],</span>
                    <span class="n">output_unit</span><span class="o">=</span><span class="s2">&quot;uK_CMB&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="c1"># sky.components[0].mbb_index = hp.ud_grade(sky.components[0].mbb_index, 8)</span>
                <span class="n">sky</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mbb_temperature</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mi">20</span> <span class="o">*</span> <span class="n">sky</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mbb_temperature</span><span class="o">.</span><span class="n">unit</span>
                <span class="p">)</span>
                <span class="c1"># sky.components[0].mbb_index = hp.ud_grade(np.array(sky.components[0].mbb_index), 8)</span>
                <span class="n">mydust</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">sky</span><span class="o">.</span><span class="n">get_emission</span><span class="p">(</span><span class="n">nu0</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">GHz</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">bandpass_unit_conversion</span><span class="p">(</span><span class="n">nu0</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">GHz</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">uK_CMB</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="n">allmaps</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">mydust</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">kconf</span> <span class="o">==</span> <span class="s2">&quot;synchrotron&quot;</span><span class="p">:</span>
                <span class="n">nu0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_fixed_params&quot;</span><span class="p">][</span><span class="s2">&quot;nu0&quot;</span><span class="p">]</span>
                <span class="n">sky</span> <span class="o">=</span> <span class="n">pysm3</span><span class="o">.</span><span class="n">Sky</span><span class="p">(</span>
                    <span class="n">nside</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span>
                    <span class="n">preset_strings</span><span class="o">=</span><span class="p">[</span><span class="n">config</span><span class="p">[</span><span class="n">kconf</span><span class="p">]],</span>
                    <span class="n">output_unit</span><span class="o">=</span><span class="s2">&quot;uK_CMB&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">mysync</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">sky</span><span class="o">.</span><span class="n">get_emission</span><span class="p">(</span><span class="n">nu0</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">GHz</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                    <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">bandpass_unit_conversion</span><span class="p">(</span><span class="n">nu0</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">GHz</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">uK_CMB</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">allmaps</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">mysync</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">kconf</span> <span class="o">==</span> <span class="s2">&quot;coline&quot;</span><span class="p">:</span>

                <span class="c1"># sky = pysm3.Sky(nside=self.nside, preset_strings=[&#39;co2&#39;], output_unit=&quot;uK_CMB&quot;)</span>
                <span class="c1"># nu0 = sky.components[0].line_frequency[&#39;21&#39;].value</span>

                <span class="c1"># myco=np.array(sky.get_emission(nu0 * u.GHz, None).T * utils.bandpass_unit_conversion(nu0*u.GHz, None, u.uK_CMB))</span>
                <span class="c1"># 10 is for reproduce the PsYM template</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ud_grade</span><span class="p">(</span>
                    <span class="n">hp</span><span class="o">.</span><span class="n">read_map</span><span class="p">(</span><span class="n">path_to_data</span> <span class="o">+</span> <span class="s2">&quot;CO_line.fits&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span>
                <span class="p">)</span>
                <span class="c1"># print(self.nside)</span>
                <span class="n">mP</span> <span class="o">=</span> <span class="n">polarized_I</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="p">)</span>
                <span class="c1"># print(mP.shape)</span>
                <span class="n">myco</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                <span class="n">myco</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">myco</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">mP</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">allmaps</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">myco</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Choose right foreground model (d0, s0, ...)&quot;</span><span class="p">)</span>

        <span class="c1"># if len(nus) == 1:</span>
        <span class="c1">#    allmaps = allmaps[0].copy()</span>

        <span class="k">return</span> <span class="n">allmaps</span></div>
</div>

<div class="viewcode-block" id="QubicIntegrated">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicIntegrated">[docs]</a>
<span class="k">class</span> <span class="nc">QubicIntegrated</span><span class="p">(</span><span class="n">QubicPolyAcquisition</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">Nsub</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nrec</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        The initialization method allows to compute basic parameters such as :</span>

<span class="sd">            - self.allnus    : array of all frequency used for the operators</span>
<span class="sd">            - self.nueff     : array of the effective frequencies</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;nf_sub&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Nsub</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;nf_recon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Nrec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span> <span class="o">=</span> <span class="n">Nsub</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">=</span> <span class="n">Nrec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fact</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">=</span> <span class="s2">&quot;QubicIntegrated&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">integration</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">integration</span> <span class="o">=</span> <span class="s2">&quot;Trapeze&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span> <span class="o">=</span> <span class="n">get_pointing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scene</span> <span class="o">=</span> <span class="n">QubicScene</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span> <span class="o">=</span> <span class="n">QubicMultibandInstrument</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;nf_sub&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">QubicPolyAcquisition</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">QubicAcquisition</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span>
                <span class="p">)</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">integration</span> <span class="o">==</span> <span class="s2">&quot;Trapeze&quot;</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nueff</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_freq</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;filter_nu&quot;</span><span class="p">],</span>
                <span class="n">Nfreq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span><span class="p">,</span>
                <span class="n">relative_bandwidth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;filter_relative_bandwidth&quot;</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nus_edge</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nueff</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_freq</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;filter_nu&quot;</span><span class="p">],</span> <span class="n">Nfreq</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;nf_recon&quot;</span><span class="p">])</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">nside</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allnus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">q</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">nu</span> <span class="o">/</span> <span class="mf">1e9</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">])</span>
        <span class="c1"># self.subacqs = [QubicAcquisition(self.multiinstrument[i], self.sampling, self.scene, self.d) for i in range(len(self.multiinstrument))]</span>

        <span class="c1">############</span>
        <span class="c1">### FWHM ###</span>
        <span class="c1">############</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">comm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">comm</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">allfwhm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">allfwhm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_convolution_peak_operator</span><span class="p">()</span><span class="o">.</span><span class="n">fwhm</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">final_fwhm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;nf_recon&quot;</span><span class="p">])</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;nf_sub&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;nf_recon&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;nf_recon&quot;</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">final_fwhm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">allfwhm</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">fact</span><span class="p">)</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">fact</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))]</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_average_instrument_acq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nu</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create and return a QubicAcquisition instance of a monochromatic</span>
<span class="sd">            instrument with frequency correspondent to the mean of the</span>
<span class="sd">            frequency range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if len(self) == 1:</span>
        <span class="c1">#    return self[0]</span>
        <span class="n">q0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nu_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">nu</span>
        <span class="n">nu_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiinstrument</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">nu</span>
        <span class="n">nep</span> <span class="o">=</span> <span class="n">q0</span><span class="o">.</span><span class="n">detector</span><span class="o">.</span><span class="n">nep</span>
        <span class="n">fknee</span> <span class="o">=</span> <span class="n">q0</span><span class="o">.</span><span class="n">detector</span><span class="o">.</span><span class="n">fknee</span>
        <span class="n">fslope</span> <span class="o">=</span> <span class="n">q0</span><span class="o">.</span><span class="n">detector</span><span class="o">.</span><span class="n">fslope</span>

        <span class="n">d1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;filter_nu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nu</span> <span class="o">*</span> <span class="mf">1e9</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;filter_relative_bandwidth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.25</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;detector_nep&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nep</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;detector_fknee&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fknee</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;detector_fslope&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fslope</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">QubicInstrument</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">FRBW</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
        <span class="n">q</span><span class="o">.</span><span class="n">detector</span> <span class="o">=</span> <span class="n">q0</span><span class="o">.</span><span class="n">detector</span>
        <span class="c1"># s_ = self.sampling</span>
        <span class="c1"># nsamplings = self.multiinstrument[0].comm.allreduce(len(s_))</span>

        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;random_pointing&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;sweeping_pointing&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;repeat_pointing&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;RA_center&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;DEC_center&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;npointings&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;npointings&quot;</span><span class="p">]</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;dtheta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">15.0</span>
        <span class="n">d1</span><span class="p">[</span><span class="s2">&quot;period&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;period&quot;</span><span class="p">]</span>

        <span class="c1"># s = create_random_pointings([0., 0.], nsamplings, 10., period=s_.period)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">QubicAcquisition</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scene</span><span class="p">,</span> <span class="n">d1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">q</span>

<div class="viewcode-block" id="QubicIntegrated.get_noise">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicIntegrated.get_noise">[docs]</a>
    <span class="k">def</span> <span class="nf">get_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">det_noise</span><span class="p">,</span> <span class="n">photon_noise</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Method which compute the noise of QUBIC.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_average_instrument_acq</span><span class="p">(</span><span class="n">nu</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;filter_nu&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">get_noise</span><span class="p">(</span><span class="n">det_noise</span><span class="o">=</span><span class="n">det_noise</span><span class="p">,</span> <span class="n">photon_noise</span><span class="o">=</span><span class="n">photon_noise</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span></div>


<div class="viewcode-block" id="QubicIntegrated.get_TOD">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicIntegrated.get_TOD">[docs]</a>
    <span class="k">def</span> <span class="nf">get_TOD</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">skyconfig</span><span class="p">,</span>
        <span class="n">beta</span><span class="p">,</span>
        <span class="n">convolution</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">myfwhm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">bandpass_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Method which allow to compute QUBIC TOD for a given skyconfig according to a given beta.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">Sky</span><span class="p">(</span><span class="n">skyconfig</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">m_nu</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">scale_component</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
        <span class="n">sed</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">get_SED</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>

        <span class="c1">### Compute operator with Nsub acqusitions</span>
        <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_array_of_operators</span><span class="p">(</span><span class="n">convolution</span><span class="o">=</span><span class="n">convolution</span><span class="p">,</span> <span class="n">myfwhm</span><span class="o">=</span><span class="n">myfwhm</span><span class="p">)</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">BlockRowOperator</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tod</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="n">m_nu</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tod</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="n">m_nu</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">noise</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_noise</span><span class="p">()</span>
            <span class="n">tod</span> <span class="o">+=</span> <span class="n">n</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">bandpass_correction</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Bandpass correction&quot;</span><span class="p">)</span>
            <span class="c1"># print(s.map_ref, beta)</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">map_ref</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">beta</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Check that map_ref or sed are not set to None&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_cmb</span><span class="p">:</span>
                <span class="n">sed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sed</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">])</span>
                <span class="c1"># print(sed.shape)</span>
            <span class="n">tod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bandpass_correction</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">tod</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">map_ref</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">i_dust</span><span class="p">],</span> <span class="n">sed</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tod</span></div>


<div class="viewcode-block" id="QubicIntegrated.bandpass_correction">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicIntegrated.bandpass_correction">[docs]</a>
    <span class="k">def</span> <span class="nf">bandpass_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">tod</span><span class="p">,</span> <span class="n">map_ref</span><span class="p">,</span> <span class="n">sed</span><span class="p">):</span>

        <span class="n">fact</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nsub</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">modelsky</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allnus</span><span class="p">),</span> <span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="c1"># print(sed.shape, np.array([map_ref[:, i]]).shape)</span>
            <span class="n">modelsky</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sed</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">map_ref</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">irec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span><span class="p">):</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">modelsky</span><span class="p">[</span><span class="n">fact</span> <span class="o">*</span> <span class="n">irec</span> <span class="p">:</span> <span class="p">(</span><span class="n">irec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">fact</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                <span class="n">modelsky</span><span class="p">[</span><span class="n">fact</span> <span class="o">*</span> <span class="n">irec</span> <span class="p">:</span> <span class="p">(</span><span class="n">irec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">fact</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">jfact</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fact</span><span class="p">):</span>
                <span class="n">delta_tt</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">delta</span><span class="p">[</span><span class="n">jfact</span><span class="p">])</span>
                <span class="n">tod</span> <span class="o">-=</span> <span class="n">delta_tt</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">tod</span></div>


    <span class="k">def</span> <span class="nf">_get_array_of_operators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">convolution</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">myfwhm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">op</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Loop through each acquisition in subacqs</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">):</span>

            <span class="c1">###################</span>
            <span class="c1">### Convolution ###</span>
            <span class="c1">###################</span>

            <span class="k">if</span> <span class="n">convolution</span><span class="p">:</span>
                <span class="c1"># Calculate the convolution operator for this sub-acquisition</span>
                <span class="n">allfwhm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allfwhm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">allfwhm</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">myfwhm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">myfwhm</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span>
                <span class="n">C</span> <span class="o">=</span> <span class="n">HealpixConvolutionGaussianOperator</span><span class="p">(</span><span class="n">fwhm</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If convolution is False, set the operator to an identity operator</span>
                <span class="n">C</span> <span class="o">=</span> <span class="n">IdentityOperator</span><span class="p">()</span>

            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">op</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">get_operator</span><span class="p">()</span> <span class="o">*</span> <span class="n">C</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">op</span>

<div class="viewcode-block" id="QubicIntegrated.get_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicIntegrated.get_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">convolution</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">myfwhm</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Initialize an empty list to store the sum of operators for each frequency band</span>
        <span class="n">op_sum</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Get an array of operators for all sub-arrays</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_array_of_operators</span><span class="p">(</span><span class="n">convolution</span><span class="o">=</span><span class="n">convolution</span><span class="p">,</span> <span class="n">myfwhm</span><span class="o">=</span><span class="n">myfwhm</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># print(&#39;done&#39;)</span>
        <span class="c1"># Loop over the frequency bands</span>
        <span class="n">op_sum</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">irec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nrec</span><span class="p">):</span>
            <span class="n">imin</span> <span class="o">=</span> <span class="n">irec</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fact</span>
            <span class="n">imax</span> <span class="o">=</span> <span class="p">(</span><span class="n">irec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fact</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">op_sum</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">op</span><span class="p">[</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allnus</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allnus</span><span class="p">[</span><span class="n">imin</span><span class="p">])</span>
                    <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allnus</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allnus</span><span class="p">[</span><span class="n">imax</span><span class="p">])</span>
                <span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="k">return</span> <span class="n">BlockRowOperator</span><span class="p">(</span>
            <span class="n">op_sum</span><span class="p">,</span> <span class="n">new_axisin</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>  <span class="c1"># * MPIDistributionIdentityOperator(self.d[&#39;comm&#39;])</span></div>


<div class="viewcode-block" id="QubicIntegrated.get_coverage">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicIntegrated.get_coverage">[docs]</a>
    <span class="k">def</span> <span class="nf">get_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_coverage</span><span class="p">()</span></div>


<div class="viewcode-block" id="QubicIntegrated.get_invntt_operator">
<a class="viewcode-back" href="../../../lib.InstrumentModel.Qacquisition.html#lib.InstrumentModel.Qacquisition.QubicIntegrated.get_invntt_operator">[docs]</a>
    <span class="k">def</span> <span class="nf">get_invntt_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">det_noise</span><span class="p">,</span> <span class="n">photon_noise</span><span class="p">):</span>
        <span class="c1"># Get the inverse noise variance covariance matrix from the first sub-acquisition</span>
        <span class="c1"># invN = self.subacqs[0].get_invntt_operator(det_noise, photon_noise)</span>
        <span class="c1"># return invN</span>

        <span class="c1"># Get the inverse noise variance covariance matrix from the first sub-acquisition</span>
        <span class="c1"># invN = self.subacqs[0].get_invntt_operator(det_noise, photon_noise)</span>
        <span class="c1"># _, a = self._get_average_instrument_acq()</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">detector</span><span class="o">.</span><span class="n">nep</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;period&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">sigma_photon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">_get_noise_photon_nep</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scene</span>
        <span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;period&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">det_noise</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">photon_noise</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sigma_photon</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">det_noise</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">photon_noise</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="k">elif</span> <span class="n">det_noise</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">photon_noise</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sigma_photon</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">sigma</span>

        <span class="n">nsamplings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allreduce</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">))</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">DiagonalOperator</span><span class="p">(</span>
            <span class="mi">1</span> <span class="o">/</span> <span class="n">sig</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">broadcast</span><span class="o">=</span><span class="s2">&quot;rightward&quot;</span><span class="p">,</span>
            <span class="n">shapein</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subacqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">instrument</span><span class="o">.</span><span class="n">detector</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="p">)),</span>
        <span class="p">)</span>
        <span class="n">out</span> <span class="o">/=</span> <span class="p">(</span>
            <span class="n">nsamplings</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">period</span>
            <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;effective_duration&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">31557600</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, QUBIC collaboration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>