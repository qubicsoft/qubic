<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>lib.QskySim &mdash; qubicsoft  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            qubicsoft
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../lib.html">lib package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">qubicsoft</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">lib.QskySim</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for lib.QskySim</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span><span class="nn">string</span><span class="o">,</span><span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">healpy</span> <span class="k">as</span> <span class="nn">hp</span>
<span class="kn">import</span> <span class="nn">random</span> <span class="k">as</span> <span class="nn">rd</span>
<span class="kn">import</span> <span class="nn">pysm3</span> <span class="k">as</span> <span class="nn">pysm</span>
<span class="kn">import</span> <span class="nn">pysm3.units</span> <span class="k">as</span> <span class="nn">u</span>
<span class="kn">from</span> <span class="nn">pysm3</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>

<span class="kn">from</span> <span class="nn">.InstrumentModel.Qinstrument</span> <span class="kn">import</span> <span class="n">compute_freq</span>
<span class="kn">from</span> <span class="nn">.Qutilities</span> <span class="kn">import</span> <span class="n">progress_bar</span>
<span class="kn">from</span> <span class="nn">.Calibration</span> <span class="kn">import</span> <span class="n">Qfiber</span> <span class="k">as</span> <span class="n">ft</span>
<span class="kn">from</span> <span class="nn">.Fitting</span> <span class="kn">import</span> <span class="n">Qcamb</span> <span class="k">as</span> <span class="n">qc</span>
<span class="c1">#from qubic.lib.Instrument.Qinstrument import compute_freq</span>
<span class="c1">#from qubic.lib.Fitting import Qcamb as qc</span>
<span class="c1">#from qubic.lib.Calibration import Qfiber as ft</span>
<span class="c1">#from qubic.lib.Qutilities import progress_bar</span>
<span class="kn">from</span> <span class="nn">qubic.data</span> <span class="kn">import</span> <span class="n">PATH</span> <span class="k">as</span> <span class="n">data_dir</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sky&#39;</span><span class="p">,</span> <span class="s1">&#39;Qubic_sky&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">cov2corr</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a Covariance Matrix into a Correlation Matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mat</span>
    <span class="n">outmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">outmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">mat</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">outmat</span>


<span class="k">def</span> <span class="nf">corr2cov</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">diagvals</span><span class="p">):</span>
    <span class="n">sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mat</span>
    <span class="n">outmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">outmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">diagvals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">diagvals</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">outmat</span>


<div class="viewcode-block" id="sky">
<a class="viewcode-back" href="../../lib.QskySim.html#lib.QskySim.sky">[docs]</a>
<span class="k">class</span> <span class="nc">sky</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a sky object as seen by an instrument.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skyconfig</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">,</span> <span class="n">out_prefix</span><span class="p">,</span> <span class="n">lmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters:</span>
<span class="sd">        skyconfig  : a skyconfig dictionary to pass to (as expected by) `PySM`</span>
<span class="sd">        d          : input dictionary, from which the following Parameters are read</span>
<span class="sd">        instrument : a `PySM` instrument describing the instrument</span>
<span class="sd">        out_dir    : default path where the sky maps will be saved</span>
<span class="sd">        out_prefix : default word for the output files</span>

<span class="sd">        For more details about `PySM` see the `PySM` documentation at the floowing link: </span>
<span class="sd">        https://pysm-public.readthedocs.io/en/latest/index.html</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skyconfig</span> <span class="o">=</span> <span class="n">skyconfig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;nside&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npix</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nfin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;nf_sub&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nfout</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;nf_recon&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_nu</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;filter_nu&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e9</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_relative_bandwidth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;filter_relative_bandwidth&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span> <span class="o">=</span> <span class="n">instrument</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_directory</span> <span class="o">=</span> <span class="n">out_dir</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_prefix</span> <span class="o">=</span> <span class="n">out_prefix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_cmb_maps</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_cmb_spectra</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">lmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;nside&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lmax</span> <span class="o">=</span> <span class="n">lmax</span>

        <span class="n">iscmb</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">preset_strings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">skyconfig</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;cmb&#39;</span><span class="p">:</span>
                <span class="n">iscmb</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">keyword</span> <span class="o">=</span> <span class="n">skyconfig</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="c1"># the CMB part is defined via a dictionary</span>
                    <span class="c1"># This can be either a set of maps, a set of CAMB spectra, or whatever</span>
                    <span class="c1"># In the second case it might also contain the seed (None means rerun it each time)</span>
                    <span class="c1"># In the third case we recompute some CAMB spectra and generate the maps</span>
                    <span class="n">keys</span> <span class="o">=</span> <span class="n">keyword</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                    <span class="k">if</span> <span class="s1">&#39;IQUMaps&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                        <span class="c1"># this is the case where we have IQU maps</span>
                        <span class="n">mymaps</span> <span class="o">=</span> <span class="n">keyword</span><span class="p">[</span><span class="s1">&#39;IQUMaps&#39;</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">input_cmb_maps</span> <span class="o">=</span> <span class="n">mymaps</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">input_cmb_spectra</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">elif</span> <span class="s1">&#39;CAMBSpectra&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                        <span class="c1"># this is the case where we have CAMB Spectra</span>
                        <span class="c1"># Note that they are in l(l+1) CL/2pi so we have to change that for synfast</span>
                        <span class="n">totDL</span> <span class="o">=</span> <span class="n">keyword</span><span class="p">[</span><span class="s1">&#39;CAMBSpectra&#39;</span><span class="p">]</span>
                        <span class="n">ell</span> <span class="o">=</span> <span class="n">keyword</span><span class="p">[</span><span class="s1">&#39;ell&#39;</span><span class="p">]</span>
                        <span class="n">mycls</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">Dl2Cl_without_monopole</span><span class="p">(</span><span class="n">ell</span><span class="p">,</span> <span class="n">totDL</span><span class="p">)</span>
                        <span class="c1"># set the seed if needed</span>
                        <span class="k">if</span> <span class="s1">&#39;seed&#39;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">keyword</span><span class="p">[</span><span class="s1">&#39;seed&#39;</span><span class="p">])</span>
                        <span class="n">mymaps</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">synfast</span><span class="p">(</span><span class="n">mycls</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">input_cmb_maps</span> <span class="o">=</span> <span class="n">mymaps</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">input_cmb_spectra</span> <span class="o">=</span> <span class="n">totDL</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;Bad Dictionary given for PySM in the CMB part - see QubicSkySim.py for details&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># The CMB part is not defined via a dictionary but only by the seed for synfast</span>
                    <span class="c1"># No map nor CAMB spectra was given, so we recompute them.</span>
                    <span class="c1"># The assumed cosmology is the default one given in the get_CAMB_Dl() function</span>
                    <span class="c1"># from camb_interface library.</span>
                    <span class="k">if</span> <span class="n">keyword</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
                    <span class="n">ell</span><span class="p">,</span> <span class="n">totDL</span><span class="p">,</span> <span class="n">unlensedCL</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">get_camb_Dl</span><span class="p">(</span><span class="n">lmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lmax</span><span class="p">)</span>
                    <span class="n">mycls</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">Dl2Cl_without_monopole</span><span class="p">(</span><span class="n">ell</span><span class="p">,</span> <span class="n">totDL</span><span class="p">)</span>
                    <span class="n">mymaps</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">synfast</span><span class="p">(</span><span class="n">mycls</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">input_cmb_maps</span> <span class="o">=</span> <span class="n">mymaps</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">input_cmb_spectra</span> <span class="o">=</span> <span class="n">totDL</span>

                <span class="c1"># Write a temporary file with the maps so the PySM can read them</span>
                <span class="n">rndstr</span> <span class="o">=</span> <span class="n">random_string</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
                <span class="n">hp</span><span class="o">.</span><span class="n">write_map</span><span class="p">(</span><span class="s1">&#39;/tmp/&#39;</span> <span class="o">+</span> <span class="n">rndstr</span><span class="p">,</span> <span class="n">mymaps</span><span class="p">)</span>
                <span class="n">cmbmap</span> <span class="o">=</span> <span class="n">pysm</span><span class="o">.</span><span class="n">CMBMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="n">map_IQU</span><span class="o">=</span><span class="s1">&#39;/tmp/&#39;</span> <span class="o">+</span> <span class="n">rndstr</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;/tmp/&#39;</span> <span class="o">+</span> <span class="n">rndstr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># we add the other predefined components</span>
                <span class="n">preset_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">skyconfig</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sky</span> <span class="o">=</span> <span class="n">pysm</span><span class="o">.</span><span class="n">Sky</span><span class="p">(</span><span class="n">nside</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="n">preset_strings</span><span class="o">=</span><span class="n">preset_strings</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">iscmb</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sky</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="n">cmbmap</span><span class="p">)</span>

<div class="viewcode-block" id="sky.get_simple_sky_map">
<a class="viewcode-back" href="../../lib.QskySim.html#lib.QskySim.sky.get_simple_sky_map">[docs]</a>
    <span class="k">def</span> <span class="nf">get_simple_sky_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create as many skies as the number of input frequencies.</span>
<span class="sd">        Instrumental effects are not considered.</span>
<span class="sd">        Return a vector of shape (number_of_input_subfrequencies, npix, 3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">nus_edge</span><span class="p">,</span> <span class="n">nus_in</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">Nbbands_in</span> <span class="o">=</span> <span class="n">compute_freq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_nu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nfin</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">filter_relative_bandwidth</span><span class="p">)</span>

        <span class="n">sky</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Nfin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1">##### This is the old code by JCH - It has been replaced by what Edgar Jaber has proposed</span>
        <span class="c1">##### see his presentation on Git: qubic/scripts/ComponentSeparation/InternshipJaber/teleconf_03122020.pdf</span>
        <span class="c1"># for i in range(Nf):</span>
        <span class="c1">#     # ###################### This is puzzling part here: ############################</span>
        <span class="c1">#     # # See Issue on PySM Git: https://github.com/healpy/pysm/issues/49</span>
        <span class="c1">#     # ###############################################################################</span>
        <span class="c1">#     # # #### THIS IS WHAT WOULD MAKE SENSE BUT DOES NOT WORK ~ 5% on maps w.r.t. input</span>
        <span class="c1">#     # # nfreqinteg = 5</span>
        <span class="c1">#     # # nus = np.linspace(nus_edge[i], nus_edge[i + 1], nfreqinteg)</span>
        <span class="c1">#     # # freqs = utils.check_freq_input(nus)</span>
        <span class="c1">#     # # convert_to_uK_RJ = (np.ones(len(freqs), dtype=np.double) * u.uK_CMB).to_value(</span>
        <span class="c1">#     # # u.uK_RJ, equivalencies=u.cmb_equivalencies(freqs))</span>
        <span class="c1">#     # # #print(&#39;Convert_to_uK_RJ :&#39;,convert_to_uK_RJ)</span>
        <span class="c1">#     # # weights = np.ones(nfreqinteg) * convert_to_uK_RJ</span>
        <span class="c1">#     # ###############################################################################</span>
        <span class="c1">#     # ###### Works OK but not clear why...</span>
        <span class="c1">#     # ###############################################################################</span>
        <span class="c1">#     # nfreqinteg = 5</span>
        <span class="c1">#     # nus = np.linspace(nus_edge[i], nus_edge[i + 1], nfreqinteg)</span>
        <span class="c1">#     # filter_uK_CMB = np.ones(len(nus), dtype=np.double)</span>
        <span class="c1">#     # filter_uK_CMB_normalized = utils.normalize_weights(nus, filter_uK_CMB)</span>
        <span class="c1">#     # weights = 1. / filter_uK_CMB_normalized</span>
        <span class="c1">#     # ###############################################################################</span>

        <span class="c1">#     # ### Integrate through band using filter shape defined in weights</span>
        <span class="c1">#     # themaps_iqu = self.sky.get_emission(nus * u.GHz, weights=weights)</span>
        <span class="c1">#     # sky[i, :, :] = np.array(themaps_iqu.to(u.uK_CMB, equivalencies=u.cmb_equivalencies(nus_in[i] * u.GHz))).T</span>
        <span class="c1">#     # ratio = np.mean(self.input_cmb_maps[0,:]/sky[i,:,0])</span>
        <span class="c1">#     # print(&#39;Ratio to initial: &#39;,ratio)</span>

        <span class="c1"># #### Here is the new code from Edgar Jaber</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nfin</span><span class="p">):</span>
            <span class="n">nfreqinteg</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">nus_edge</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nus_edge</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">nfreqinteg</span><span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nfreqinteg</span><span class="p">)</span>
            <span class="n">sky</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">sky</span><span class="o">.</span><span class="n">get_emission</span><span class="p">(</span><span class="n">freqs</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">GHz</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span> <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">bandpass_unit_conversion</span><span class="p">(</span><span class="n">freqs</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">GHz</span><span class="p">,</span>
                                                                                                   <span class="n">weights</span><span class="p">,</span>
                                                                                                   <span class="n">u</span><span class="o">.</span><span class="n">uK_CMB</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">sky</span></div>
</div>


    <span class="c1"># ### This is not supported yet....</span>
    <span class="c1"># def read_sky_map(self):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Returns the maps saved in the `output_directory` containing the `output_prefix`.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     map_list = [s for s in os.listdir(self.output_directory) if self.output_prefix in s]</span>
    <span class="c1">#     map_list = [m for m in map_list if &#39;total&#39; in m]</span>
    <span class="c1">#     if len(map_list) &gt; len(self.instrument.Frequencies):</span>
    <span class="c1">#         map_list = np.array(</span>
    <span class="c1">#             [[m for m in map_list if x in m] for x in self.instrument.Channel_Names]).ravel().tolist()</span>
    <span class="c1">#     maps = np.zeros((len(map_list), hp.nside2npix(self.nside), 3))</span>
    <span class="c1">#     for i, title in enumerate(map_list):</span>
    <span class="c1">#         maps[i] = hp.read_map(title, field=(0, 1, 2)).T</span>
    <span class="c1">#     return map_list, maps</span>

    <span class="c1"># def get_sky_map(self):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Returns the maps saved in the `output_directory` containing the `output_prefix`. If</span>
    <span class="c1">#     there are no maps in the `ouput_directory` they will be created.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     sky_map_list, sky_map = self.read_sky_map()</span>
    <span class="c1">#     if len(sky_map_list) &lt; len(self.instrument.Frequencies):</span>
    <span class="c1">#         self.instrument.observe(self.sky)</span>
    <span class="c1">#         sky_map_list, sky_map = self.read_sky_map()</span>
    <span class="c1">#     return sky_map</span>


<span class="c1"># ### This part has been commented as it is not yet compatible with PySM3</span>
<span class="c1"># ### it was written by F. Incardona using PySM2</span>
<span class="c1"># class Planck_sky(sky):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Define a sky object as seen by Planck.</span>
<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     def __init__(self, skyconfig, d, output_directory=&quot;./&quot;, output_prefix=&quot;planck_sky&quot;, band=143):</span>
<span class="c1">#         self.band = band</span>
<span class="c1">#         self.planck_central_nus = np.array([30, 44, 70, 100, 143, 217, 353, 545, 857])</span>
<span class="c1">#         self.planck_relative_bandwidths = np.array([0.2, 0.2, 0.2, 0.33, 0.33, 0.33, 0.33, 0.33, 0.33])</span>
<span class="c1">#         self.planck_beams = np.array([33, 24, 14, 9.2, 7.1, 5.5, 5, 5, 5])</span>
<span class="c1">#         self.planck_Isensitivities_pixel = np.array([2, 2.7, 4.7, 2, 2.2, 4.8, 14.7, 147, 6700])</span>
<span class="c1">#         self.planck_Psensitivities_pixel = np.array([2.8, 3.9, 6.7, np.NaN, 4.2, 9.8, 29.8, np.NaN, np.NaN])</span>
<span class="c1">#         self.planck_channels = self.create_planck_bandwidth()</span>
<span class="c1">#         self.planck_channels_names = [&#39;33_GHz&#39;, &#39;44_GHz&#39;, &#39;70_GHz&#39;, &#39;100_GHz&#39;, &#39;143_GHz&#39;, &#39;217_GHz&#39;, &#39;353_GHz&#39;,</span>
<span class="c1">#                                       &#39;545_GHz&#39;, &#39;857_GHz&#39;]</span>

<span class="c1">#         if band is not None:</span>
<span class="c1">#             idx = np.argwhere(self.planck_central_nus == band)[0][0]</span>
<span class="c1">#             instrument = pysm.Instrument(</span>
<span class="c1">#                 {&#39;nside&#39;: d[&#39;nside&#39;], &#39;frequencies&#39;: self.planck_central_nus[idx:idx + 1],  # GHz</span>
<span class="c1">#                  &#39;use_smoothing&#39;: True, &#39;beams&#39;: self.planck_beams[idx:idx + 1],  # arcmin</span>
<span class="c1">#                  &#39;add_noise&#39;: True,  # If True `sens_I` and `sens_Q` are required</span>
<span class="c1">#                  &#39;noise_seed&#39;: 0,  # Not used if `add_noise` is False</span>
<span class="c1">#                  &#39;sens_I&#39;: self.get_planck_sensitivity(&quot;I&quot;)[idx:idx + 1],  # Not used if `add_noise` is False</span>
<span class="c1">#                  &#39;sens_P&#39;: self.get_planck_sensitivity(&quot;P&quot;)[idx:idx + 1],  # Not used if `add_noise` is False</span>
<span class="c1">#                  &#39;use_bandpass&#39;: True,  # If True pass banpasses  with the key `channels`</span>
<span class="c1">#                  &#39;channel_names&#39;: self.planck_channels_names[idx:idx + 1],</span>
<span class="c1">#                  &#39;channels&#39;: self.planck_channels[idx:idx + 1], &#39;output_units&#39;: &#39;uK_RJ&#39;,</span>
<span class="c1">#                  &#39;output_directory&#39;: output_directory, &#39;output_prefix&#39;: output_prefix, &#39;pixel_indices&#39;: None})</span>
<span class="c1">#         else:</span>
<span class="c1">#             instrument = {&#39;nside&#39;: d[&#39;nside&#39;], &#39;frequencies&#39;: self.planck_central_nus,  # GHz</span>
<span class="c1">#                                           &#39;use_smoothing&#39;: True, &#39;beams&#39;: self.planck_beams,  # arcmin</span>
<span class="c1">#                                           &#39;add_noise&#39;: True,  # If True `sens_I` and `sens_Q` are required</span>
<span class="c1">#                                           &#39;noise_seed&#39;: 0,  # Not used if `add_noise` is False</span>
<span class="c1">#                                           &#39;sens_I&#39;: self.get_planck_sensitivity(&quot;I&quot;),</span>
<span class="c1">#                                           # Not used if `add_noise` is False</span>
<span class="c1">#                                           &#39;sens_P&#39;: self.get_planck_sensitivity(&quot;P&quot;),</span>
<span class="c1">#                                           # Not used if `add_noise` is False</span>
<span class="c1">#                                           &#39;use_bandpass&#39;: True,  # If True pass banpasses  with the key `channels`</span>
<span class="c1">#                                           &#39;channel_names&#39;: self.planck_channels_names, &#39;channels&#39;: self.planck_channels,</span>
<span class="c1">#                                           &#39;output_units&#39;: &#39;uK_RJ&#39;, &#39;output_directory&#39;: output_directory,</span>
<span class="c1">#                                           &#39;output_prefix&#39;: output_prefix, &#39;pixel_indices&#39;: None}</span>

<span class="c1">#         sky.__init__(self, skyconfig, d, instrument, output_directory, output_prefix)</span>

<span class="c1">#     def create_planck_bandwidth(self, length=100):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Returns a list of bandwidths and respectively weights correponding to the ideal Planck bandwidths.</span>
<span class="c1">#         `planck_central_nus` must be an array containing the central frequency of the channel while the</span>
<span class="c1">#         `planck_relative_bandwidth` parameter must be an array containig the relative bandwidths for </span>
<span class="c1">#         each Planck channel. `length` is the length of the output array; default is 100.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         halfband = self.planck_relative_bandwidths * self.planck_central_nus / 2</span>
<span class="c1">#         bandwidths = np.zeros((len(self.planck_relative_bandwidths), length))</span>
<span class="c1">#         v = []</span>
<span class="c1">#         for i, hb in enumerate(halfband):</span>
<span class="c1">#             bandwidths[i] = np.linspace(self.planck_central_nus[i] - hb, self.planck_central_nus[i] + hb, num=length)</span>
<span class="c1">#             v.append((bandwidths[i], np.ones_like(bandwidths[i])))</span>
<span class="c1">#         return v</span>

<span class="c1">#     def get_planck_sensitivity(self, kind):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Convert the sensitiviy per pixel to sensitivity per arcmin.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         if kind == &quot;I&quot;:</span>
<span class="c1">#             return self.planck_Isensitivities_pixel * self.planck_beams ** 2</span>
<span class="c1">#         return self.planck_Psensitivities_pixel * self.planck_beams ** 2</span>


<div class="viewcode-block" id="Qubic_sky">
<a class="viewcode-back" href="../../lib.QskySim.html#lib.QskySim.Qubic_sky">[docs]</a>
<span class="k">class</span> <span class="nc">Qubic_sky</span><span class="p">(</span><span class="n">sky</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a sky object as seen by Qubic</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skyconfig</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">output_directory</span><span class="o">=</span><span class="s2">&quot;./&quot;</span><span class="p">,</span> <span class="n">output_prefix</span><span class="o">=</span><span class="s2">&quot;qubic_sky&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nfin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;nf_sub&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nfout</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;nf_recon&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_relative_bandwidth</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;filter_relative_bandwidth&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_nu</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;filter_nu&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1e9</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">nus_edge_in</span><span class="p">,</span> <span class="n">central_nus</span><span class="p">,</span> <span class="n">deltas</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_freq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_nu</span><span class="p">,</span>
                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">Nfin</span><span class="p">,</span>
                                                                 <span class="bp">self</span><span class="o">.</span><span class="n">filter_relative_bandwidth</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qubic_central_nus</span> <span class="o">=</span> <span class="n">central_nus</span>
        <span class="c1"># THESE LINES HAVE TO BE CONFIRMED/IMPROVED in future since fwhm = lambda / (P Delta_x)</span>
        <span class="c1"># is an approximation for the resolution</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;FI&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fi2td</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;TD&#39;</span><span class="p">:</span>
            <span class="n">P_FI</span> <span class="o">=</span> <span class="mi">22</span>  <span class="c1"># horns in the largest baseline in the FI</span>
            <span class="n">P_TD</span> <span class="o">=</span> <span class="mi">8</span>  <span class="c1"># horns in the largest baseline in the TD</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fi2td</span> <span class="o">=</span> <span class="p">(</span><span class="n">P_FI</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">P_TD</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qubic_resolution_nus</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;synthbeam_peak150_fwhm&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">150</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic_central_nus</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fi2td</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qubic_channels_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{:.3s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;_GHz&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic_central_nus</span><span class="p">]</span>

        <span class="n">instrument</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nside&#39;</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;nside&#39;</span><span class="p">],</span> <span class="s1">&#39;frequencies&#39;</span><span class="p">:</span> <span class="n">central_nus</span><span class="p">,</span>  <span class="c1"># GHz</span>
                      <span class="s1">&#39;use_smoothing&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;beams&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">central_nus</span><span class="p">),</span>  <span class="c1"># arcmin</span>
                      <span class="s1">&#39;add_noise&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>  <span class="c1"># If True `sens_I` and `sens_Q` are required</span>
                      <span class="s1">&#39;noise_seed&#39;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">,</span>  <span class="c1"># Not used if `add_noise` is False</span>
                      <span class="s1">&#39;sens_I&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">central_nus</span><span class="p">),</span>  <span class="c1"># Not used if `add_noise` is False</span>
                      <span class="s1">&#39;sens_P&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">central_nus</span><span class="p">),</span>  <span class="c1"># Not used if `add_noise` is False</span>
                      <span class="s1">&#39;use_bandpass&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>  <span class="c1"># If True pass banpasses  with the key `channels`</span>
                      <span class="s1">&#39;channel_names&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic_channels_names</span><span class="p">,</span>  <span class="c1"># np.ones_like(central_nus),</span>
                      <span class="s1">&#39;channels&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">central_nus</span><span class="p">),</span> <span class="s1">&#39;output_units&#39;</span><span class="p">:</span> <span class="s1">&#39;uK_RJ&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;output_directory&#39;</span><span class="p">:</span> <span class="n">output_directory</span><span class="p">,</span> <span class="s1">&#39;output_prefix&#39;</span><span class="p">:</span> <span class="n">output_prefix</span><span class="p">,</span>
                      <span class="s1">&#39;pixel_indices&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

        <span class="n">sky</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skyconfig</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">instrument</span><span class="p">,</span> <span class="n">output_directory</span><span class="p">,</span> <span class="n">output_prefix</span><span class="p">)</span>

<div class="viewcode-block" id="Qubic_sky.get_fullsky_convolved_maps">
<a class="viewcode-back" href="../../lib.QskySim.html#lib.QskySim.Qubic_sky.get_fullsky_convolved_maps">[docs]</a>
    <span class="k">def</span> <span class="nf">get_fullsky_convolved_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FWHMdeg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This returns full sky maps at each subfrequency convolved by the beam of  the  instrument at</span>
<span class="sd">        each frequency or with another beam if FWHMdeg is provided.</span>
<span class="sd">        when FWHMdeg is 0, the maps are not convolved.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        FWHMdeg: float</span>
<span class="sd">        verbose: bool</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># First get the full sky maps</span>
        <span class="n">fullmaps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_simple_sky_map</span><span class="p">()</span>

        <span class="c1"># Convolve the maps</span>
        <span class="n">fwhms</span><span class="p">,</span> <span class="n">fullmaps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing</span><span class="p">(</span><span class="n">fullmaps</span><span class="p">,</span> <span class="n">FWHMdeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nfin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubic_central_nus</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instrument</span><span class="p">[</span><span class="s1">&#39;beams&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fwhms</span>

        <span class="k">return</span> <span class="n">fullmaps</span></div>


<div class="viewcode-block" id="Qubic_sky.smoothing">
<a class="viewcode-back" href="../../lib.QskySim.html#lib.QskySim.Qubic_sky.smoothing">[docs]</a>
    <span class="k">def</span> <span class="nf">smoothing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">,</span> <span class="n">FWHMdeg</span><span class="p">,</span> <span class="n">Nf</span><span class="p">,</span> <span class="n">central_nus</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convolve the maps to the FWHM at each sub-frequency or to a common beam if FWHMdeg is given.&quot;&quot;&quot;</span>
        <span class="n">fwhms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">FWHMdeg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fwhms</span> <span class="o">+=</span> <span class="n">FWHMdeg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fwhms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;synthbeam_peak150_fwhm&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">150.</span> <span class="o">/</span> <span class="n">central_nus</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fi2td</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nf</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fwhms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">maps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">sphtfunc</span><span class="o">.</span><span class="n">smoothing</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">fwhms</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">fwhms</span><span class="p">,</span> <span class="n">maps</span></div>


<div class="viewcode-block" id="Qubic_sky.get_partial_sky_maps_withnoise">
<a class="viewcode-back" href="../../lib.QskySim.html#lib.QskySim.Qubic_sky.get_partial_sky_maps_withnoise">[docs]</a>
    <span class="k">def</span> <span class="nf">get_partial_sky_maps_withnoise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coverage</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">version_FastSim</span><span class="o">=</span><span class="s1">&#39;01&#39;</span><span class="p">,</span> <span class="n">sigma_sec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                       <span class="n">Nyears</span><span class="o">=</span><span class="mf">4.</span><span class="p">,</span> <span class="n">FWHMdeg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                       <span class="n">noise_profile</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">spatial_noise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nunu_correlation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">noise_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">integrate_into_band</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">noise_covcut</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This returns maps in the same way as with get_simple_sky_map but cut according to the coverage</span>
<span class="sd">        and with noise added according to this coverage and the RMS in muK.sqrt(sec) given by sigma_sec</span>
<span class="sd">        The default integration time is 4 years but can be modified with optional variable Nyears</span>
<span class="sd">        Note that the maps are convolved with the instrument beam by default, or with FWHMdeg (can be an array)</span>
<span class="sd">        if provided.</span>
<span class="sd">        If seed is provided, it will be used for the noise realization. If not it will be a new realization at</span>
<span class="sd">        each call.</span>
<span class="sd">        The optional effective_variance_invcov keyword is a modification law to be applied to the coverage in order to obtain</span>
<span class="sd">        more realistic noise profile. It is a law for effective RMS as a function of inverse coverage and is 2D array</span>
<span class="sd">        with the first one being (nx samples) inverse coverage and the second being the corresponding effective variance to be</span>
<span class="sd">        used through interpolation when generating the noise.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coverage: array</span>
<span class="sd">            Coverage map of the sky.</span>
<span class="sd">            By default, we load a coverage centered on the galactic center with 10000 pointings.</span>
<span class="sd">        version_FastSim: str</span>
<span class="sd">            Version of the FastSimulator files: 01, 02, 03... For now, only 01 exists.</span>
<span class="sd">        sigma_sec: float</span>
<span class="sd">        Nyears: float</span>
<span class="sd">            Integration time for observation to scale the noise, by default it is 4.</span>
<span class="sd">        FWHMdeg:</span>
<span class="sd">        seed:</span>
<span class="sd">        noise_profile:</span>
<span class="sd">        spatial_noise: bool</span>
<span class="sd">            If True, spatial noise correlations are added. True by default.</span>
<span class="sd">        nunu_correlation: bool</span>
<span class="sd">            If True, correlations between frequency sub-bands are added. True by default.</span>
<span class="sd">        noise_only: bool</span>
<span class="sd">            If True, only returns the noise maps and the coverage (without the sky signal).</span>
<span class="sd">        integrate_into_band: bool</span>
<span class="sd">            If True, averaging input sub-band maps into reconstruction sub-bands. True by default.</span>
<span class="sd">        verbose: bool</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        maps + noisemaps, maps, noisemaps, coverage</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">### Input bands</span>
        <span class="n">Nfreq_edges</span><span class="p">,</span> <span class="n">nus_edge</span><span class="p">,</span> <span class="n">nus</span><span class="p">,</span> <span class="n">deltas</span><span class="p">,</span> <span class="n">Delta</span><span class="p">,</span> <span class="n">Nbbands</span> <span class="o">=</span> <span class="n">compute_freq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_nu</span><span class="p">,</span>
                                                                          <span class="bp">self</span><span class="o">.</span><span class="n">Nfin</span><span class="p">,</span>
                                                                          <span class="bp">self</span><span class="o">.</span><span class="n">filter_relative_bandwidth</span><span class="p">)</span>
        <span class="c1">### Output bands</span>
        <span class="c1"># Check Nfout is between 1 and 8.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nfout</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nfout</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;Nfout should be contained between 1 and 8 for FastSimulation.&quot;</span><span class="p">)</span>
        <span class="n">Nfreq_edges_out</span><span class="p">,</span> <span class="n">nus_edge_out</span><span class="p">,</span> <span class="n">nus_out</span><span class="p">,</span> <span class="n">deltas_out</span><span class="p">,</span> <span class="n">Delta_out</span><span class="p">,</span> <span class="n">Nbbands_out</span> <span class="o">=</span> <span class="n">compute_freq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_nu</span><span class="p">,</span>
                                                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">Nfout</span><span class="p">,</span>
                                                                                                  <span class="bp">self</span><span class="o">.</span><span class="n">filter_relative_bandwidth</span><span class="p">)</span>

        <span class="c1"># First get the convolved maps</span>
        <span class="k">if</span> <span class="n">noise_only</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">maps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Nfout</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">integrate_into_band</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Convolving each input frequency map&#39;</span><span class="p">)</span>
                <span class="n">maps_all</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fullsky_convolved_maps</span><span class="p">(</span><span class="n">FWHMdeg</span><span class="o">=</span><span class="n">FWHMdeg</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

                <span class="c1"># Now averaging maps into reconstruction sub-bands maps</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Averaging input maps from input sub-bands into reconstruction sub-bands:&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nfout</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;doing band </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nus_edge_out</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nus_edge_out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                    <span class="n">inband</span> <span class="o">=</span> <span class="p">(</span><span class="n">nus</span> <span class="o">&gt;</span> <span class="n">nus_edge_out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nus</span> <span class="o">&lt;</span> <span class="n">nus_edge_out</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">maps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">maps_all</span><span class="p">[</span><span class="n">inband</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Nfout</span><span class="p">):</span>
                    <span class="n">freq</span> <span class="o">=</span> <span class="n">nus_out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">maps</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sky</span><span class="o">.</span><span class="n">get_emission</span><span class="p">(</span><span class="n">freq</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">GHz</span><span class="p">)</span>
                                     <span class="o">*</span> <span class="n">utils</span><span class="o">.</span><span class="n">bandpass_unit_conversion</span><span class="p">(</span><span class="n">freq</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">GHz</span><span class="p">,</span>
                                                                      <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                                                      <span class="n">output_unit</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">uK_CMB</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">maps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">FWHMdeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nfout</span><span class="p">,</span> <span class="n">nus_out</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1">##############################################################################################################</span>
        <span class="c1"># Restore data for FastSimulation ############################################################################</span>
        <span class="c1">##############################################################################################################</span>
        <span class="c1">#### Directory for fast simulations</span>
        <span class="n">dir_fast</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;FastSimulator_version</span><span class="si">{</span><span class="n">version_FastSim</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1">#### Integration time assumed in FastSim files</span>
        <span class="n">fastsimfile_effective_duration</span> <span class="o">=</span> <span class="mf">2.</span>

        <span class="n">fast_pkl</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_fast</span><span class="p">,</span><span class="s1">&#39;DataFastSimulator_</span><span class="si">{}{}</span><span class="s1">_nfsub_</span><span class="si">{}</span><span class="s1">.pkl&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">],</span>
                                                                                      <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_nu</span><span class="p">),</span>
                                                                                      <span class="bp">self</span><span class="o">.</span><span class="n">Nfout</span><span class="p">)</span>
                                <span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fast_pkl</span><span class="p">,</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;reading pickle file: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">fast_pkl</span><span class="p">)</span>
            <span class="n">DataFastSim</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
            
        <span class="c1"># Read Coverage map        </span>
        <span class="k">if</span> <span class="n">coverage</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coverage_pkl</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dir_fast</span><span class="p">,</span><span class="s1">&#39;DataFastSimulator_</span><span class="si">{}{}</span><span class="s1">_coverage.pkl&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">],</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_nu</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;reading coverage file: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">coverage_pkl</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">coverage_pkl</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span>
            <span class="n">DataFastSimCoverage</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            <span class="n">h</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">coverage</span> <span class="o">=</span> <span class="n">DataFastSimCoverage</span><span class="p">[</span><span class="s1">&#39;coverage&#39;</span><span class="p">]</span>
        <span class="c1"># Read noise normalization</span>
        <span class="k">if</span> <span class="n">sigma_sec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#### Beware ! Initial End-To-End simulations that produced the first FastSimulator were done with</span>
            <span class="c1">#### Effective_duration = 4 years and this is the meaning of signoise</span>
            <span class="c1">#### New files were done with 2 years and as result the signoise needs to be multiplied by sqrt(effective_duration/4)</span>
            <span class="n">sigma_sec</span> <span class="o">=</span> <span class="n">DataFastSim</span><span class="p">[</span><span class="s1">&#39;signoise&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">fastsimfile_effective_duration</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">)</span>

        <span class="c1"># # Read Nyears</span>
        <span class="c1"># if Nyears is None:</span>
        <span class="c1">#     Nyears = DataFastSim[&#39;years&#39;]</span>

        <span class="c1"># Read Noise Profile</span>
        <span class="k">if</span> <span class="n">noise_profile</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">effective_variance_invcov</span> <span class="o">=</span> <span class="n">DataFastSim</span><span class="p">[</span><span class="s1">&#39;effective_variance_invcov&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">effective_variance_invcov</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Read Spatial noise correlation</span>
        <span class="k">if</span> <span class="n">spatial_noise</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">clnoise</span> <span class="o">=</span> <span class="n">DataFastSim</span><span class="p">[</span><span class="s1">&#39;clnoise&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clnoise</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Read Noise Profile</span>
        <span class="k">if</span> <span class="n">nunu_correlation</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">covI</span> <span class="o">=</span> <span class="n">DataFastSim</span><span class="p">[</span><span class="s1">&#39;CovI&#39;</span><span class="p">]</span>
            <span class="n">covQ</span> <span class="o">=</span> <span class="n">DataFastSim</span><span class="p">[</span><span class="s1">&#39;CovQ&#39;</span><span class="p">]</span>
            <span class="n">covU</span> <span class="o">=</span> <span class="n">DataFastSim</span><span class="p">[</span><span class="s1">&#39;CovU&#39;</span><span class="p">]</span>
            <span class="n">sub_bands_cov</span> <span class="o">=</span> <span class="p">[</span><span class="n">covI</span><span class="p">,</span> <span class="n">covQ</span><span class="p">,</span> <span class="n">covU</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sub_bands_cov</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">##############################################################################################################</span>

        <span class="c1"># Now pure noise maps</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Making noise realizations&#39;</span><span class="p">)</span>
        <span class="n">noisemaps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_noise_maps</span><span class="p">(</span><span class="n">sigma_sec</span><span class="p">,</span> <span class="n">coverage</span><span class="p">,</span> <span class="n">nsub</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Nfout</span><span class="p">,</span>
                                           <span class="n">Nyears</span><span class="o">=</span><span class="n">Nyears</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
                                           <span class="n">effective_variance_invcov</span><span class="o">=</span><span class="n">effective_variance_invcov</span><span class="p">,</span>
                                           <span class="n">clnoise</span><span class="o">=</span><span class="n">clnoise</span><span class="p">,</span>
                                           <span class="n">sub_bands_cov</span><span class="o">=</span><span class="n">sub_bands_cov</span><span class="p">,</span>
                                           <span class="n">covcut</span><span class="o">=</span><span class="n">noise_covcut</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Nfout</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">noisemaps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">noisemaps</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coverage</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">seenpix</span> <span class="o">=</span> <span class="n">noisemaps</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="n">coverage</span><span class="p">[</span><span class="o">~</span><span class="n">seenpix</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">noise_only</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">noisemaps</span><span class="p">,</span> <span class="n">coverage</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">maps</span><span class="p">[:,</span> <span class="o">~</span><span class="n">seenpix</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">maps</span> <span class="o">+</span> <span class="n">noisemaps</span><span class="p">,</span> <span class="n">maps</span><span class="p">,</span> <span class="n">noisemaps</span><span class="p">,</span> <span class="n">coverage</span></div>


<div class="viewcode-block" id="Qubic_sky.create_noise_maps">
<a class="viewcode-back" href="../../lib.QskySim.html#lib.QskySim.Qubic_sky.create_noise_maps">[docs]</a>
    <span class="k">def</span> <span class="nf">create_noise_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma_sec</span><span class="p">,</span> <span class="n">coverage</span><span class="p">,</span> <span class="n">covcut</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">nsub</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                          <span class="n">Nyears</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">effective_variance_invcov</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">clnoise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">sub_bands_cov</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This returns a realization of noise maps for I, Q and U with no correlation between them, according to a</span>
<span class="sd">        noise RMS map built according to the coverage specified as an attribute to the class</span>
<span class="sd">        The optional effective_variance_invcov keyword is a modification law to be applied to the coverage in order to obtain</span>
<span class="sd">        more realistic noise profile. It is a law for effective RMS as a function of inverse coverage and is 2D array</span>
<span class="sd">        with the first one being (nx samples) inverse coverage and the second being the corresponding effective variance to be</span>
<span class="sd">        used through interpolation when generating the noise.</span>
<span class="sd">        The clnoise option is used to apply a convolution to the noise to obtain spatially correlated noise. This cl should be </span>
<span class="sd">        calculated from the c(theta) of the noise that can be measured using the function ctheta_parts() below. The transformation</span>
<span class="sd">        of this C9theta) into Cl has to be done using wrappers on camb function found in camb_interface.py of the QUBIC software:</span>
<span class="sd">        the functions to back and forth from ctheta to cl are: cl_2_ctheta and ctheta_2_cell. The simulation of the noise itself</span>
<span class="sd">        calls a function of camb_interface called simulate_correlated_map().</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sigma_sec</span>
<span class="sd">        coverage</span>
<span class="sd">        Nyears</span>
<span class="sd">        verbose</span>
<span class="sd">        seed</span>
<span class="sd">        effective_variance_invcov</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Seen pixels</span>
        <span class="n">seenpix</span> <span class="o">=</span> <span class="p">(</span><span class="n">coverage</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coverage</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">covcut</span>
        <span class="n">npix</span> <span class="o">=</span> <span class="n">seenpix</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># Sigma_sec for each Stokes: by default they are the same unless there is non trivial covariance</span>
        <span class="k">if</span> <span class="n">sub_bands_cov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fact_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nsub</span><span class="p">)</span>
            <span class="n">fact_Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nsub</span><span class="p">)</span>
            <span class="n">fact_U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nsub</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fact_I</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sub_bands_cov</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">sub_bands_cov</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="n">fact_Q</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sub_bands_cov</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sub_bands_cov</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="n">fact_U</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sub_bands_cov</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">sub_bands_cov</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>

        <span class="n">all_sigma_sec_I</span> <span class="o">=</span> <span class="n">fact_I</span> <span class="o">*</span> <span class="n">sigma_sec</span>
        <span class="n">all_sigma_sec_Q</span> <span class="o">=</span> <span class="n">fact_Q</span> <span class="o">*</span> <span class="n">sigma_sec</span>
        <span class="n">all_sigma_sec_U</span> <span class="o">=</span> <span class="n">fact_U</span> <span class="o">*</span> <span class="n">sigma_sec</span>

        <span class="n">thnoiseI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsub</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seenpix</span><span class="p">)))</span>
        <span class="n">thnoiseQ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsub</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seenpix</span><span class="p">)))</span>
        <span class="n">thnoiseU</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsub</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seenpix</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">isub</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsub</span><span class="p">):</span>
            <span class="c1"># The theoretical noise in I for the coverage</span>
            <span class="n">ideal_noise_I</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theoretical_noise_maps</span><span class="p">(</span><span class="n">all_sigma_sec_I</span><span class="p">[</span><span class="n">isub</span><span class="p">],</span> <span class="n">coverage</span><span class="p">,</span> <span class="n">Nyears</span><span class="o">=</span><span class="n">Nyears</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">ideal_noise_Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theoretical_noise_maps</span><span class="p">(</span><span class="n">all_sigma_sec_Q</span><span class="p">[</span><span class="n">isub</span><span class="p">],</span> <span class="n">coverage</span><span class="p">,</span> <span class="n">Nyears</span><span class="o">=</span><span class="n">Nyears</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">ideal_noise_U</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theoretical_noise_maps</span><span class="p">(</span><span class="n">all_sigma_sec_U</span><span class="p">[</span><span class="n">isub</span><span class="p">],</span> <span class="n">coverage</span><span class="p">,</span> <span class="n">Nyears</span><span class="o">=</span><span class="n">Nyears</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="n">sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ideal_noise_I</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">effective_variance_invcov</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">thnoiseI</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ideal_noise_I</span>
                <span class="n">thnoiseQ</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ideal_noise_Q</span>
                <span class="n">thnoiseU</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ideal_noise_U</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">effective_variance_invcov</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">my_effective_variance_invcov</span> <span class="o">=</span> <span class="n">effective_variance_invcov</span><span class="p">[</span><span class="n">isub</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">my_effective_variance_invcov</span> <span class="o">=</span> <span class="n">effective_variance_invcov</span>
                <span class="n">sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">my_effective_variance_invcov</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1">### We have the same correction for I, Q and U</span>
                    <span class="n">correction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coverage</span><span class="p">[</span><span class="n">seenpix</span><span class="p">])</span> <span class="o">/</span> <span class="n">coverage</span><span class="p">[</span><span class="n">seenpix</span><span class="p">],</span>
                                           <span class="n">my_effective_variance_invcov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">my_effective_variance_invcov</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="n">thnoiseI</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="n">seenpix</span><span class="p">]</span> <span class="o">=</span> <span class="n">ideal_noise_I</span><span class="p">[</span><span class="n">seenpix</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">correction</span><span class="p">)</span>
                    <span class="n">thnoiseQ</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="n">seenpix</span><span class="p">]</span> <span class="o">=</span> <span class="n">ideal_noise_Q</span><span class="p">[</span><span class="n">seenpix</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">correction</span><span class="p">)</span>
                    <span class="n">thnoiseU</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="n">seenpix</span><span class="p">]</span> <span class="o">=</span> <span class="n">ideal_noise_U</span><span class="p">[</span><span class="n">seenpix</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">correction</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">### We have distinct correction for I and QU</span>
                    <span class="n">correctionI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coverage</span><span class="p">[</span><span class="n">seenpix</span><span class="p">])</span> <span class="o">/</span> <span class="n">coverage</span><span class="p">[</span><span class="n">seenpix</span><span class="p">],</span>
                                            <span class="n">my_effective_variance_invcov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">my_effective_variance_invcov</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="n">correctionQU</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coverage</span><span class="p">[</span><span class="n">seenpix</span><span class="p">])</span> <span class="o">/</span> <span class="n">coverage</span><span class="p">[</span><span class="n">seenpix</span><span class="p">],</span>
                                             <span class="n">my_effective_variance_invcov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">my_effective_variance_invcov</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="n">thnoiseI</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="n">seenpix</span><span class="p">]</span> <span class="o">=</span> <span class="n">ideal_noise_I</span><span class="p">[</span><span class="n">seenpix</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">correctionI</span><span class="p">)</span>
                    <span class="n">thnoiseQ</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="n">seenpix</span><span class="p">]</span> <span class="o">=</span> <span class="n">ideal_noise_Q</span><span class="p">[</span><span class="n">seenpix</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">correctionQU</span><span class="p">)</span>
                    <span class="n">thnoiseU</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="n">seenpix</span><span class="p">]</span> <span class="o">=</span> <span class="n">ideal_noise_U</span><span class="p">[</span><span class="n">seenpix</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">correctionQU</span><span class="p">)</span>

        <span class="n">noise_maps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsub</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coverage</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1">### Simulate variance 1 maps for each sub-band independently</span>
        <span class="k">for</span> <span class="n">isub</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsub</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">clnoise</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1">### With no sspatial correlation</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">isub</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Simulating noise maps with no spatial correlation&#39;</span><span class="p">)</span>
                <span class="n">IrndFull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">)</span>
                <span class="n">QrndFull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">UrndFull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npix</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">### With spatial correlations given by cl which is the Legendre transform of the targetted C(theta)</span>
                <span class="c1">### NB: here one should not expect the variance of the obtained maps to make complete sense because</span>
                <span class="c1">### of ell space truncation. They have however the correct Cl spectrum in the relevant ell range </span>
                <span class="c1">### (up to lmax = 2*nside)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">isub</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Simulating noise maps with spatial correlation&#39;</span><span class="p">)</span>
                <span class="n">IrndFull</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">simulate_correlated_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">clin</span><span class="o">=</span><span class="n">clnoise</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">QrndFull</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">simulate_correlated_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">clin</span><span class="o">=</span><span class="n">clnoise</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">UrndFull</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">simulate_correlated_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nside</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">clin</span><span class="o">=</span><span class="n">clnoise</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1">### put them into the whole sub-bandss array</span>
            <span class="n">noise_maps</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="n">seenpix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">IrndFull</span><span class="p">[</span><span class="n">seenpix</span><span class="p">]</span>
            <span class="n">noise_maps</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="n">seenpix</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">QrndFull</span><span class="p">[</span><span class="n">seenpix</span><span class="p">]</span>
            <span class="n">noise_maps</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="n">seenpix</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">UrndFull</span><span class="p">[</span><span class="n">seenpix</span><span class="p">]</span>

        <span class="c1">### If there is non-diagonal noise covariance between sub-bands (spectro-imaging case)</span>
        <span class="k">if</span> <span class="n">nsub</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sub_bands_cov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Simulating noise maps sub-bands covariance&#39;</span><span class="p">)</span>
                <span class="c1">### We get the eigenvalues and eigenvectors of the sub-band covariance matrix divided by its 0,0 element</span>
                <span class="c1">### The reason for this si that the overall  noise is given by the input parameter sigma_sec which we do not</span>
                <span class="c1">### want to override</span>

                <span class="n">wI</span><span class="p">,</span> <span class="n">vI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">sub_bands_cov</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">sub_bands_cov</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">wQ</span><span class="p">,</span> <span class="n">vQ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">sub_bands_cov</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">sub_bands_cov</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">wU</span><span class="p">,</span> <span class="n">vU</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">sub_bands_cov</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">sub_bands_cov</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

                <span class="c1">### Multiply the maps by the sqrt(eigenvalues)</span>
                <span class="k">for</span> <span class="n">isub</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsub</span><span class="p">):</span>
                    <span class="n">noise_maps</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="n">seenpix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">wI</span><span class="p">[</span><span class="n">isub</span><span class="p">])</span>
                    <span class="n">noise_maps</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="n">seenpix</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">wQ</span><span class="p">[</span><span class="n">isub</span><span class="p">])</span>
                    <span class="n">noise_maps</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="n">seenpix</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">wU</span><span class="p">[</span><span class="n">isub</span><span class="p">])</span>
                <span class="c1">### Apply the rotation to each Stokes Parameter separately</span>

                <span class="n">noise_maps</span><span class="p">[:,</span> <span class="n">seenpix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vI</span><span class="p">,</span> <span class="n">noise_maps</span><span class="p">[:,</span> <span class="n">seenpix</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">noise_maps</span><span class="p">[:,</span> <span class="n">seenpix</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vQ</span><span class="p">,</span> <span class="n">noise_maps</span><span class="p">[:,</span> <span class="n">seenpix</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">noise_maps</span><span class="p">[:,</span> <span class="n">seenpix</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vU</span><span class="p">,</span> <span class="n">noise_maps</span><span class="p">[:,</span> <span class="n">seenpix</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

        <span class="c1"># Now normalize the maps with the coverage behaviour and the sqrt(2) for Q and U</span>
        <span class="n">noise_maps</span><span class="p">[:,</span> <span class="n">seenpix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">thnoiseI</span><span class="p">[:,</span> <span class="n">seenpix</span><span class="p">]</span>
        <span class="n">noise_maps</span><span class="p">[:,</span> <span class="n">seenpix</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">thnoiseQ</span><span class="p">[:,</span> <span class="n">seenpix</span><span class="p">]</span>
        <span class="n">noise_maps</span><span class="p">[:,</span> <span class="n">seenpix</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">thnoiseU</span><span class="p">[:,</span> <span class="n">seenpix</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">nsub</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">noise_maps</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">noise_maps</span></div>


<div class="viewcode-block" id="Qubic_sky.theoretical_noise_maps">
<a class="viewcode-back" href="../../lib.QskySim.html#lib.QskySim.Qubic_sky.theoretical_noise_maps">[docs]</a>
    <span class="k">def</span> <span class="nf">theoretical_noise_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma_sec</span><span class="p">,</span> <span class="n">coverage</span><span class="p">,</span> <span class="n">Nyears</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This returns a map of the RMS noise (not an actual realization, just the expected RMS - No covariance)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sigma_sec: float</span>
<span class="sd">            Noise level.</span>
<span class="sd">        coverage: array</span>
<span class="sd">            The coverage map.</span>
<span class="sd">        Nyears: int</span>
<span class="sd">        verbose: bool</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ###### Noise normalization</span>
        <span class="c1"># We assume we have integrated for a time Ttot in seconds with a sigma per root sec sigma_sec</span>
        <span class="n">Ttot</span> <span class="o">=</span> <span class="n">Nyears</span> <span class="o">*</span> <span class="mi">365</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">3600</span>  <span class="c1"># in seconds</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total time is </span><span class="si">{}</span><span class="s1"> seconds&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Ttot</span><span class="p">))</span>
        <span class="c1"># Oberved pixels</span>
        <span class="n">thepix</span> <span class="o">=</span> <span class="n">coverage</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="c1"># Normalized coverage (sum=1)</span>
        <span class="n">covnorm</span> <span class="o">=</span> <span class="n">coverage</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coverage</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Normalized coverage sum: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">covnorm</span><span class="p">)))</span>

        <span class="c1"># Time per pixel</span>
        <span class="n">Tpix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">covnorm</span><span class="p">)</span>
        <span class="n">Tpix</span><span class="p">[</span><span class="n">thepix</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ttot</span> <span class="o">*</span> <span class="n">covnorm</span><span class="p">[</span><span class="n">thepix</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sum Tpix: </span><span class="si">{}</span><span class="s1"> s  ; Ttot = </span><span class="si">{}</span><span class="s1"> s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Tpix</span><span class="p">),</span> <span class="n">Ttot</span><span class="p">))</span>

        <span class="c1"># RMS per pixel</span>
        <span class="n">Sigpix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">covnorm</span><span class="p">)</span>
        <span class="n">Sigpix</span><span class="p">[</span><span class="n">thepix</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma_sec</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Tpix</span><span class="p">[</span><span class="n">thepix</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total noise (with no averages in pixels): </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">Sigpix</span> <span class="o">*</span> <span class="n">Tpix</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">Sigpix</span></div>
</div>



<span class="k">def</span> <span class="nf">random_string</span><span class="p">(</span><span class="n">nchars</span><span class="p">):</span>
    <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">rd</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nchars</span><span class="p">)]</span>
    <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">str</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_noise_invcov_profile</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">coverage</span><span class="p">,</span> <span class="n">covcut</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                             <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allstokes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fitlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">QUsep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">seenpix</span> <span class="o">=</span> <span class="n">coverage</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">covcut</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coverage</span><span class="p">))</span>
    <span class="n">covnorm</span> <span class="o">=</span> <span class="n">coverage</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coverage</span><span class="p">)</span>

    <span class="n">xx</span><span class="p">,</span> <span class="n">yyI</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dyI</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ft</span><span class="o">.</span><span class="n">profile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">covnorm</span><span class="p">[</span><span class="n">seenpix</span><span class="p">]),</span> <span class="n">maps</span><span class="p">[</span><span class="n">seenpix</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">nbins</span><span class="o">=</span><span class="n">nbins</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">xx</span><span class="p">,</span> <span class="n">yyQ</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dyQ</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ft</span><span class="o">.</span><span class="n">profile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">covnorm</span><span class="p">[</span><span class="n">seenpix</span><span class="p">]),</span> <span class="n">maps</span><span class="p">[</span><span class="n">seenpix</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">nbins</span><span class="o">=</span><span class="n">nbins</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">xx</span><span class="p">,</span> <span class="n">yyU</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dyU</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ft</span><span class="o">.</span><span class="n">profile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">covnorm</span><span class="p">[</span><span class="n">seenpix</span><span class="p">]),</span> <span class="n">maps</span><span class="p">[</span><span class="n">seenpix</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">nbins</span><span class="o">=</span><span class="n">nbins</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">dyI</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dyQ</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dyU</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">avgQU</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">dyQ</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dyU</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">avg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="n">myY</span> <span class="o">=</span> <span class="p">(</span><span class="n">avg</span> <span class="o">/</span> <span class="n">xx</span><span class="p">)</span> <span class="o">*</span> <span class="n">fact</span>
    <span class="n">myYI</span> <span class="o">=</span> <span class="p">(</span><span class="n">dyI</span> <span class="o">/</span> <span class="n">xx</span><span class="p">)</span> <span class="o">*</span> <span class="n">fact</span>
    <span class="n">myYQU</span> <span class="o">=</span> <span class="p">(</span><span class="n">avgQU</span> <span class="o">/</span> <span class="n">xx</span><span class="p">)</span> <span class="o">*</span> <span class="n">fact</span>

    <span class="k">if</span> <span class="n">doplot</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">QUsep</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">xx</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">myY</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span> <span class="o">+</span> <span class="s1">&#39; IQU&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">allstokes</span><span class="p">:</span>
                <span class="n">plot</span><span class="p">(</span><span class="n">xx</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">myYI</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span> <span class="o">+</span> <span class="s1">&#39; I&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
                <span class="n">plot</span><span class="p">(</span><span class="n">xx</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">myYQU</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span> <span class="o">+</span> <span class="s1">&#39; Average Q, U /sqrt(2)&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pi</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">xx</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">myYI</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span> <span class="o">+</span> <span class="s1">&#39; I&#39;</span><span class="p">)</span>
            <span class="n">pqu</span> <span class="o">=</span> <span class="n">plot</span><span class="p">(</span><span class="n">xx</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">myYQU</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span> <span class="o">+</span> <span class="s1">&#39; QU / sqrt(2)&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fit</span><span class="p">:</span>
        <span class="n">ok</span> <span class="o">=</span> <span class="n">isfinite</span><span class="p">(</span><span class="n">myY</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fitlim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Clipping fit from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fitlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fitlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">ok</span> <span class="o">=</span> <span class="n">ok</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xx</span> <span class="o">&gt;=</span> <span class="n">fitlim</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xx</span> <span class="o">&lt;=</span> <span class="n">fitlim</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">QUsep</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">mymodel</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">e</span><span class="p">)))</span>  <span class="c1"># /(a+b+c*np.exp(-d*(1-e)))</span>
            <span class="n">myfit</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">mymodel</span><span class="p">,</span> <span class="n">xx</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">myY</span><span class="p">[</span><span class="n">ok</span><span class="p">],</span> <span class="n">p0</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">myY</span><span class="p">[</span><span class="n">ok</span><span class="p">]),</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span> <span class="n">maxfev</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span>
                              <span class="n">ftol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mymodel</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="p">(</span>
                    <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">f</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">g</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">e</span><span class="p">)))</span>  <span class="c1"># /(a+b+c*np.exp(-d*(1-e)))</span>
            <span class="n">myfitI</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">mymodel</span><span class="p">,</span> <span class="n">xx</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">myYI</span><span class="p">[</span><span class="n">ok</span><span class="p">],</span> <span class="n">p0</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">myY</span><span class="p">[</span><span class="n">ok</span><span class="p">]),</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
                               <span class="n">maxfev</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span> <span class="n">ftol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">)</span>
            <span class="n">myfitQU</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">mymodel</span><span class="p">,</span> <span class="n">xx</span><span class="p">[</span><span class="n">ok</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">myYQU</span><span class="p">[</span><span class="n">ok</span><span class="p">],</span> <span class="n">p0</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">myY</span><span class="p">[</span><span class="n">ok</span><span class="p">]),</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
                                <span class="n">maxfev</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span> <span class="n">ftol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">doplot</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">QUsep</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">plot</span><span class="p">(</span><span class="n">xx</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mymodel</span><span class="p">(</span><span class="n">xx</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">myfit</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span> <span class="o">+</span> <span class="s1">&#39; Fit&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_color</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plot</span><span class="p">(</span><span class="n">xx</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mymodel</span><span class="p">(</span><span class="n">xx</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">myfitI</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span> <span class="o">+</span> <span class="s1">&#39; Fit I&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">pi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_color</span><span class="p">())</span>
                <span class="n">plot</span><span class="p">(</span><span class="n">xx</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mymodel</span><span class="p">(</span><span class="n">xx</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">myfitQU</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span> <span class="o">+</span> <span class="s1">&#39; Fit QU / sqrt(2)&#39;</span><span class="p">,</span>
                     <span class="n">color</span><span class="o">=</span><span class="n">pqu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_color</span><span class="p">())</span>

            <span class="c1"># print(myfit[0])</span>
        <span class="c1"># Interpolation of the fit from invcov = 1 to 15</span>
        <span class="n">invcov_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">QUsep</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">eff_v</span> <span class="o">=</span> <span class="n">mymodel</span><span class="p">(</span><span class="n">invcov_samples</span><span class="p">,</span> <span class="o">*</span><span class="n">myfit</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="c1"># Avoid extrapolation problem for pixels before the first bin or after the last one.</span>
            <span class="n">eff_v</span><span class="p">[</span><span class="n">invcov_samples</span> <span class="o">&lt;</span> <span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mymodel</span><span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">myfit</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">eff_v</span><span class="p">[</span><span class="n">invcov_samples</span> <span class="o">&gt;</span> <span class="n">xx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mymodel</span><span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">myfit</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="n">effective_variance_invcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">invcov_samples</span><span class="p">,</span> <span class="n">eff_v</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eff_vI</span> <span class="o">=</span> <span class="n">mymodel</span><span class="p">(</span><span class="n">invcov_samples</span><span class="p">,</span> <span class="o">*</span><span class="n">myfitI</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">eff_vQU</span> <span class="o">=</span> <span class="n">mymodel</span><span class="p">(</span><span class="n">invcov_samples</span><span class="p">,</span> <span class="o">*</span><span class="n">myfitQU</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="c1"># Avoid extrapolation problem for pixels before the first bin or after the last one.</span>
            <span class="n">eff_vI</span><span class="p">[</span><span class="n">invcov_samples</span> <span class="o">&lt;</span> <span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mymodel</span><span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">myfitI</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">eff_vQU</span><span class="p">[</span><span class="n">invcov_samples</span> <span class="o">&gt;</span> <span class="n">xx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">mymodel</span><span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="n">myfitQU</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="n">effective_variance_invcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">invcov_samples</span><span class="p">,</span> <span class="n">eff_vI</span><span class="p">,</span> <span class="n">eff_vQU</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">doplot</span><span class="p">:</span>
        <span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;1./cov normed&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
            <span class="n">add_yl</span> <span class="o">=</span> <span class="s1">&#39; (Normalized to 1 at 1)&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">add_yl</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;RMS Ratio w.r.t linear scaling&#39;</span> <span class="o">+</span> <span class="n">add_yl</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xx</span><span class="p">,</span> <span class="n">myY</span><span class="p">,</span> <span class="n">effective_variance_invcov</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xx</span><span class="p">,</span> <span class="n">myY</span><span class="p">,</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">get_angular_profile</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">thmax</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">316.44761929</span><span class="p">,</span> <span class="o">-</span><span class="mf">58.75808063</span><span class="p">]),</span>
                        <span class="n">allstokes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">separate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">vec0</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ang2vec</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">lonlat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">maps</span><span class="p">)</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">npix2nside</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">vecpix</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">pix2vec</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="n">ns</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">angs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vec0</span><span class="p">,</span> <span class="n">vecpix</span><span class="p">)))</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">thmax</span><span class="p">])</span>
    <span class="n">xx</span><span class="p">,</span> <span class="n">yyI</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dyI</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ft</span><span class="o">.</span><span class="n">profile</span><span class="p">(</span><span class="n">angs</span><span class="p">,</span> <span class="n">maps</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">nbins</span><span class="o">=</span><span class="n">nbins</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
    <span class="n">xx</span><span class="p">,</span> <span class="n">yyQ</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dyQ</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ft</span><span class="o">.</span><span class="n">profile</span><span class="p">(</span><span class="n">angs</span><span class="p">,</span> <span class="n">maps</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">nbins</span><span class="o">=</span><span class="n">nbins</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
    <span class="n">xx</span><span class="p">,</span> <span class="n">yyU</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dyU</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ft</span><span class="o">.</span><span class="n">profile</span><span class="p">(</span><span class="n">angs</span><span class="p">,</span> <span class="n">maps</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">nbins</span><span class="o">=</span><span class="n">nbins</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rng</span><span class="o">=</span><span class="n">rng</span><span class="p">)</span>
    <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">dyI</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dyQ</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dyU</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">doplot</span><span class="p">:</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">avg</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">allstokes</span><span class="p">:</span>
            <span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">dyI</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span> <span class="o">+</span> <span class="s1">&#39; I&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
            <span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">dyQ</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span> <span class="o">+</span> <span class="s1">&#39; Q/sqrt(2)&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
            <span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">dyU</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span> <span class="o">+</span> <span class="s1">&#39; U/sqrt(2)&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
        <span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Angle [deg.]&#39;</span><span class="p">)</span>
        <span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;RMS&#39;</span><span class="p">)</span>
        <span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">separate</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xx</span><span class="p">,</span> <span class="n">dyI</span><span class="p">,</span> <span class="n">dyQ</span><span class="p">,</span> <span class="n">dyU</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xx</span><span class="p">,</span> <span class="n">avg</span>


<span class="k">def</span> <span class="nf">correct_maps_rms</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">effective_variance_invcov</span><span class="p">):</span>
    <span class="n">okpix</span> <span class="o">=</span> <span class="n">cov</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">newmaps</span> <span class="o">=</span> <span class="n">maps</span> <span class="o">*</span> <span class="mi">0</span>
    <span class="n">sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">effective_variance_invcov</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">correction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span> <span class="o">/</span> <span class="n">cov</span><span class="p">[</span><span class="n">okpix</span><span class="p">],</span> <span class="n">effective_variance_invcov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span>
                               <span class="n">effective_variance_invcov</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">newmaps</span><span class="p">[</span><span class="n">okpix</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">okpix</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">correction</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="n">okpix</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cov</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">correctionI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span> <span class="o">/</span> <span class="n">cov</span><span class="p">[</span><span class="n">okpix</span><span class="p">],</span> <span class="n">effective_variance_invcov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span>
                                <span class="n">effective_variance_invcov</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">correctionQU</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span> <span class="o">/</span> <span class="n">cov</span><span class="p">[</span><span class="n">okpix</span><span class="p">],</span> <span class="n">effective_variance_invcov</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span>
                                 <span class="n">effective_variance_invcov</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">newmaps</span><span class="p">[</span><span class="n">okpix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">okpix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">correctionI</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="n">okpix</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cov</span><span class="p">))</span>
        <span class="n">newmaps</span><span class="p">[</span><span class="n">okpix</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">okpix</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">correctionQU</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="n">okpix</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cov</span><span class="p">))</span>
        <span class="n">newmaps</span><span class="p">[</span><span class="n">okpix</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">maps</span><span class="p">[</span><span class="n">okpix</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">correctionQU</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="n">okpix</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cov</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">newmaps</span>


<span class="k">def</span> <span class="nf">flatten_noise</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">coverage</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">doplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">normalize_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">QUsep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">maps</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">maps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sh</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">out_maps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">maps</span><span class="p">)</span>
    <span class="n">newsh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">maps</span><span class="p">)</span>
    <span class="n">all_fitcov</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_norm_noise</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">doplot</span><span class="p">:</span>
        <span class="n">figure</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">isub</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">newsh</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">fitcov</span> <span class="o">=</span> <span class="n">get_noise_invcov_profile</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">coverage</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="n">nbins</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                  <span class="n">label</span><span class="o">=</span><span class="s1">&#39;sub-band: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">isub</span><span class="p">),</span> <span class="n">fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">doplot</span><span class="o">=</span><span class="n">doplot</span><span class="p">,</span> <span class="n">allstokes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">QUsep</span><span class="o">=</span><span class="n">QUsep</span><span class="p">)</span>
        <span class="n">all_norm_noise</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">yy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">doplot</span><span class="p">:</span>
            <span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">all_fitcov</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fitcov</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">normalize_all</span><span class="p">:</span>
            <span class="n">out_maps</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">correct_maps_rms</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">coverage</span><span class="p">,</span> <span class="n">fitcov</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_maps</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">correct_maps_rms</span><span class="p">(</span><span class="n">maps</span><span class="p">[</span><span class="n">isub</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">coverage</span><span class="p">,</span> <span class="n">all_fitcov</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_maps</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">all_fitcov</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out_maps</span><span class="p">,</span> <span class="n">all_fitcov</span><span class="p">,</span> <span class="n">all_norm_noise</span>


<span class="k">def</span> <span class="nf">map_corr_neighbtheta</span><span class="p">(</span><span class="n">themap_in</span><span class="p">,</span> <span class="n">ipok_in</span><span class="p">,</span> <span class="n">thetamin</span><span class="p">,</span> <span class="n">thetamax</span><span class="p">,</span> <span class="n">nbins</span><span class="p">,</span> <span class="n">degrade</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">degrade</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">themap</span> <span class="o">=</span> <span class="n">themap_in</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ipok</span> <span class="o">=</span> <span class="n">ipok_in</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">themap</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ud_grade</span><span class="p">(</span><span class="n">themap_in</span><span class="p">,</span> <span class="n">degrade</span><span class="p">)</span>
        <span class="n">mapbool</span> <span class="o">=</span> <span class="n">themap_in</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1e30</span>
        <span class="n">mapbool</span><span class="p">[</span><span class="n">ipok_in</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mapbool</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">ud_grade</span><span class="p">(</span><span class="n">mapbool</span><span class="p">,</span> <span class="n">degrade</span><span class="p">)</span>
        <span class="n">ip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="n">degrade</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">ipok</span> <span class="o">=</span> <span class="n">ip</span><span class="p">[</span><span class="n">mapbool</span><span class="p">]</span>
    <span class="n">rthmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">thetamin</span><span class="p">)</span>
    <span class="n">rthmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">thetamax</span><span class="p">)</span>
    <span class="n">thvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">rthmin</span><span class="p">,</span> <span class="n">rthmax</span><span class="p">,</span> <span class="n">nbins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">npix2nside</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">themap</span><span class="p">))</span>
    <span class="n">thesum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
    <span class="n">thesum2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
    <span class="n">thecount</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">progress_bar</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ipok</span><span class="p">),</span> <span class="s1">&#39;Pixels&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ipok</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="n">bar</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="n">valthis</span> <span class="o">=</span> <span class="n">themap</span><span class="p">[</span><span class="n">ipok</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">pix2vec</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">ipok</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># ipneighb_inner = []</span>
        <span class="n">ipneighb_inner</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">query_disc</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">thetamin</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbins</span><span class="p">):</span>
            <span class="n">thmin</span> <span class="o">=</span> <span class="n">thvals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">thmax</span> <span class="o">=</span> <span class="n">thvals</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">ipneighb_outer</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">query_disc</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">thmax</span><span class="p">))</span>
            <span class="n">ipneighb</span> <span class="o">=</span> <span class="n">ipneighb_outer</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">ipneighb_inner</span><span class="p">:</span> <span class="n">ipneighb</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="n">valneighb</span> <span class="o">=</span> <span class="n">themap</span><span class="p">[</span><span class="n">ipneighb</span><span class="p">]</span>
            <span class="n">thesum</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valthis</span> <span class="o">*</span> <span class="n">valneighb</span><span class="p">)</span>
            <span class="n">thesum2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">valthis</span> <span class="o">*</span> <span class="n">valneighb</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">thecount</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">valneighb</span><span class="p">)</span>
            <span class="n">ipneighb_inner</span> <span class="o">=</span> <span class="n">ipneighb_outer</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">mm</span> <span class="o">=</span> <span class="n">thesum</span> <span class="o">/</span> <span class="n">thecount</span>
    <span class="n">mm2</span> <span class="o">=</span> <span class="n">thesum2</span> <span class="o">/</span> <span class="n">thecount</span>
    <span class="n">errs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mm2</span> <span class="o">-</span> <span class="n">mm</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">thecount</span><span class="p">))</span>
    <span class="n">corrfct</span> <span class="o">=</span> <span class="n">thesum</span> <span class="o">/</span> <span class="n">thecount</span>
    <span class="n">mythetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">thvals</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">thvals</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">mythetas</span><span class="p">,</span> <span class="n">corrfct</span><span class="p">,</span> <span class="n">errs</span>


<span class="k">def</span> <span class="nf">get_angles</span><span class="p">(</span><span class="n">ip0</span><span class="p">,</span> <span class="n">ips</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">pix2vec</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">ip0</span><span class="p">))</span>
    <span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hp</span><span class="o">.</span><span class="n">pix2vec</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">ips</span><span class="p">))</span>
    <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">vecs</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">th</span>


<span class="k">def</span> <span class="nf">ctheta_parts</span><span class="p">(</span><span class="n">themap</span><span class="p">,</span> <span class="n">ipok</span><span class="p">,</span> <span class="n">thetamin</span><span class="p">,</span> <span class="n">thetamax</span><span class="p">,</span> <span class="n">nbinstot</span><span class="p">,</span> <span class="n">nsplit</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">degrade_init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">allthetalims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">thetamin</span><span class="p">,</span> <span class="n">thetamax</span><span class="p">,</span> <span class="n">nbinstot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">thmin</span> <span class="o">=</span> <span class="n">allthetalims</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">thmax</span> <span class="o">=</span> <span class="n">allthetalims</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nbinstot</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="n">nbinstot</span> <span class="o">//</span> <span class="n">nsplit</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">degrade_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nside_init</span> <span class="o">=</span> <span class="n">hp</span><span class="o">.</span><span class="n">npix2nside</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">themap</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nside_init</span> <span class="o">=</span> <span class="n">degrade_init</span>
    <span class="n">nside_part</span> <span class="o">=</span> <span class="n">nside_init</span> <span class="o">//</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">idx</span><span class="p">)</span>
    <span class="n">thall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbinstot</span><span class="p">)</span>
    <span class="n">cthall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbinstot</span><span class="p">)</span>
    <span class="n">errcthall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbinstot</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsplit</span><span class="p">):</span>
        <span class="n">thispart</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">k</span>
        <span class="n">mythmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">thmin</span><span class="p">[</span><span class="n">thispart</span><span class="p">])</span>
        <span class="n">mythmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">thmax</span><span class="p">[</span><span class="n">thispart</span><span class="p">])</span>
        <span class="n">mynbins</span> <span class="o">=</span> <span class="n">nbinstot</span> <span class="o">//</span> <span class="n">nsplit</span>
        <span class="n">mynside</span> <span class="o">=</span> <span class="n">nside_init</span> <span class="o">//</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span>
            <span class="s1">&#39;Doing </span><span class="si">{0:3.0f}</span><span class="s1"> bins between </span><span class="si">{1:5.2f}</span><span class="s1"> and </span><span class="si">{2:5.2f}</span><span class="s1"> deg at nside=</span><span class="si">{3:4.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mynbins</span><span class="p">,</span> <span class="n">mythmin</span><span class="p">,</span> <span class="n">mythmax</span><span class="p">,</span>
                                                                                             <span class="n">mynside</span><span class="p">))</span>
        <span class="n">myth</span><span class="p">,</span> <span class="n">mycth</span><span class="p">,</span> <span class="n">errs</span> <span class="o">=</span> <span class="n">map_corr_neighbtheta</span><span class="p">(</span><span class="n">themap</span><span class="p">,</span> <span class="n">ipok</span><span class="p">,</span> <span class="n">mythmin</span><span class="p">,</span> <span class="n">mythmax</span><span class="p">,</span> <span class="n">mynbins</span><span class="p">,</span> <span class="n">degrade</span><span class="o">=</span><span class="n">mynside</span><span class="p">,</span>
                                                 <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="n">cthall</span><span class="p">[</span><span class="n">thispart</span><span class="p">]</span> <span class="o">=</span> <span class="n">mycth</span>
        <span class="n">errcthall</span><span class="p">[</span><span class="n">thispart</span><span class="p">]</span> <span class="o">=</span> <span class="n">errs</span>
        <span class="n">thall</span><span class="p">[</span><span class="n">thispart</span><span class="p">]</span> <span class="o">=</span> <span class="n">myth</span>

        <span class="c1">### One could also calculate the average of the distribution of pixels within the ring instead of the simplistic thetas</span>
    <span class="n">dtheta</span> <span class="o">=</span> <span class="n">allthetalims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">allthetalims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">thall</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">((</span><span class="n">thmin</span> <span class="o">+</span> <span class="n">dtheta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">thmin</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">thmin</span> <span class="o">+</span> <span class="n">dtheta</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">thmin</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1">### But it actually changes very little</span>
    <span class="c1"># print(&#39;coucou&#39;)</span>
    <span class="k">return</span> <span class="n">thall</span><span class="p">,</span> <span class="n">cthall</span><span class="p">,</span> <span class="n">errcthall</span>


<span class="k">def</span> <span class="nf">get_cov_nunu</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">coverage</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">QUsep</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_flat_maps</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># This function returns the sub-frequency, sub_frequency covariance matrix for each stoke parameter</span>
    <span class="c1"># it does not attend to check for covariance between Stokes parameters (this should be incorporated later)</span>
    <span class="c1"># it returns the three covariance matrices as well as the fitted function of coverage that was used to</span>
    <span class="c1"># flatten the noise RMS in the maps before covariance calculation (this is for subsequent possible use)</span>
    <span class="c1"># NB: because this is done with  maps that are flattened, the RMS is put to 1 for I (and should be sqrt(2) for Q and U</span>
    <span class="c1"># so this covariance absorbes the  overall maps variances</span>

    <span class="c1">### First normalize by coverage</span>
    <span class="n">new_sub_maps</span><span class="p">,</span> <span class="n">all_fitcov</span><span class="p">,</span> <span class="n">all_norm_noise</span> <span class="o">=</span> <span class="n">flatten_noise</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">coverage</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="n">nbins</span><span class="p">,</span> <span class="n">doplot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">QUsep</span><span class="o">=</span><span class="n">QUsep</span><span class="p">)</span>

    <span class="c1">### Now calculate the covariance matrix for each sub map</span>
    <span class="n">sh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">maps</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">okpix</span> <span class="o">=</span> <span class="n">new_sub_maps</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="n">cov_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">new_sub_maps</span><span class="p">[</span><span class="n">okpix</span><span class="p">,</span> <span class="mi">0</span><span class="p">])]])</span>
        <span class="n">cov_Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">new_sub_maps</span><span class="p">[</span><span class="n">okpix</span><span class="p">,</span> <span class="mi">1</span><span class="p">])]])</span>
        <span class="n">cov_U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">new_sub_maps</span><span class="p">[</span><span class="n">okpix</span><span class="p">,</span> <span class="mi">2</span><span class="p">])]])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">okpix</span> <span class="o">=</span> <span class="n">new_sub_maps</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="n">cov_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">new_sub_maps</span><span class="p">[:,</span> <span class="n">okpix</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">cov_Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">new_sub_maps</span><span class="p">[:,</span> <span class="n">okpix</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">cov_U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">new_sub_maps</span><span class="p">[:,</span> <span class="n">okpix</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cov_I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cov_I</span><span class="p">]])</span>
            <span class="n">cov_Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cov_Q</span><span class="p">]])</span>
            <span class="n">cov_U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cov_U</span><span class="p">]])</span>

    <span class="k">if</span> <span class="n">return_flat_maps</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cov_I</span><span class="p">,</span> <span class="n">cov_Q</span><span class="p">,</span> <span class="n">cov_U</span><span class="p">,</span> <span class="n">all_fitcov</span><span class="p">,</span> <span class="n">all_norm_noise</span><span class="p">,</span> <span class="n">new_sub_maps</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cov_I</span><span class="p">,</span> <span class="n">cov_Q</span><span class="p">,</span> <span class="n">cov_U</span><span class="p">,</span> <span class="n">all_fitcov</span><span class="p">,</span> <span class="n">all_norm_noise</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, QUBIC collaboration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>