<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>lib.Instrument.Qinstrument module &#8212; qubicsoft  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-lib.Instrument.Qinstrument">
<span id="lib-instrument-qinstrument-module"></span><h1>lib.Instrument.Qinstrument module<a class="headerlink" href="#module-lib.Instrument.Qinstrument" title="Link to this heading">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Instrument.Qinstrument.</span></span><span class="sig-name descname"><span class="pre">QubicInstrument</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FRBW</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Instrument</span></code></p>
<p>The QubicInstrument class. It represents the instrument setup.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>comm</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_before_horns" title="lib.Instrument.Qinstrument.QubicInstrument.NEP_before_horns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NEP_before_horns</span></code></a>(noise, nu[, return_only, ...])</p></td>
<td><p>This method computes the noise for all the components before back-to-back array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_coldstop" title="lib.Instrument.Qinstrument.QubicInstrument.NEP_coldstop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NEP_coldstop</span></code></a>(noise[, return_only, sampling])</p></td>
<td><p>This method calculates the noise of the cold stop.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_combiner" title="lib.Instrument.Qinstrument.QubicInstrument.NEP_combiner"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NEP_combiner</span></code></a>(noise[, return_only, sampling])</p></td>
<td><p>This method calculates the noise of the optical combiner (consider 2 mirrors).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_dichroic" title="lib.Instrument.Qinstrument.QubicInstrument.NEP_dichroic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NEP_dichroic</span></code></a>(noise[, return_only, sampling])</p></td>
<td><p>This method calculates the noise of the dichroic.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_environment" title="lib.Instrument.Qinstrument.QubicInstrument.NEP_environment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NEP_environment</span></code></a>(noise, names[, return_only, ...])</p></td>
<td><p>This method calculates the environment noise.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_horns" title="lib.Instrument.Qinstrument.QubicInstrument.NEP_horns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NEP_horns</span></code></a>(noise[, return_only, sampling])</p></td>
<td><p>This method calculates the noise of the array of horns.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_lastfilter" title="lib.Instrument.Qinstrument.QubicInstrument.NEP_lastfilter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NEP_lastfilter</span></code></a>(noise[, return_only, sampling])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_lowpassedge" title="lib.Instrument.Qinstrument.QubicInstrument.NEP_lowpassedge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NEP_lowpassedge</span></code></a>(noise, i[, return_only, ...])</p></td>
<td><p>This method calculates the noise of the low pass edge filter.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_lpefilter_220" title="lib.Instrument.Qinstrument.QubicInstrument.NEP_lpefilter_220"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NEP_lpefilter_220</span></code></a>(noise, i[, return_only, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_neutraldensityfilter" title="lib.Instrument.Qinstrument.QubicInstrument.NEP_neutraldensityfilter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NEP_neutraldensityfilter</span></code></a>(noise[, ...])</p></td>
<td><p>This method calculates the noise of the neutral density filter for 150GHz band.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.get_aperture_integration_operator" title="lib.Instrument.Qinstrument.QubicInstrument.get_aperture_integration_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_aperture_integration_operator</span></code></a>()</p></td>
<td><p>Integrate flux density in the telescope aperture.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.get_convolution_peak_operator" title="lib.Instrument.Qinstrument.QubicInstrument.get_convolution_peak_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_convolution_peak_operator</span></code></a>(**keywords)</p></td>
<td><p>Return an operator that convolves the Healpix sky by the gaussian kernel that, if used in conjonction with the peak sampling operator, best approximates the synthetic beam.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.get_detector_integration_operator" title="lib.Instrument.Qinstrument.QubicInstrument.get_detector_integration_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_detector_integration_operator</span></code></a>()</p></td>
<td><p>Integrate flux density in detector solid angles and take into account the secondary beam transmission.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.get_detector_response_operator" title="lib.Instrument.Qinstrument.QubicInstrument.get_detector_response_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_detector_response_operator</span></code></a>(sampling[, tau])</p></td>
<td><p>Return the operator for the bolometer responses.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.get_filter_operator" title="lib.Instrument.Qinstrument.QubicInstrument.get_filter_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_filter_operator</span></code></a>()</p></td>
<td><p>Return the filter operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.get_hwp_operator" title="lib.Instrument.Qinstrument.QubicInstrument.get_hwp_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_hwp_operator</span></code></a>(sampling, scene)</p></td>
<td><p>Return the rotation matrix for the half-wave plate.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.get_invntt_operator" title="lib.Instrument.Qinstrument.QubicInstrument.get_invntt_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_invntt_operator</span></code></a>(sampling)</p></td>
<td><p>Return the inverse time-time noise correlation matrix as an Operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.get_noise" title="lib.Instrument.Qinstrument.QubicInstrument.get_noise"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_noise</span></code></a>(sampling, scene[, det_noise, ...])</p></td>
<td><p>Return a noisy timeline.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.get_noise_detector" title="lib.Instrument.Qinstrument.QubicInstrument.get_noise_detector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_noise_detector</span></code></a>(sampling[, out])</p></td>
<td><p>Return the detector noise (#det, #sampling).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.get_noise_photon" title="lib.Instrument.Qinstrument.QubicInstrument.get_noise_photon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_noise_photon</span></code></a>(sampling, scene[, out])</p></td>
<td><p>Return the photon noise (#det, #sampling).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_operator</span></code>(sampling, scene)</p></td>
<td><p>Return the acquisition model for the specified sampling and scene as an operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.get_polarizer_operator" title="lib.Instrument.Qinstrument.QubicInstrument.get_polarizer_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_polarizer_operator</span></code></a>(sampling, scene)</p></td>
<td><p>Return operator for the polarizer grid.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.get_projection_operator" title="lib.Instrument.Qinstrument.QubicInstrument.get_projection_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_projection_operator</span></code></a>(sampling, scene[, ...])</p></td>
<td><p>Return the peak sampling operator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.get_synthbeam" title="lib.Instrument.Qinstrument.QubicInstrument.get_synthbeam"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_synthbeam</span></code></a>(scene[, idet, theta_max, ...])</p></td>
<td><p>Return the detector synthetic beams, computed from the superposition of the electromagnetic fields.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.get_transmission_operator" title="lib.Instrument.Qinstrument.QubicInstrument.get_transmission_operator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_transmission_operator</span></code></a>()</p></td>
<td><p>Return the operator that multiplies by the cumulative instrumental transmission.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lib.Instrument.Qinstrument.QubicInstrument.load_NEP_parameters" title="lib.Instrument.Qinstrument.QubicInstrument.load_NEP_parameters"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_NEP_parameters</span></code></a>(scene)</p></td>
<td><p>This method loads the parameters for the photon noise (NEP) computation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">pack</span></code>(x)</p></td>
<td><p>Convert a multi-dimensional array into a 1-dimensional array which only includes the selected components, potentially ordered according to a given ordering.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code>(**keywords)</p></td>
<td><p>Plot the instrument detector footprint.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scatter</span></code>([comm])</p></td>
<td><p>MPI-scatter of the instrument.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code>(n)</p></td>
<td><p>Split the instrument in partitioning groups.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">unpack</span></code>(x)</p></td>
<td><p>Convert a 1-dimensional array into a multi-dimensional array which includes the non-selected components, mimicking the multi-dimensional layout.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>detector_subset</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>remove_significant_peaks</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>synthbeam_file</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.NEP_before_horns">
<span class="sig-name descname"><span class="pre">NEP_before_horns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_before_horns" title="Link to this definition">¶</a></dt>
<dd><p>This method computes the noise for all the components before
back-to-back array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noise</strong> – parameters for the computation of the noise. It is loaded from
load_NEP_parameters method</p></li>
<li><p><strong>nu</strong> – frequency</p></li>
<li><p><strong>return_only</strong> – if True, the method returns a dictionary with the components of the noise
sampled using sampling in Instrument.get_noise() method from pysimulators
if False, the method just load the components of the photon noise in the noise argument</p></li>
<li><p><strong>sampling</strong> – qubic.get_sampling(dict) object</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>“power” –&gt; photon power
“NEP_phot_nobunch”
“NEP_phot2” –&gt; NEP squared. shape = (#det,)
“NEP_array” –&gt; NEP array sampled. shape = (#det,#samples)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>if return_only –&gt; dictionary with the following keys</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.NEP_coldstop">
<span class="sig-name descname"><span class="pre">NEP_coldstop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_coldstop" title="Link to this definition">¶</a></dt>
<dd><p>This method calculates the noise of the cold stop.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noise</strong> – parameters for the computation of the noise. It is loaded from
load_NEP_parameters method</p></li>
<li><p><strong>return_only</strong> – if True, the method returns a dictionary with the components of the noise
sampled using sampling in Instrument.get_noise() method from pysimulators
if False, the method just load the components of the photon noise in the noise argument</p></li>
<li><p><strong>sampling</strong> – qubic.get_sampling(dict) object</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>“power” –&gt; photon power
“NEP_phot2” –&gt; NEP squared. shape = (#det,)
“NEP_array” –&gt; NEP array sampled. shape = (#det,#samples)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>if return_only –&gt; dictionary with the following keys</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.NEP_combiner">
<span class="sig-name descname"><span class="pre">NEP_combiner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_combiner" title="Link to this definition">¶</a></dt>
<dd><p>This method calculates the noise of the optical combiner (consider 2 mirrors).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noise</strong> – parameters for the computation of the noise. It is loaded from
load_NEP_parameters method</p></li>
<li><p><strong>return_only</strong> – if True, the method returns a dictionary with the components of the noise
sampled using sampling in Instrument.get_noise() method from pysimulators
if False, the method just load the components of the photon noise in the noise argument</p></li>
<li><p><strong>sampling</strong> – qubic.get_sampling(dict) object</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>“power” –&gt; photon power
“NEP_phot2” –&gt; NEP squared. shape = (#det,)
“NEP_array” –&gt; NEP array sampled. shape = (#det,#samples)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>if return_only –&gt; dictionary with the following keys</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.NEP_dichroic">
<span class="sig-name descname"><span class="pre">NEP_dichroic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_dichroic" title="Link to this definition">¶</a></dt>
<dd><p>This method calculates the noise of the dichroic. It’s only accounted for the FI configuration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noise</strong> – parameters for the computation of the noise. It is loaded from
load_NEP_parameters method</p></li>
<li><p><strong>return_only</strong> – if True, the method returns a dictionary with the components of the noise
sampled using sampling in Instrument.get_noise() method from pysimulators
if False, the method just load the components of the photon noise in the noise argument</p></li>
<li><p><strong>sampling</strong> – qubic.get_sampling(dict) object</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>“power” –&gt; photon power
“NEP_phot2” –&gt; NEP squared. shape = (#det,)
“NEP_array” –&gt; NEP array sampled. shape = (#det,#samples)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>if return_only –&gt; dictionary with the following keys</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.NEP_environment">
<span class="sig-name descname"><span class="pre">NEP_environment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_environment" title="Link to this definition">¶</a></dt>
<dd><p>This method calculates the environment noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noise</strong> – parameters for the computation of the noise. It is loaded from
load_NEP_parameters method</p></li>
<li><p><strong>names</strong> – (noise.names attribute)
names of the components considered in the instrument model for the noise.</p></li>
<li><p><strong>return_only</strong> – if True, the method returns a dictionary with the components of the noise
sampled using sampling in Instrument.get_noise() method from pysimulators
if False, the method just load the components of the photon noise in the noise argument</p></li>
<li><p><strong>sampling</strong> – qubic.get_sampling(dict) object</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>“power” –&gt; photon power
“NEP_phot2_env” –&gt; NEP squared. shape = (#det,)
“NEP_array” –&gt; NEP array sampled. shape = (#det,#samples)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>if return_only –&gt; dictionary with the following keys</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.NEP_horns">
<span class="sig-name descname"><span class="pre">NEP_horns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_horns" title="Link to this definition">¶</a></dt>
<dd><p>This method calculates the noise of the array of horns.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noise</strong> – parameters for the computation of the noise. It is loaded from
load_NEP_parameters method</p></li>
<li><p><strong>return_only</strong> – if True, the method returns a dictionary with the components of the noise
sampled using sampling in Instrument.get_noise() method from pysimulators
if False, the method just load the components of the photon noise in the noise argument</p></li>
<li><p><strong>sampling</strong> – qubic.get_sampling(dict) object</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>“power” –&gt; photon power
“NEP_phot2” –&gt; NEP squared. shape = (#det,)
“NEP_array” –&gt; NEP array sampled. shape = (#det,#samples)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>if return_only –&gt; dictionary with the following keys</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.NEP_lastfilter">
<span class="sig-name descname"><span class="pre">NEP_lastfilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_lastfilter" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noise</strong> – parameters for the computation of the noise. It is loaded from
load_NEP_parameters method</p></li>
<li><p><strong>return_only</strong> – if True, the method returns a dictionary with the components of the noise
sampled using sampling in Instrument.get_noise() method from pysimulators
if False, the method just load the components of the photon noise in the noise argument</p></li>
<li><p><strong>sampling</strong> – qubic.get_sampling(dict) object</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>“power” –&gt; photon power
“NEP_phot2” –&gt; NEP squared. shape = (#det,)
“NEP_array” –&gt; NEP array sampled. shape = (#det,#samples)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>if return_only –&gt; dictionary with the following keys</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.NEP_lowpassedge">
<span class="sig-name descname"><span class="pre">NEP_lowpassedge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_lowpassedge" title="Link to this definition">¶</a></dt>
<dd><p>This method calculates the noise of the low pass edge filter.
In the case of the 220GHz the ndf is considered in an independent method called NEP_lastfilters_220.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noise</strong> – parameters for the computation of the noise. It is loaded from
load_NEP_parameters method</p></li>
<li><p><strong>i</strong> – index for the low pass edge filters (lpe1 or lpe2 attr of noise)</p></li>
<li><p><strong>return_only</strong> – if True, the method returns a dictionary with the components of the noise
sampled using sampling in Instrument.get_noise() method from pysimulators
if False, the method just load the components of the photon noise in the noise argument</p></li>
<li><p><strong>sampling</strong> – qubic.get_sampling(dict) object</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>“power” –&gt; photon power
“NEP_phot2” –&gt; NEP squared. shape = (#det,)
“NEP_array” –&gt; NEP array sampled. shape = (#det,#samples)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>if return_only –&gt; dictionary with the following keys</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.NEP_lpefilter_220">
<span class="sig-name descname"><span class="pre">NEP_lpefilter_220</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_lpefilter_220" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noise</strong> – parameters for the computation of the noise. It is loaded from
load_NEP_parameters method</p></li>
<li><p><strong>i</strong> – noise component index</p></li>
<li><p><strong>return_only</strong> – if True, the method returns a dictionary with the components of the noise
sampled using sampling in Instrument.get_noise() method from pysimulators
if False, the method just load the components of the photon noise in the noise argument</p></li>
<li><p><strong>sampling</strong> – qubic.get_sampling(dict) object</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>“power” –&gt; photon power
“NEP_phot2” –&gt; NEP squared. shape = (#det,)
“NEP_array” –&gt; NEP array sampled. shape = (#det,#samples)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>if return_only –&gt; dictionary with the following keys</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.NEP_neutraldensityfilter">
<span class="sig-name descname"><span class="pre">NEP_neutraldensityfilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">noise</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sampling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.NEP_neutraldensityfilter" title="Link to this definition">¶</a></dt>
<dd><p>This method calculates the noise of the neutral density filter for 150GHz band.
In the case of the 220GHz the ndf is considered in an independent method called NEP_lastfilters_220.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>noise</strong> – parameters for the computation of the noise. It is loaded from
load_NEP_parameters method</p></li>
<li><p><strong>return_only</strong> – if True, the method returns a dictionary with the components of the noise
sampled using sampling in Instrument.get_noise() method from pysimulators
if False, the method just load the components of the photon noise in the noise argument</p></li>
<li><p><strong>sampling</strong> – qubic.get_sampling(dict) object</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>“power” –&gt; photon power
“NEP_phot2” –&gt; NEP squared. shape = (#det,)
“NEP_array” –&gt; NEP array sampled. shape = (#det,#samples)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>if return_only –&gt; dictionary with the following keys</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.detector_subset">
<span class="sig-name descname"><span class="pre">detector_subset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dets</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.detector_subset" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.get_aperture_integration_operator">
<span class="sig-name descname"><span class="pre">get_aperture_integration_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.get_aperture_integration_operator" title="Link to this definition">¶</a></dt>
<dd><p>Integrate flux density in the telescope aperture.
Convert signal from W / m^2 / Hz into W / Hz.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.get_convolution_peak_operator">
<span class="sig-name descname"><span class="pre">get_convolution_peak_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">keywords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.get_convolution_peak_operator" title="Link to this definition">¶</a></dt>
<dd><p>Return an operator that convolves the Healpix sky by the gaussian
kernel that, if used in conjonction with the peak sampling operator,
best approximates the synthetic beam.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.get_detector_integration_operator">
<span class="sig-name descname"><span class="pre">get_detector_integration_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.get_detector_integration_operator" title="Link to this definition">¶</a></dt>
<dd><p>Integrate flux density in detector solid angles and take into account
the secondary beam transmission.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.get_detector_response_operator">
<span class="sig-name descname"><span class="pre">get_detector_response_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.get_detector_response_operator" title="Link to this definition">¶</a></dt>
<dd><p>Return the operator for the bolometer responses.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.get_filter_operator">
<span class="sig-name descname"><span class="pre">get_filter_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.get_filter_operator" title="Link to this definition">¶</a></dt>
<dd><p>Return the filter operator.
Convert units from W/Hz to W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.get_hwp_operator">
<span class="sig-name descname"><span class="pre">get_hwp_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.get_hwp_operator" title="Link to this definition">¶</a></dt>
<dd><p>Return the rotation matrix for the half-wave plate.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.get_invntt_operator">
<span class="sig-name descname"><span class="pre">get_invntt_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.get_invntt_operator" title="Link to this definition">¶</a></dt>
<dd><p>Return the inverse time-time noise correlation matrix as an Operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.get_noise">
<span class="sig-name descname"><span class="pre">get_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">det_noise=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">photon_noise=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operation=&lt;function</span> <span class="pre">operation_assignment&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.get_noise" title="Link to this definition">¶</a></dt>
<dd><p>Return a noisy timeline.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.get_noise_detector">
<span class="sig-name descname"><span class="pre">get_noise_detector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.get_noise_detector" title="Link to this definition">¶</a></dt>
<dd><p>Return the detector noise (#det, #sampling).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.get_noise_photon">
<span class="sig-name descname"><span class="pre">get_noise_photon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.get_noise_photon" title="Link to this definition">¶</a></dt>
<dd><p>Return the photon noise (#det, #sampling).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.get_polarizer_operator">
<span class="sig-name descname"><span class="pre">get_polarizer_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.get_polarizer_operator" title="Link to this definition">¶</a></dt>
<dd><p>Return operator for the polarizer grid.
When the polarizer is not present a transmission of 1 is assumed
for the detectors on the first focal plane and of 0 for the other.
Otherwise, the signal is split onto the focal planes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.get_projection_operator">
<span class="sig-name descname"><span class="pre">get_projection_operator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sampling</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scene</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.get_projection_operator" title="Link to this definition">¶</a></dt>
<dd><p>Return the peak sampling operator.
Convert units from W to W/sr.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sampling</strong> (<a class="reference internal" href="lib.Qsamplings.html#lib.Qsamplings.QubicSampling" title="lib.Qsamplings.QubicSampling"><em>QubicSampling</em></a>) – The pointing information.</p></li>
<li><p><strong>scene</strong> (<a class="reference internal" href="lib.Qscene.html#lib.Qscene.QubicScene" title="lib.Qscene.QubicScene"><em>QubicScene</em></a>) – The observed scene.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, display information about the memory allocation.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.get_synthbeam">
<span class="sig-name descname"><span class="pre">get_synthbeam</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scene</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">45</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_A</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hwp_position</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector_integrate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detpos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.get_synthbeam" title="Link to this definition">¶</a></dt>
<dd><p>Return the detector synthetic beams, computed from the superposition
of the electromagnetic fields.</p>
<p>The synthetic beam B_d = (B_d,i) of a given detector d is such that
the power I_d in [W] collected by this detector observing a sky S=(S_i)
in [W/m^2/Hz] is:</p>
<blockquote>
<div><p>I_d = (S | B_d) = sum_i S_i * B_d,i.</p>
</div></blockquote>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scene</span> <span class="o">=</span> <span class="n">QubicScene</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inst</span> <span class="o">=</span> <span class="n">QubicInstrument</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sb</span> <span class="o">=</span> <span class="n">inst</span><span class="o">.</span><span class="n">get_synthbeam</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>The power collected by the bolometers in W, given a sky in W/m²/Hz is:
&gt;&gt;&gt; sb = inst.get_synthbeam(scene)
&gt;&gt;&gt; sky = scene.ones()   # [W/m²/Hz]
&gt;&gt;&gt; P = np.dot(sb, sky)  # [W]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scene</strong> (<a class="reference internal" href="lib.Qscene.html#lib.Qscene.QubicScene" title="lib.Qscene.QubicScene"><em>QubicScene</em></a>) – The scene.</p></li>
<li><p><strong>idet</strong> (<em>int</em><em>, </em><em>optional</em>) – The detector number. By default, the synthetic beam is computed for
all detectors.</p></li>
<li><p><strong>theta_max</strong> (<em>float</em><em>, </em><em>optional</em>) – The maximum zenithal angle above which the synthetic beam is
assumed to be zero, in degrees.</p></li>
<li><p><strong>external_A</strong> (<em>list</em><em> of </em><em>tables describing the phase and amplitude at each point</em><em> of </em><em>the focal</em>) – plane for each of the horns:
[0] : array, X coordinates with shape (n) in GRF [m]
[1] : array, Y coordinates with shape (n) in GRF [m]
[2] : array, amplitude on X with shape (n, nhorns)
[3] : array, amplitude on Y with shape (n, nhorns)
[4] : array, phase on X with shape (n, nhorns) [rad]
[5] : array, phase on Y with shape (n, nhorns) [rad]</p></li>
<li><p><strong>hwp_position</strong> (<em>int</em>) – HWP position from 0 to 7.</p></li>
<li><p><strong>detector_integrate</strong> (<em>Optional</em><em>, </em><em>number</em><em> of </em><em>subpixels in x direction for integration over detectors</em>) – default (None) is no integration =&gt; uses the center of the pixel</p></li>
<li><p><strong>detpos</strong> (<em>Optional</em><em>, </em><em>position in the focal plane at which the Synthesized Beam is desired as np.array</em><em>(</em><em>[</em><em>x</em><em>,</em><em>y</em><em>,</em><em>z</em><em>]</em><em>)</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.get_transmission_operator">
<span class="sig-name descname"><span class="pre">get_transmission_operator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.get_transmission_operator" title="Link to this definition">¶</a></dt>
<dd><p>Return the operator that multiplies by the cumulative instrumental
transmission.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.load_NEP_parameters">
<span class="sig-name descname"><span class="pre">load_NEP_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scene</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.load_NEP_parameters" title="Link to this definition">¶</a></dt>
<dd><p>This method loads the parameters for the photon noise (NEP) computation.
The attributes are loaded into a Noise() class. The attributes are:</p>
<p>temperatures, transmissions, emissivities, gp (polarization) of each component of the instrument,
names: name of each component,
tr_prod: cumulative multiplication of the transmissions of each components,
dnu: bandwidth,
S_det: detector area,
omega_det: solid angle sustained by a given detector on the sky,
S_horns: physical horn area,
S_horns_eff: effective horn area,
sec_beam: secondary beam QubicInstrument.secondary_beam,</p>
<p>P_phot, NEP_phot: empty arrays to be loaded by NEP-like methods (below),
indexes for each component,</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.remove_significant_peaks">
<span class="sig-name descname"><span class="pre">remove_significant_peaks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synthbeam</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.remove_significant_peaks" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicInstrument.synthbeam_file">
<span class="sig-name descname"><span class="pre">synthbeam_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicInstrument.synthbeam_file" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicMultibandInstrument">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Instrument.Qinstrument.</span></span><span class="sig-name descname"><span class="pre">QubicMultibandInstrument</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicMultibandInstrument" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The QubicMultibandInstrument class
Represents the QUBIC multiband features
as an array of QubicInstrumet objects</p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>detector_subset</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>direct_convolution</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>get_synthbeam</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicMultibandInstrument.detector_subset">
<span class="sig-name descname"><span class="pre">detector_subset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dets</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicMultibandInstrument.detector_subset" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicMultibandInstrument.direct_convolution">
<span class="sig-name descname"><span class="pre">direct_convolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scene</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicMultibandInstrument.direct_convolution" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicMultibandInstrument.get_synthbeam">
<span class="sig-name descname"><span class="pre">get_synthbeam</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scene</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">45</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector_integrate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detpos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicMultibandInstrument.get_synthbeam" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicMultibandInstrumentTrapezoidalIntegration">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">lib.Instrument.Qinstrument.</span></span><span class="sig-name descname"><span class="pre">QubicMultibandInstrumentTrapezoidalIntegration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicMultibandInstrumentTrapezoidalIntegration" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The QubicMultibandInstrument class
Represents the QUBIC multiband features
as an array of QubicInstrumet objects</p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>detector_subset</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>direct_convolution</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>get_synthbeam</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicMultibandInstrumentTrapezoidalIntegration.detector_subset">
<span class="sig-name descname"><span class="pre">detector_subset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dets</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicMultibandInstrumentTrapezoidalIntegration.detector_subset" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicMultibandInstrumentTrapezoidalIntegration.direct_convolution">
<span class="sig-name descname"><span class="pre">direct_convolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scene</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicMultibandInstrumentTrapezoidalIntegration.direct_convolution" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="lib.Instrument.Qinstrument.QubicMultibandInstrumentTrapezoidalIntegration.get_synthbeam">
<span class="sig-name descname"><span class="pre">get_synthbeam</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scene</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">45</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector_integrate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detpos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#lib.Instrument.Qinstrument.QubicMultibandInstrumentTrapezoidalIntegration.get_synthbeam" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">qubicsoft</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, QUBIC Collaboration.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/lib.Instrument.Qinstrument.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>