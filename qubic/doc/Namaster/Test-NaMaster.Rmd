---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Notebook to test Namaster tools to get spectra

Editting by Jean-Christophe and Louise

March 2020

```{python}
# %matplotlib inline
import numpy as np
import healpy as hp
import matplotlib.pyplot as plt

# Import the NaMaster python wrapper
import pymaster as nmt

# Specific qubic modules
from qubicpack.utilities import Qubic_DataDir
from pysimulators import FitsArray
import qubic
from qubic import QubicSkySim as qss

rc('figure', figsize=(16, 10))
rc('font', size=15)
```

```{python}
#### Create sample CMB I,Q,U maps
global_dir = Qubic_DataDir(datafile='instrument.py', datadir=os.environ['QUBIC_DATADIR'])

# dictfilename = global_dir + '/dicts/BmodesNoDustNoSystPaper0_2020.dict'
dictfilename = global_dir + '/dicts/test_QubicSkySim.dict'

# Read dictionary chosen
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictfilename)
d['nside']=256
center = qubic.equ2gal(d['RA_center'], d['DEC_center'])
print(center)
```

```{python}
# Make a sky using PYSM
seed = None
sky_config = {'cmb': seed}
Qubic_sky = qss.Qubic_sky(sky_config, d)
x0 = np.reshape(Qubic_sky.get_simple_sky_map(),(d['nf_sub'],d['nside']**2*12,3))

print('Input Map with shape (nf_sub, #pixels, #stokes) : ', np.shape(x0))
rc('figure', figsize=(16, 10))
figure()
stn = ['I','Q','U']
rng = (np.std(x0, axis=(0,1))*3).astype(int)
rng[1:] = np.max(rng[1:])
numsub = 4
for i in range(d['nf_sub']):
    for istokes in [0,1,2]:
        hp.mollview(x0[i,:,istokes], min=-rng[istokes], max=rng[istokes],
                    sub=(d['nf_sub']+1,3,numsub), title=stn[istokes]+' subfreq {}'.format(i))
        numsub += 1
```

```{python}
# Remember that we can always retrieve the input CMB maps and spectra
### Input Maps
input_maps = Qubic_sky.input_cmb_maps
rng = (np.std(input_maps, axis=(1))*3).astype(int)
rng[1:] = np.max(rng[1:])
figure()
hp.mollview(input_maps[0,:], title="I input map used", min=-rng[0], max=rng[0], sub=(1,3,1))
hp.mollview(input_maps[1,:], title="Q input map used", min=-rng[1], max=rng[1], sub=(1,3,2))
hp.mollview(input_maps[2,:], title="U input map used", min=-rng[2], max=rng[2], sub=(1,3,3))

### Input Cls
input_cl = Qubic_sky.input_cmb_spectra
if input_cl is not None:
    input_ell = np.arange(np.shape(input_cl)[0])
    figure()
    order = ['TT', 'EE', 'BB', 'TE']
    for i in range(4):
        subplot(2,2,i+1)
        plot(input_ell,input_cl[:,i], color='k')
        title(order[i])
        xlabel('$\\ell$')
        ylabel('$D_\\ell$')
    tight_layout()
```

```{python}
#### Read a sample QUBIC coverage map (made in the RandomPointing approximmation)
cov = hp.ud_grade(hp.read_map('sample_coverage_qubic.fits', verbose=False), d['nside'])
cov /= np.max(cov)
hp.mollview(cov)
```

```{python}
#### Now mask these maps using QUBIC mask and add noise according to QUBIC coverage
seenpix = cov > 0.5#(np.max(cov)/1000)
maps_observed = np.zeros_like(x0)

# Noise
noise_level = 0.0
fact_noise = [1., sqrt(2), sqrt(2)]

### For Now Uniform noise
for i in range(3):
    maps_observed[:,seenpix,i] = x0[:,seenpix,i] #+ np.random.randn(seenpix.sum()) * noise_level * fact_noise[i] 

figure() 
numsub = 1
for i in range(d['nf_sub']):
    for istokes in [0,1,2]:
        hp.mollview(maps_observed[i,:,istokes], min=-rng[istokes], max=rng[istokes],
                    sub=(d['nf_sub']+1,3,numsub), title=stn[istokes]+' subfreq {}'.format(i))
        numsub += 1

figure() 
numsub = 1
for i in range(d['nf_sub']):
    for istokes in [0,1,2]:
        hp.gnomview(maps_observed[i,:,istokes], min=-rng[istokes], max=rng[istokes],
                    rot=center, reso=15,
                    sub=(d['nf_sub']+1,3,numsub), title=stn[istokes]+' subfreq {}'.format(i))
        numsub += 1

```

```{python}
seenpix
```

```{python}
### NaMaster
# Create the mask
msk = np.zeros(12*d['nside']**2)
msk[seenpix]=1

# Now we apodize the mask. The pure-B formalism requires the mask to be
# differentiable along the edges. The 'C1' and 'C2' apodization types
# supported by mask_apodization achieve this.
msk_apo = nmt.mask_apodization(msk, 10.0, apotype='C1')

res=15
hp.mollview(msk, rot=center, sub=(2,2,1))
hp.mollview(msk_apo, rot=center, sub=(2,2,2))
hp.gnomview(msk, rot=center, reso=res, sub=(2,2,3))
hp.gnomview(msk_apo, rot=center, reso=res, sub=(2,2,4))
```

```{python}
# Select a binning scheme
##b = nmt.NmtBin.from_nside_linear(nside, 16)
b = nmt.NmtBin(d['nside'], nlb=16, is_Dell=True)

leff = b.get_effective_ells()

def get_fields(mp_t, mp_q, mp_u, msk_apo, purify_e=True, purify_b=True):
    # This creates a spin-0 field 
    f0 = nmt.NmtField(msk_apo, [mp_t, mp_t])
    # This creates a spin-2 field with both pure E and B.
    f2 = nmt.NmtField(msk_apo, [mp_q, mp_u], purify_e=purify_e, purify_b=purify_b)
    # Note that generally it's not a good idea to purify both,
    # since you'll lose sensitivity on E
    return f0, f2

def get_spectra(I,Q,U,mask,purify_e=True, purify_b=True, workspace=None):
    f0, f2 = get_fields(I, Q, U, mask, purify_e=purify_e, purify_b=purify_b)
    if workspace is None:
        w0 = nmt.NmtWorkspace()
        w0.compute_coupling_matrix(f0, f0, b)
        w2 = nmt.NmtWorkspace()
        w2.compute_coupling_matrix(f2, f2, b)
        w = [w0, w2]
    else:
        w = workspace
    # Spin 0
    c00coupled = nmt.compute_coupled_cell(f0, f0)
    c00 = w[0].decouple_cell(c00coupled)
    # Spin 2
    c22coupled = nmt.compute_coupled_cell(f2, f2)
    c22 = w[1].decouple_cell(c22coupled)
    # spectra
    spectra = np.array([c00[0], c22[0], c22[3]])
    return spectra, w

def plot_cells(ell, cells, color=None, label=None):
    cell_names = ['TT', 'EE', 'BB']
    for i in range(3):
        subplot(2,2,i+1)
        plot(ell, cells[i], color=color, label=label)
        xlabel('$\\ell$', fontsize=18)
        ylabel('$D_\\ell$', fontsize=18)
        if label is not None: legend(loc='upper right', frameon=False)
        title(cell_names[i])
    tight_layout()


cells, w = get_spectra(maps_observed[0,:,0], maps_observed[0,:,1], maps_observed[0,:,2], msk_apo,
                       purify_e=True, purify_b=True)
cellsnp, wnp = get_spectra(maps_observed[0,:,0], maps_observed[0,:,1], maps_observed[0,:,2], msk_apo,
                           purify_e=False, purify_b=False)


```

```{python}
pixwin = np.interp(leff, np.arange(3*d['nside']),hp.pixwin(d['nside']))
clth = Qubic_sky.input_cmb_spectra
ellth = np.arange(np.shape(input_cl)[0])
clnames = ['TT','EE','BB']
for i in range(3):
    subplot(2,3,i+1)
    plot(ellth, clth[:,i])
    plot(leff, cells[i,:],'o',label='Pure')
    plot(leff, cellsnp[i,:],'o', label='Not Pure')
    xlabel('$\\ell$')
    ylabel('$D_\\ell$')
    title(clnames[i])
    legend()
tight_layout()
```

## Testing the library NamasterLib

```{python}
from qubic import NamasterLib as nam
```

```{python}
# Create a Namaster object
lmin = 20
lmax = 3 * d['nside'] - 1
delta_ell = 10

Namaster = nam.Namaster(seenpix, lmin=lmin, lmax=lmax, delta_ell=delta_ell)
```

### Test the function that binned a spectra between lmin and lmax

```{python}
cl_binned = Namaster.bin_spectra(input_cl[:, 0])
print(input_cl.shape, cl_binned.shape)

ell_binned = Namaster.ell_binned

plot(ellth, input_cl[:, 0])
plot(ell_binned, cl_binned,'o')
xlabel('$\\ell$')
ylabel('$D_\\ell$')
```

### Get spectra from IQU maps

```{python}
# Make a mask
mask_apo = Namaster.get_apodized_mask()

res=15
hp.mollview(mask_apo, rot=center)
```

```{python}
# Make an 2D array containing IQU maps
maps = np.array((maps_observed[0, :, 0], maps_observed[0, :, 1], maps_observed[0, :, 2]))
print('maps shape:', maps.shape)

# Get spectra
leff, cells, w = Namaster.get_spectra(maps, d, mask_apo, multipoles_per_bin=16, purify_e=False, purify_b=False)
```

```{python}
print(leff)
```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']

for i in range(4):
    subplot(2, 2, i+1)
    plot(input_ell, input_cl[:, i])
    plot(leff, cells[:, i],'o')
    xlabel('$\\ell$')
    ylabel('$D_\\ell$')
    title(clnames[i])
tight_layout()
```

## Test bug JC
This section will be removed later (Louise debugging).

```{python}
d['nf_sub'] = 1
lmax = 2 * d['nside']

# Create a sky with qss
seed = None
sky_config = {'cmb': seed}
Qubic_sky = qss.Qubic_sky(sky_config, d)
x0 = Qubic_sky.get_simple_sky_map()
print('x0 Shape:', x0.shape)

# Input map used by qss
inmap = Qubic_sky.input_cmb_maps
print('input Shape:', inmap.shape)

# Anafast spectrum from input map
clsin = hp.anafast(inmap, lmax=lmax)
ll = np.arange(0, lmax+1)
print('ll shape', ll.shape)
# print(ll)
Dlsin = ll * (ll + 1) * clsin / (2 * np.pi)
print('Dlsin', Dlsin.shape)

# Spectra used in qss to create the x0 map
Dlth = Qubic_sky.input_cmb_spectra
print('Dlth', Dlth.shape)
llth = np.arange(len(Dlth[:, 0]))
print('llth shape', llth.shape)
# print(llth)

# Spectra with Anafast from x0 map
Dls = []
for i in range(d['nf_sub']):
    Cls = hp.anafast(x0[i, :, :].T, lmax=lmax)
    Dls.append(ll * (ll + 1) * Cls / (2 * np.pi))
Dls = np.array(Dls)
print('Dls', Dls.shape)
   
    
order = ['TT', 'EE', 'BB', 'TE']
for i in range(4):
    subplot(2, 2, i+1)
    title(order[i])
    xlim(0, lmax)
    plot(llth, Dlth[:, i], 'k', label='Dl Th')
    plot(ll, Dlsin[i, :], alpha=0.3, label='Dl from Input')
    for k in range(d['nf_sub']):
        plot(ll, Dls[k, i, :], alpha=0.3, label='Dl from x0 band {}'.format(k))
legend()
```

```{python}
inmap.shape
```

```{python}

```
