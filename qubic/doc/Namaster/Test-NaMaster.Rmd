---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
# %matplotlib inline
import numpy as np
import healpy as hp
import matplotlib.pyplot as plt

# Import the NaMaster python wrapper
import pymaster as nmt

# Specific qubic modules
from qubicpack.utilities import Qubic_DataDir
from pysimulators import FitsArray
import qubic
from qubic import QubicSkySim as qss

rc('figure', figsize=(16, 10))
rc('font', size=15)
```

```{python}
#### Create sample CMB I,Q,U maps
global_dir = Qubic_DataDir(datafile='instrument.py', datadir=os.environ['QUBIC_DATADIR'])
dictfilename = global_dir + '/dicts/BmodesNoDustNoSystPaper0_2020.dict'

# Read dictionary chosen
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictfilename)
d['nside']=256
center = qubic.equ2gal(d['RA_center'], d['DEC_center'])
print(center)
```

```{python}
# Make a sky using PYSM
seed = 0
sky_config = {'cmb': seed}
Qubic_sky = qss.Qubic_sky(sky_config, d)
x0 = np.reshape(Qubic_sky.get_simple_sky_map(),(d['nf_sub'],d['nside']**2*12,3))

print('Input Map with shape (nf_sub, #pixels, #stokes) : ', np.shape(x0))
rc('figure', figsize=(16, 10))
figure()
stn = ['I','Q','U']
rng = (np.std(x0, axis=(0,1))*3).astype(int)
rng[1:] = np.max(rng[1:])
numsub = 4
for i in range(d['nf_sub']):
    for istokes in [0,1,2]:
        hp.mollview(x0[i,:,istokes], min=-rng[istokes], max=rng[istokes],
                    sub=(d['nf_sub']+1,3,numsub), title=stn[istokes]+' subfreq {}'.format(i))
        numsub += 1
```

```{python}
# Remember that we can always retrieve the input CMB maps and spectra
### Input Maps
input_maps = Qubic_sky.input_cmb_maps
rng = (np.std(input_maps, axis=(1))*3).astype(int)
rng[1:] = np.max(rng[1:])
figure()
hp.mollview(input_maps[0,:], title="I input map used", min=-rng[0], max=rng[0], sub=(1,3,1))
hp.mollview(input_maps[1,:], title="Q input map used", min=-rng[1], max=rng[1], sub=(1,3,2))
hp.mollview(input_maps[2,:], title="U input map used", min=-rng[2], max=rng[2], sub=(1,3,3))

### Input Cls
input_cl = Qubic_sky.input_cmb_spectra
if input_cl is not None:
    input_ell = np.arange(np.shape(input_cl)[0])
    figure()
    order = ['TT', 'EE', 'BB', 'TE']
    for i in range(4):
        subplot(2,2,i+1)
        plot(input_ell,input_cl[:,i], color='k')
        title(order[i])
        xlabel('$\\ell$')
        ylabel('$D_\\ell$')
    tight_layout()
```

```{python}
#### Read a sample QUBIC coverage map (made in the RandomPointing approximmation)
cov = hp.ud_grade(hp.read_map('sample_coverage_qubic.fits', verbose=False), d['nside'])
cov /= np.max(cov)
hp.mollview(cov)
```

```{python}
#### Now mask these maps using QUBIC mask and add noise according to QUBIC coverage
seenpix = cov > (np.max(cov) >-1) #/ 10)
maps_observed = np.zeros_like(x0)

# Noise
noise_level = 0.0
fact_noise = [1., sqrt(2), sqrt(2)]

### For Now Uniform noise
for i in range(3):
    maps_observed[:,seenpix,i] = x0[:,seenpix,i] #+ np.random.randn(seenpix.sum()) * noise_level * fact_noise[i] 

figure() 
numsub = 1
for i in range(d['nf_sub']):
    for istokes in [0,1,2]:
        hp.mollview(maps_observed[i,:,istokes], min=-rng[istokes], max=rng[istokes],
                    sub=(d['nf_sub']+1,3,numsub), title=stn[istokes]+' subfreq {}'.format(i))
        numsub += 1

figure() 
numsub = 1
for i in range(d['nf_sub']):
    for istokes in [0,1,2]:
        hp.gnomview(maps_observed[i,:,istokes], min=-rng[istokes], max=rng[istokes],
                    rot=center, reso=15,
                    sub=(d['nf_sub']+1,3,numsub), title=stn[istokes]+' subfreq {}'.format(i))
        numsub += 1

```

```{python}
### NaMaster
# Create the mask
msk = np.zeros(12*d['nside']**2)
msk[seenpix]=1

# Now we apodize the mask. The pure-B formalism requires the mask to be
# differentiable along the edges. The 'C1' and 'C2' apodization types
# supported by mask_apodization achieve this.
msk_apo = nmt.mask_apodization(msk, 10.0, apotype='C1')

res=15
hp.mollview(msk, rot=center, sub=(2,2,1))
hp.mollview(msk_apo, rot=center, sub=(2,2,2))
hp.gnomview(msk, rot=center, reso=res, sub=(2,2,3))
hp.gnomview(msk_apo, rot=center, reso=res, sub=(2,2,4))
```

```{python}
# Select a binning scheme
##b = nmt.NmtBin.from_nside_linear(nside, 16)
b= nmt.NmtBin(d['nside'],nlb=16, is_Dell=True)

leff = b.get_effective_ells()

def get_fields(mp_t, mp_q, mp_u, msk_apo, purify_e=True, purify_b=True):
    # This creates a spin-0 field 
    f0 = nmt.NmtField(msk_apo, [mp_t, mp_t])
    # This creates a spin-2 field with both pure E and B.
    f2 = nmt.NmtField(msk_apo, [mp_q, mp_u], purify_e=purify_e, purify_b=purify_b)
    # Note that generally it's not a good idea to purify both,
    # since you'll lose sensitivity on E
    return f0, f2

def get_spectra(I,Q,U,mask,purify_e=True, purify_b=True, workspace=None):
    f0, f2 = get_fields(I, Q, U, mask, purify_e=purify_e, purify_b=purify_b)
    if workspace is None:
        w0 = nmt.NmtWorkspace()
        w0.compute_coupling_matrix(f0, f0, b)
        w2 = nmt.NmtWorkspace()
        w2.compute_coupling_matrix(f2, f2, b)
        w = [w0, w2]
    else:
        w = workspace
    # Spin 0
    c00coupled = nmt.compute_coupled_cell(f0, f0)
    c00 = w[0].decouple_cell(c00coupled)
    # Spin 2
    c22coupled = nmt.compute_coupled_cell(f2, f2)
    c22 = w[1].decouple_cell(c22coupled)
    # spectra
    spectra = np.array([c00[0], c22[0], c22[3]])
    return spectra, w

def plot_cells(ell, cells, color=None, label=None):
    cell_names = ['TT', 'EE', 'BB']
    for i in range(3):
        subplot(2,2,i+1)
        plot(ell, cells[i], color=color, label=label)
        xlabel('$\\ell$', fontsize=18)
        ylabel('$D_\\ell$', fontsize=18)
        if label is not None: legend(loc='upper right', frameon=False)
        title(cell_names[i])
    tight_layout()


cells, w = get_spectra(maps_observed[0,:,0], maps_observed[0,:,1], maps_observed[0,:,2], msk_apo,
                       purify_e=True, purify_b=True)
cellsnp, wnp = get_spectra(maps_observed[0,:,0], maps_observed[0,:,1], maps_observed[0,:,2], msk_apo,
                           purify_e=False, purify_b=False)


```

```{python}
pixwin = np.interp(leff, np.arange(3*d['nside']),hp.pixwin(d['nside']))
clth = Qubic_sky.input_cmb_spectra
ellth = np.arange(np.shape(input_cl)[0])
clnames = ['TT','EE','BB']
for i in range(3):
    subplot(2,3,i+1)
    plot(ellth, clth[:,i])
    plot(leff, cells[i,:],'o',label='Pure')
    plot(leff, cellsnp[i,:],'o', label='Not Pure')
    xlabel('$\\ell$')
    ylabel('$D_\\ell$')
    title(clnames[i])
    legend()
tight_layout()
```

```{python}

```

```{python}
pwd
```

```{python}

```
