---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Notebook to test Namaster tools to get spectra

Editting by Jean-Christophe and Louise

March 2020

```{python}
# %matplotlib inline
import numpy as np
import healpy as hp
import matplotlib.pyplot as plt

# Specific qubic modules
from qubicpack.utilities import Qubic_DataDir
from pysimulators import FitsArray
import pysm
import qubic
from qubic import QubicSkySim as qss
from qubic import NamasterLib as nam

rc('figure', figsize=(12, 8))
rc('font', size=15)
```

## Build maps with a given spectra

```{python}
#### Create sample CMB I,Q,U maps
global_dir = Qubic_DataDir(datafile='instrument.py', datadir=os.environ['QUBIC_DATADIR'])

# dictfilename = global_dir + '/dicts/BmodesNoDustNoSystPaper0_2020.dict'
dictfilename = global_dir + '/dicts/test_QubicSkySim.dict'

# Read dictionary chosen
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictfilename)
d['nside'] = 256
center = qubic.equ2gal(d['RA_center'], d['DEC_center'])
print(center)
```

```{python}
# Make a sky using PYSM3
seed = None
sky_config = {'cmb': seed}
Qubic_sky = qss.Qubic_sky(sky_config, d)
x0 = np.reshape(Qubic_sky.get_simple_sky_map(), (d['nf_sub'], d['nside']**2*12, 3))

print('Input Map with shape (nf_sub, #pixels, #stokes) : ', np.shape(x0))
rc('figure', figsize=(16, 10))
figure()
stn = ['I', 'Q', 'U']
rng = (np.std(x0, axis=(0,1))*3).astype(int)
rng[1:] = np.max(rng[1:])
numsub = 4
for i in range(d['nf_sub']):
    for istokes in [0, 1, 2]:
        hp.mollview(x0[i, :, istokes], min=-rng[istokes], max=rng[istokes],
                    sub=(d['nf_sub']+1, 3, numsub), title=stn[istokes]+' subfreq {}'.format(i))
        numsub += 1
```

```{python}
# Remember that we can always retrieve the input CMB maps and spectra
### Input Maps
input_maps = Qubic_sky.input_cmb_maps
rng = (np.std(input_maps, axis=(1))*3).astype(int)
rng[1:] = np.max(rng[1:])
figure()
hp.mollview(input_maps[0,:], title="I input map used", min=-rng[0], max=rng[0], sub=(1,3,1))
hp.mollview(input_maps[1,:], title="Q input map used", min=-rng[1], max=rng[1], sub=(1,3,2))
hp.mollview(input_maps[2,:], title="U input map used", min=-rng[2], max=rng[2], sub=(1,3,3))

### Input Dls
input_Dl = Qubic_sky.input_cmb_spectra
if input_Dl is not None:
    input_ell = np.arange(np.shape(input_Dl)[0])
    figure()
    order = ['TT', 'EE', 'BB', 'TE']
    for i in range(4):
        subplot(2,2,i+1)
        plot(input_ell, input_Dl[:,i], color='k')
        title(order[i])
        xlabel('$\\ell$')
        ylabel('$D_\\ell$')
    tight_layout()
```

### Get only the observed patch

```{python}
#### Read a sample QUBIC coverage map (made in the RandomPointing approximmation)
cov = hp.ud_grade(hp.read_map('sample_coverage_qubic.fits', verbose=False), d['nside'])
cov /= np.max(cov)
hp.mollview(cov)
```

```{python}
#### Now mask these maps using QUBIC mask and add noise according to QUBIC coverage
seenpix = cov > 0.5#(np.max(cov)/1000)
maps_observed = np.zeros_like(x0)

# Noise
noise_level = 0.0
fact_noise = [1., sqrt(2), sqrt(2)]

### For Now Uniform noise
for i in range(3):
    maps_observed[:, seenpix, i] = x0[:, seenpix, i] #+ np.random.randn(seenpix.sum()) * noise_level * fact_noise[i] 

figure() 
numsub = 1
for i in range(d['nf_sub']):
    for istokes in [0,1,2]:
        hp.mollview(maps_observed[i, :, istokes], min=-rng[istokes], max=rng[istokes],
                    sub=(d['nf_sub']+1,3,numsub), title=stn[istokes]+' subfreq {}'.format(i))
        numsub += 1

# figure() 
# numsub = 1
# for i in range(d['nf_sub']):
#     for istokes in [0,1,2]:
#         hp.gnomview(maps_observed[i,:,istokes], min=-rng[istokes], max=rng[istokes],
#                     rot=center, reso=15,
#                     sub=(d['nf_sub']+1,3,numsub), title=stn[istokes]+' subfreq {}'.format(i))
#         numsub += 1

```

# Testing the library NamasterLib

```{python}
# Create a Namaster object
lmin = 20
lmax = 3 * d['nside'] - 1
delta_ell = 16

Namaster = nam.Namaster(seenpix, lmin=lmin, lmax=lmax, delta_ell=delta_ell)
```

### Test the function that binned a spectra between lmin and lmax

```{python}
ell_binned, b = Namaster.get_binning(d)

Dls_binned = Namaster.bin_spectra(input_Dl[:, 0], d)
print('lmax=', lmax)

print(ell_binned.shape, Dls_binned.shape)

plt.plot(input_ell, input_Dl[:, 0])
plt.plot(ell_binned, Dls_binned[0, :],'o')
plt.xlabel('$\\ell$')
plt.ylabel('$D_\\ell$')
```

### Get spectra from IQU maps

```{python}
# Make a mask
mask_apo = Namaster.get_apodized_mask()

res=15
hp.mollview(mask_apo, sub=(121))
hp.gnomview(mask_apo, rot=center, sub=(122), reso=12)
```

### Make spectra

```{python}
# Make an 2D array containing IQU maps, the shape must be (3, #pixels)
maps = maps_observed[0].T
print('maps shape:', maps.shape)

# Get spectra
leff, cells, w = Namaster.get_spectra(maps, d, mask_apo, 
                                      purify_e=True, 
                                      purify_b=False, 
                                      beam_correction=False,
                                      pixwin_correction=False)
```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']

for i in range(4):
    plt.subplot(2, 2, i+1)
    plt.plot(input_ell, input_Dl[:, i])
    plt.plot(leff, cells[:, i],'o')
    plt.xlabel('$\\ell$')
    plt.ylabel('$D_\\ell$')
    plt.title(clnames[i])
plt.tight_layout()
```

### Test the beam correction

```{python}
smooth_maps = hp.sphtfunc.smoothing(maps, fwhm=np.deg2rad(d['synthbeam_peak150_fwhm']))
                          
# Get spectra
leff_nobeam, cells_nobeam, w_nobeam = Namaster.get_spectra(smooth_maps, d, mask_apo, 
                                                           purify_e=True, 
                                                           purify_b=False, 
                                                           beam_correction=False)
leff_beam, cells_beam, w_beam = Namaster.get_spectra(smooth_maps, d, mask_apo, 
                                                     purify_e=True, 
                                                     purify_b=False, 
                                                     beam_correction=True)


```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']

for i in range(4):
    plt.subplot(2, 2, i+1)
    plt.plot(input_ell, input_Dl[:, i], label='Input spectra')
    plt.plot(leff_nobeam, cells_nobeam[:, i], 'o', label='No correction')
    plt.plot(leff_beam, cells_beam[:, i], 'o', label='Beam correction')
    plt.xlabel('$\\ell$')
    plt.ylabel('$D_\\ell$')
    plt.title(clnames[i])
    plt.legend()
plt.tight_layout()
```

### Test the pixwin correction

```{python}
pwb = Namaster.get_pixwin_correction(d)
print(pwb.shape)

# Make maps with integration into pixels
input_Cl = qss.Dl2Cl_without_monopole(input_ell, input_Dl)

pw_maps = hp.synfast(input_Cl.T, d['nside'], pol=True, lmax=Namaster.lmax, pixwin=True, new=True)
print(pw_maps.shape)

# Get only the observed patch
pw_seenmaps = np.zeros_like(pw_maps)
for i in range(3):
    pw_seenmaps[i, seenpix] = pw_maps[i, seenpix]
# hp.mollview(pw_seenmaps[0, :])

# Get spectra with and without the pixwin correction
leff_pw, cells_pw, w_pw = Namaster.get_spectra(pw_seenmaps, d, mask_apo, 
                                                           purify_e=True, 
                                                           purify_b=False, 
                                                           beam_correction=False,
                                                           pixwin_correction=True)

leff_nopw, cells_nopw, w_nopw = Namaster.get_spectra(pw_seenmaps, d, mask_apo, 
                                                           purify_e=True, 
                                                           purify_b=False, 
                                                           beam_correction=False,
                                                           pixwin_correction=False)
```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']

for i in range(4):
    plt.subplot(2, 2, i+1)
    plt.plot(input_ell, input_Dl[:, i], label='Input spectra')
    plt.plot(leff_nopw, cells_nopw[:, i], 'o', label='No correction')
    plt.plot(leff_pw, cells_pw[:, i], 'o', label='Pixwin correction')
    plt.xlabel('$\\ell$')
    plt.ylabel('$D_\\ell$')
    plt.title(clnames[i])
    plt.legend()
plt.tight_layout()
```

### Do many realisations
Not finished

```{python}
def make_maps(d, seed=None, noise_level=0.):
    sky_config = {'cmb': seed}
    Qubic_sky = qss.Qubic_sky(sky_config, d)
    x0 = Qubic_sky.get_simple_sky_map()

    maps_observed = np.zeros_like(x0)

    # Noise
    fact_noise = [1., sqrt(2), sqrt(2)]

    ### For Now Uniform noise
    for i in range(3):
        maps_observed[:, seenpix, i] = x0[:, seenpix, i] + np.random.randn(seenpix.sum()) * noise_level * fact_noise[i] 

    maps = maps_observed[0].T
    print('maps shape:', maps.shape)
    return maps

# Do many realizations
nsim = 4
nsim_leff, nsim_cells = [], []
for sim in range(nsim):
    maps = make_maps(d)
    leff, cells, w = Namaster.get_spectra(maps, d, mask_apo, purify_e=True, purify_b=False, beam_correction=False)
    nsim_leff.append(leff)
    nsim_cells.append(nsim_cells)
print()
```

## Test bug PySM 3
This section will be removed later (Louise debugging).

```{python}
d['nf_sub'] = 1
lmax = 2 * d['nside']

# Create a sky with qss
seed = None
sky_config = {'cmb': seed}
Qubic_sky = qss.Qubic_sky(sky_config, d)
x0 = Qubic_sky.get_simple_sky_map()
print('x0 Shape:', x0.shape)

# Input map used by qss
inmap = Qubic_sky.input_cmb_maps
print('input Shape:', inmap.shape)

# Anafast spectrum from input map
clsin = hp.anafast(inmap, lmax=lmax)
ll = np.arange(0, lmax+1)
print('ll shape', ll.shape)
# print(ll)
Dlsin = ll * (ll + 1) * clsin / (2 * np.pi)
print('Dlsin', Dlsin.shape)

# Spectra used in qss to create the x0 map
Dlth = Qubic_sky.input_cmb_spectra
print('Dlth', Dlth.shape)
llth = np.arange(len(Dlth[:, 0]))
print('llth shape', llth.shape)
# print(llth)

# Spectra with Anafast from x0 map
Dls = []
for i in range(d['nf_sub']):
    Cls = hp.anafast(x0[i, :, :].T, lmax=lmax)
    Dls.append(ll * (ll + 1) * Cls / (2 * np.pi))
Dls = np.array(Dls)
print('Dls', Dls.shape)
   
    
order = ['TT', 'EE', 'BB', 'TE']
for i in range(4):
    subplot(2, 2, i+1)
    title(order[i])
    xlim(0, lmax)
    plot(llth, Dlth[:, i], 'k', label='Dl Th')
    plot(ll, Dlsin[i, :], alpha=0.3, label='Dl from Input')
    for k in range(d['nf_sub']):
        plot(ll, Dls[k, i, :], alpha=0.3, label='Dl from x0 band {}'.format(k))
legend()
```

```{python}

```
