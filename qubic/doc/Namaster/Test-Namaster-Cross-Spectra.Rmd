---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Testing Cross-Spectra with NaMaster
JCH - March 2020

```{python}
# %matplotlib inline
import numpy as np
import healpy as hp
import matplotlib.pyplot as plt
from importlib import reload

# Specific qubic modules
from qubicpack.utilities import Qubic_DataDir
from pysimulators import FitsArray
import pysm
import qubic
from qubic import QubicSkySim as qss
from qubic import NamasterLib as nam

rc('figure', figsize=(12, 8))
rc('font', size=15)
```

Let's generate an underlying CMB (I,Q,U) on a partial coverage, and then add noise according to this coverage.

```{python}
global_dir = Qubic_DataDir(datafile='instrument.py', datadir=os.environ['QUBIC_DATADIR'])
dictfilename = global_dir + '/dicts/test_cross-spectra.dict'

# Read dictionary chosen
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictfilename)
d['nside']=256
center = qubic.equ2gal(d['RA_center'], d['DEC_center'])
print(center)

# Restore a QUBIC typical coverage
cov = hp.ud_grade(hp.read_map('sample_coverage_qubic.fits', verbose=False), d['nside'])
cov /= np.max(cov)
hp.mollview(cov)
```

```{python}
reload(qss)
### Create fake QUBIC observations convolved at each frequency FWHM with noise and coverage
### They are all with the same CMB (from QubicSky instanciation) but will have different 
### noise realization
seed = None
sky_config = {'cmb': seed}
Qubic_sky = qss.Qubic_sky(sky_config, d)

nmaps = 3
all_maps = np.zeros((nmaps, 12*d['nside']**2, 3))

figure()
input_maps = Qubic_sky.input_cmb_maps
res = 30
stk = ['I', 'Q', 'U']
rng = [200, 10, 10]
for s in range(3):
    hp.gnomview(input_maps[s,:], sub=(nmaps,3,s+1), reso=res, rot=center,
                min=-rng[s], max=rng[s], title=stk[s]+' Noiseless')

### This si a very small noise level
for i in range(nmaps):
    all_maps[i,:,:] = Qubic_sky.get_partial_sky_maps_withnoise(cov, sigma_sec=10.)

figure()
for i in range(nmaps):
    hp.gnomview(all_maps[i,:,0], sub=(nmaps,3,3*i+1), reso=res, rot=center,
                min=-rng[0], max=rng[0], title=stk[0]+' Map {}'.format(i))
    hp.gnomview(all_maps[i,:,1], sub=(nmaps,3,3*i+2), reso=res, rot=center,
                min=-rng[1], max=rng[1], title=stk[1]+' Map {}'.format(i))
    hp.gnomview(all_maps[i,:,2], sub=(nmaps,3,3*i+3), reso=res, rot=center,
                min=-rng[2], max=rng[2], title=stk[2]+' Map {}'.format(i))
```

Now we'll compute the cross-Cls for all possibilities including auto-Cls

```{python}
reload(nam)
# Create a Namaster object
lmin = 20
lmax = 2 * d['nside'] - 1
delta_ell = 25
maskpix = cov > np.max(cov)/10
Namaster = nam.Namaster(maskpix, lmin=lmin, lmax=lmax, delta_ell=delta_ell)
ell_bins, b = Namaster.get_binning(d)
mask_apo = Namaster.get_apodized_mask()


leff, cl_nonoise, wnnonoise = Namaster.get_spectra(input_maps, d, mask_apo, 
                                            purify_e=False, purify_b=True, 
                                            verbose=False)


cls = np.zeros((nmaps, nmaps, len(ell_bins), 4))
w=None
for i in range(nmaps):
    for j in range(i,nmaps):
        print(i,j)
        leff, cls[i,j, :,:], w = Namaster.get_spectra(all_maps[i,:,:].T, d, mask_apo, 
                                                      map2=all_maps[j,:,:].T,
                                                      purify_e=False, purify_b=True, w=w, 
                                                      verbose=False,
                                                      beam_correction=Qubic_sky.instrument['beams'])
        cls[j,i, :,:] = cls[i,j, :,:].copy() 


```

```{python}
rc('figure', figsize=(12, 8))
input_cell = Qubic_sky.input_cmb_spectra
lth = np.arange(len(input_cell[:,0]))

s=2
xlim(0,2*d['nside'])
title('BB')
ylim(0,np.max(input_cell[:2*d['nside'],s])*1.2)
plot(lth, input_cell[:,s],'k:',label='Theory')
plot(leff, cl_nonoise[:,s],'k',label='No Noise')
for i in range(nmaps):
    for j in range(i,nmaps):
        plot(leff, cls[i,j,:,s], label='{}x{}'.format(i,j))
legend(fontsize=9)
        
```

```{python}

```
