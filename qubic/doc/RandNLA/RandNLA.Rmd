---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.16.1
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

```{python}
import qubic
from parla.drivers import evd
import scipy
from pyoperators import *
import healpy as hp
from time import time

rc('figure',figsize=(10,8))
rc('font',size=13)
```

Setting the dimensions of the problem.

```{python}
nside = 32
ndetectors = 992
npointings = 1000

n = 12*nside**2 * 3
m = ndetectors * npointings

print(f'n = {n}')
print(f'm = {m}')
```

```{python}
######## Technological Demonstrator COnfiguration #######
#dictname = 'RealisticScanning-BmodesNoDustNoSystPaper0_2020.dict'
dictname = 'pipeline_demo.dict'
#dictname = 'global_source_oneDet.dict'
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictname)
d['hwp_stepsize'] = 3
d['npointings'] = npointings
d['nside'] = nside
d['synthbeam_kmax'] = 3
d['synthbeam_fraction'] = 0.95
d['random_pointing'] = True
d['repeat_pointing'] = False
#d['dtheta'] = 80
q = qubic.QubicInstrument(d)
s = qubic.QubicScene(d)
samp = qubic.get_pointing(d)
```

Creating a map, the operator H, and generating the TOD.

```{python}
acq = qubic.QubicAcquisition(q, samp, s, d)
H_op = acq[:ndetectors].get_operator()
```

```{python}
def circular_mask(nside, center, radius):
    lon = center[0]
    lat = center[1]
    vec = hp.ang2vec(lon, lat, lonlat=True)
    disc = hp.query_disc(nside, vec, radius=np.deg2rad(radius))
    m = np.zeros(hp.nside2npix(nside))
    m[disc] = 1
    return np.array(m, dtype=bool)

mask = circular_mask(nside, qubic.equ2gal(0, -57), d['dtheta'])

Mask = np.zeros((H_op.shape[1], np.count_nonzero(mask), 3))
a = 0
for i in range(len(mask)):
    if mask[i]:
        Mask[i*3:(i+1)*3,a] = np.identity(3)
        a += 1
Mask = np.reshape(Mask, (H_op.shape[1], np.count_nonzero(mask)*3))

PatchMask = ReshapeOperator(H_op.shape[1], H_op.shapein) * asoperator(Mask, flags='linear,real') * ReshapeOperator(
    (np.count_nonzero(mask), 3), np.count_nonzero(mask)*3)

H = H_op * PatchMask
```

```{python}
'''
map = np.ones((12*nside**2, 3))

acq = qubic.QubicAcquisition(q, samp, s, d)
H = acq[:ndetectors].get_operator()
tod = H(map)

invN = acq[:ndetectors].get_invntt_operator()

A = H.T * invN * H
b = H.T * invN * tod
'''
```

```{python}
map = np.ones((np.count_nonzero(mask), 3))

tod = H(map)

invN = acq[:ndetectors].get_invntt_operator()

A = CompositionOperator((H.T, invN, H), flags='linear,real,symmetric,square')
b = H.T * invN * tod
```

```{python}
'''
H_qubic = H
R_qubic = ReshapeOperator(H_qubic.operands[0].shapeout, H_qubic.operands[0].shape[0])
R_planck = ReshapeOperator((12*nside**2, 3), (12*nside**2*3))

Operator = [R_qubic(H_qubic), R_planck]
#BlockColumnOperator(Operator, axisout=0)
R_planck.todense()
'''
```

```{python}
hp.visufunc.mollview(map=PatchMask(map)[:,0])
```

```{python}
hp.visufunc.mollview(map=acq[:ndetectors].get_coverage(), title='coverage')
```

```{python}
print(f'map: {map.shape}')
print(f'H: {H.shape}')
print(f'TOD: {tod.shape}')
print(f'A: {A.shape}')
print(f'b: {b.shape}')
```

Calculating the preconditioners

```{python}
start = time()
k_list = [10, 50, 150]
invM_list = []

for k in k_list:
    V, D = evd2(A, k, 10, 5, None)
    
    invM = D[-1]* V @ np.diag(1/D) @ V.T + (np.identity(A.shape[1]) - V @ V.T)
    invM_list.append(ReshapeOperator(A.shape[1], A.shapein) * asoperator(invM, 
                                                flags='real,symmetric') * ReshapeOperator(A.shapeout, A.shape[0]))
print(time()-start)
```

```{python}
inv_cov = acq[:ndetectors].get_preconditioner(acq[:ndetectors].get_coverage())
inv_cov = PatchMask.T * inv_cov * PatchMask
```

Computing the PCG

```{python}
start = time()
Max_iterations = [0,1,2,3,4,5,7,9,11,13,15,18,21,24,27,30,33,36,39,42,45,48,51]

residues_cg = []
residues_invcov_pcg = []
residues_nystrom_pcg = np.empty((len(k_list), len(Max_iterations)))

for i, val in enumerate(Max_iterations):
    x_cg = pcg(A, b, tol=1e-50, maxiter=val)['x']
    residues_cg.append(np.linalg.norm(b-A(x_cg))/np.linalg.norm(b))
    
    x_pcg_cov = pcg(A, b, tol=1e-50, maxiter=val, M=inv_cov)['x']
    residues_invcov_pcg.append(np.linalg.norm(b-A(x_pcg_cov))/np.linalg.norm(b))

    for k in range(len(k_list)):
        x_nystrom_pcg = pcg(A, b, tol=1e-50, maxiter=val, M=invM_list[k])['x']
        residues_nystrom_pcg[k, i] = (np.linalg.norm(b-A(x_nystrom_pcg))/np.linalg.norm(b))
print(time()-start)
```

```{python}
plt.plot(Max_iterations, residues_cg, label='CG')
plt.plot(Max_iterations, residues_true_invcov_pcg, label='inverse coverage PCG')
for k in range(len(k_list)):
    plt.plot(Max_iterations, residues_nystrom_pcg[k], label=f'Nyström PCG, k={k_list[k]}')
plt.yscale('log')
plt.grid(axis='y', linestyle='dotted')
plt.xlabel('Number of iterations')
plt.ylabel(r'Relative residue $\frac{||b-Ax||}{||b||}$')
plt.title(f'Solving $Ax=b$, A has size {A.shape}')
plt.legend()
plt.show()
```

## Analysis of the eigenvalues of A. Do this only if A is not to big !!

```{python}
A_matrix = A.todense()
```

```{python}
plt.matshow(A_matrix, vmin=-np.max(A_matrix), vmax=np.max(A_matrix), cmap='seismic')
plt.colorbar(boundaries=np.linspace(np.min(A_matrix), np.max(A_matrix), 1000))
plt.xlabel('Sky\'s pixels ' r'$\times$ (I, Q, U)')
plt.ylabel('Sky\'s pixels ' r'$\times$ (I, Q, U)')
plt.title(r'$A = H^TN^{-1}H$')
plt.show()

plt.matshow(A_matrix, vmin=np.min(A_matrix), vmax=-np.min(A_matrix), cmap='seismic')
plt.colorbar()
plt.xlabel('Sky\'s pixels ' r'$\times$ (I, Q, U)')
plt.ylabel('Sky\'s pixels ' r'$\times$ (I, Q, U)')
plt.title(r'$A = H^TN^{-1}H$, truncated scale')
plt.show()
```

```{python}
vec = np.zeros(H.T.shapein)
vec[231,21] = 1
hp.gnomview(PatchMask(H.T(vec))[:,0], rot=qubic.equ2gal(0, -57), reso=12, cmap='viridis', title='Example of a pointing')
```

```{python}
plt.plot(np.diag(A_matrix))
plt.xlabel('Sky\'s pixels ' r'$\times$ (I, Q, U)')
plt.title('Diagonal values of A')
plt.show()
```

```{python}
detectors = [[i]*3 for i in range(A.shape[0]//3)]
hp.gnomview(PatchMask(detectors)[:,0], rot=qubic.equ2gal(0, -57), reso=12, cmap='jet', title='Numbering of the pixels in Qubic\'s patch')
```

```{python}
A_reshaped = np.reshape(A_matrix, (A_matrix.shape[0]//3, 3, A_matrix.shape[1]//3, 3))
plt.plot(np.diag(A_reshaped[:,0,:,0]), label=r'$A_I$')
plt.plot(np.diag(A_reshaped[:,1,:,1]), label=r'$A_Q$')
plt.plot(np.diag(A_reshaped[:,2,:,2]), label=r'$A_U$')
plt.title('Diagonal values of A')
plt.xlabel('Sky\'s pixels')
plt.legend()
plt.show()
```

```{python}
A_I_diag = np.diag(A_reshaped[:,0,:,0])
plt.plot(A_I_diag, label=r'$A_I$')
edge_det,_ = scipy.signal.find_peaks(-A_I_diag, height=-(np.max(A_I_diag)+np.min(A_I_diag))/2)
plt.plot(edge_det, A_I_diag[edge_det], 'x', label='identifying pixels at the edge of the patch')
plt.title('Diagonal values of A')
plt.xlabel('Sky\'s pixels')
plt.legend()
plt.show()
```

```{python}
detectors = np.zeros(A.shapein)
for det in edge_det:
    detectors[det] = [1,1,1]
hp.gnomview(PatchMask(detectors)[:,0], rot=qubic.equ2gal(0, -57), reso=12, cmap='jet', title='numerotation of the pixels in the sky')

```

```{python}
plt.matshow(A_matrix, vmin=np.min(A_matrix), vmax=-np.min(A_matrix), cmap='seismic')
plt.vlines(edge_det*3, 0, A.shape[0]-1, colors='black', linestyles='dotted')
plt.hlines(edge_det*3, 0, A.shape[0]-1, colors='black', linestyles='dotted')
plt.colorbar()
plt.xlabel('Sky\'s pixels ' r'$\times$ (I, Q, U)')
plt.ylabel('Sky\'s pixels ' r'$\times$ (I, Q, U)')
plt.title(r'$A = H^TN^{-1}H$, truncated scale')
plt.show()
```

Let's see how the preconditioning matrix are affecting the eigenvalues of A.

```{python}
A_approx = V @ np.diag(D) @ V.T
```

```{python}
plt.matshow(A_approx, vmin=np.min(A_matrix), vmax=-np.min(A_matrix), cmap='seismic')
plt.colorbar(shrink=0.85)
plt.xlabel('Sky\'s pixels ' r'$\times$ (I, Q, U)')
plt.ylabel('Sky\'s pixels ' r'$\times$ (I, Q, U)')
plt.title(r'Nyström approximation of $A$: $\hat{A}=UDU^T$, truncated scale')
plt.show()
```

```{python}
start = time()
inv_cov_matrix = inv_cov.todense()
invM_matrix = []
for invM in invM_list:
    invM_matrix.append(invM.todense())
print(time()-start)
```

```{python}
start = time()
eigenvalues_A = scipy.linalg.eigh(A_matrix, eigvals_only=True)
eigenvalues_invcov_A = scipy.linalg.eigh(inv_cov_matrix @ A_matrix, eigvals_only=True)
eigenvalues_invM_A = []
for invM in invM_matrix:
    eigenvalues_invM_A.append(scipy.linalg.eigh(invM @ A_matrix, eigvals_only=True))
print(time()-start)
```

```{python}
print(f'smallest eigenvalue of A: {np.min(eigenvalues_A)}')
print(f'smallest eigenvalue of InvCov A: {np.min(eigenvalues_invcov_A)}')
```

```{python}
plt.plot(eigenvalues_A[::-1])
plt.xlabel('Sky\'s pixels ' r'$\times$ (I, Q, U)')
plt.title('Eigenvalues of A')
plt.show()
```

```{python}
plt.plot(eigenvalues_A[::-1], label='A')
for index, eigenvalues in enumerate(eigenvalues_invM_A):
    plt.plot(eigenvalues[::-1], label=r'$M_{{{0}}}^{{{1}}} \cdot A$'.format(k_list[index], -1))
plt.xlabel('Sky\'s pixels ' r'$\times$ (I, Q, U)')
plt.title('Eigenvalues for the Nyström preconditioner')
plt.legend()
plt.show()
```

```{python}
plt.plot(eigenvalues_A[::-1], label='A')
plt.plot(eigenvalues_invcov_A[::-1]/np.mean(np.diag(inv_cov_matrix)), label=r'$\frac{InvCov \cdot A}{mean(InvCov)}$')
plt.xlabel('Sky\'s pixels ' r'$\times$ (I, Q, U)')
plt.title('Eigenvalues for the inverse coverage preconditioner')
plt.legend()
plt.show()
```

```{python}
plt.plot(eigenvalues_A[::-1], label='eigenvalues of A')
plt.plot(D, label=f'{k_list[-1]} eigenvalues estimated by Nyström\'s preconditioner')
plt.plot(np.sort(np.diag(A_matrix))[::-1], label='sorted diagonal of A')
plt.xlabel('Sky\'s pixels ' r'$\times$ (I, Q, U)')
plt.title('Approximating the eigenvalues of A with its diagonal and Nyström\'s preconditioner')
plt.legend()
plt.show()
```

Let's see the eigenvectors of A

```{python}
eigenvalues_A, eigenvectors = scipy.linalg.eigh(A_matrix)
```

```{python}
A_without_noise = (H.T * H).todense()
```

```{python}
true_inv_cov = ReshapeOperator(A.shape[1], A.shapein) * asoperator(1/np.diag(A_without_noise), 
                                                flags='real,linear,symmetric') * ReshapeOperator(A.shapeout, A.shape[0])
```

```{python}
start = time()
Max_iterations = [0,1,2,3,4,5,7,9,11,13,15,18,21,24,27,30,33,36,39,42,45,48,51]

residues_cg = []
residues_invcov_pcg = []
residues_true_invcov_pcg = []

for i, val in enumerate(Max_iterations):
    x_cg = pcg(A, b, tol=1e-50, maxiter=val)['x']
    residues_cg.append(np.linalg.norm(b-A(x_cg))/np.linalg.norm(b))
    
    x_pcg_cov = pcg(A, b, tol=1e-50, maxiter=val, M=inv_cov)['x']
    residues_invcov_pcg.append(np.linalg.norm(b-A(x_pcg_cov))/np.linalg.norm(b))

    x_pcg_true_cov = pcg(A, b, tol=1e-50, maxiter=val, M=true_inv_cov)['x']
    residues_true_invcov_pcg.append(np.linalg.norm(b-A(x_pcg_true_cov))/np.linalg.norm(b))
print(time()-start)
```

```{python}
plt.plot(Max_iterations, residues_cg, label='CG')
plt.plot(Max_iterations, residues_invcov_pcg, label='inverse coverage PCG')
plt.plot(Max_iterations, residues_true_invcov_pcg, label=r'inverse diagonal $H^T H$ PCG')
plt.yscale('log')
plt.grid(axis='y', linestyle='dotted')
plt.xlabel('Number of iterations')
plt.ylabel(r'Relative residue $\frac{||b-Ax||}{||b||}$')
plt.title(f'Solving $Ax=b$, A has size {A.shape}')
plt.legend()
plt.show()
```

```{python}
eigenvalues_A_noiseless = scipy.linalg.eigh(A_without_noise, eigvals_only=True)
```

```{python}
plt.plot(eigenvalues_A_noiseless[::-1])
plt.xlabel('Sky\'s pixels ' r'$\times$ (I, Q, U)')
plt.title('Eigenvalues of noiseless A')
plt.show()
```

```{python}
hp.gnomview(PatchMask(np.reshape(np.diag(A_without_noise), (A_without_noise.shape[0]//3, 3)))[:,0], 
            rot=qubic.equ2gal(0, -57), reso=12, title='Coverage')
```

```{python}
hp.gnomview(acq[:ndetectors].get_coverage(), rot=qubic.equ2gal(0, -57), reso=12, title='coverage')
```

```{python}
fig = plt.figure(figsize = (15,12))
for i in range(9):
    hp.gnomview(PatchMask(np.reshape(eigenvectors[i], (A.shape[0]//3, 3)))[:,0], rot=qubic.equ2gal(0, -57), reso=12, 
                sub=(3,3,i+1), title=f'eigenvector {i+1}')
```

Defining the preconditioner

```{python}
def evd(A, k, over, num_passes, rng):
    """
    Return ndarrays (V, lamb) that define a symmetric positive semidefinite matrix
    "A_approx" through its eigen-decomposition:

        A_approx = (V * lamb) @ V.T.

    The function assumes A is symmetric positive semidefinite.
    The columns of V are approximations of the dominant eigenvectors of A.
    The entries of lamb are the corresponding approximate eigenvalues.

    The approximation is "fixed rank." The array V has min(k, rank(A)) columns,
    and there is no direct control over the approximation error ||A_approx - A||.
    Increasing "num_passes" and "over" should result in better approximations.

    Parameters
    ----------
    A : Union[ndarray, spmatrix, LinearOperator]
        Data matrix to approximate. A must be an n × n positive semidefinite matrix.

    k : int
        Target rank for the approximation of A: 0 < k < n.

    over : int
        Perform internal calculations with a sketch of rank (k + over).
        This is usually a small constant, e.g., 5 to 25. In some situations
        it's useful to set over = k.

    num_passes : int
        Total number of passes the algorithm is allowed over A.
        We require num_passes >= 1, and usually we have num_passes <= 10.
        Increasing this parameter is one way to obtain better
        approximations, especially at lower ranks.

    rng : Union[None, int, SeedSequence, BitGenerator, Generator]
        Determines the numpy Generator object that manages randomness
        in this function call.

    Returns
    -------
    V : ndarray
        Has shape (n, min(k, rank(A)). Columns are orthonormal.

    lamb : ndarray
        Has shape (min(k, rank(A)),), the vector of estimated eigenvalues of A.

    Notes
    -----
    We perform (num_passes - 1) steps of subspace iteration, and
    stabilize subspace iteration by a QR factorization at every step.

    References
    ----------
    This function adapts Algorithm 3 from

        Joel A Tropp, Alp Yurtsever, Madeleine Udell, and Volkan Cevher.
        "Fixed-rank approximation of a positive-semidefinite matrix from streaming data."
        Advances in neural information processing systems, 2017.
        (available at `arXiv <https://arxiv.org/abs/1706.05736>`_).
    """
    assert num_passes >= 1
    assert k > 0
    n = A.shape[0]
    assert k < n
    rng = np.random.default_rng(rng)

    scale = np.sqrt(1.0/min(A.shape[1], k+over))
    S = rng.normal(0.0, scale, (A.shape[1], k+over))
    for q in range(num_passes-1):
        for j in range(k+over):
            S[:,j] = np.ndarray.flatten(A(np.reshape(S[:,j], A.shapein)))
        S = scipy.linalg.qr(S, mode='economic')[0]

    Y = np.empty(S.shape)
    for j in range(k+over):
        Y[:,j] = np.ndarray.flatten(A(np.reshape(S[:,j], A.shapein)))
    epsilon_mach = np.finfo(float).eps
    nu = np.sqrt(n) * epsilon_mach * scipy.linalg.norm(Y)
    # a temporary regularization parameter
    Y = Y + nu*S
    R = scipy.linalg.cholesky(S.T @ Y, lower=False)
    # R is upper-triangular and R^T @ R = S^T @ Y = S^T @ (A + nu*I)S
    B = (scipy.linalg.solve_triangular(R, Y.T, lower=False, trans=True)).T
    # B has n rows and k + s columns
    V, sigma, Wh = scipy.linalg.svd(B)
        
    comp_list = [k]
    for i in range(k-1):
        if sigma[(i+1)]**2 <= nu:
            comp_list.append(i)
    r = min(comp_list)
    # drop components that relied on regularization
    lamb = (sigma**2)[:r]-nu
    V = V[:, :r]
    
    return V, lamb
```

```{python}

```

$$\frac{O(mn^2)}{O\left(mn\log\left(\frac{1}{\epsilon}\right)+n^3\right)} \approx \frac{O(mn^2)}{O\left(mn\log\left(\frac{1}{\epsilon}\right)\right)} \approx \frac{n}{\log\left(\frac{1}{\epsilon}\right)} \approx \frac{n}{10}$$

```{python}

```
