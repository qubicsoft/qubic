---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Synthetized beam on the sky

```{python}
import glob
import os 

import numpy as np
import healpy as hp

import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

# %matplotlib inline
# %matplotlib notebook

from matplotlib import rc
rc('figure',figsize=(15,15))
rc('font',size=14)
#rc('text',usetex=False)

from qubicpack.utilities import Qubic_DataDir
import qubic 
import qubic.sb_fitting as sbfit
import qubic.selfcal_lib as scal

from qubicpack.pixel_translation import make_id_focalplane, tes2index
```

```{python}
# Dictionary
d = qubic.qubicdict.qubicDict()
d.read_from_file(os.environ['QUBIC_DICT']+'pipeline_demo.dict')

# d.read_from_file(dictfilename)
d['config'] = 'TD'

d['synthbeam_kmax'] = 3

# Instrument and scene
q = qubic.QubicInstrument(d)
s = qubic.QubicScene(d)
```

### Synthetic beams on the sky for all TES

```{python}
sb = q.get_synthbeam(s, idet=None, external_A=None, hwp_position=0)
print(sb.shape)
```

#### Coordinates of the peaks (spherical coordinates in radian) for each TES

```{python}
kmax = d['synthbeam_kmax']
npeaks = (2 * kmax + 1)**2

horn_spacing = q.horn.spacing
horn_angle = q.horn.angle
nu = d['filter_nu']

position_TES = q.detector.center

# Coordinate on a simple grid
theta, phi = q._peak_angles_kmax(kmax, horn_spacing, horn_angle, nu, position_TES)
print(theta[0])

# Coordinates ordered from highest intensity to the smallest one
theta_order, phi_order, val = q._peak_angles(s, nu, q.detector.center, q.synthbeam, q.horn, q.primary_beam)

```

```{python}
# Plot
nTES = 2
for TES in range(nTES):
#     hp.mollview(sb[TES], min=0, max=1e5, title=None)
    hp.gnomview(sb[TES], min=0, max=1e5, rot=(0, 90), reso=30, title=None)
    for p in range(npeaks):
        th = theta[TES, p]
        ph = phi[TES, p]
        th2 = theta_order[TES, p]
        ph2 = phi_order[TES, p]
#         hp.visufunc.projscatter(th, ph, color='w', marker='+')
        hp.visufunc.projtext(th, ph, str(p), color='w', fontsize=12)
        hp.visufunc.projtext(th2 - 0.02, ph2, str(p), color='r', fontsize=12)
```

#### Print on the sky the motion of the one peak for all TES 

```{python}
# Choose a peak
p = 30
hp.gnomview(sb[200] * 0., min=0, max=1e6, rot=(0, 90), reso=12, title=None)
for TES in range(248):
    color = 'w'
    th = theta[TES, p]
    ph = phi[TES, p]
    hp.visufunc.projscatter(th, ph, color=color, marker='.')
#     hp.visufunc.projtext(th, ph, str(TES), color=color, fontsize=10)

```

### Measured beam

Get the measurement and order them as the simulations.

```{python}
path = '/home/lmousset/QUBIC/Qubic_work/Calibration/datas/Synthetic_beams/2019-avril/synth_beam_150'

sb_measured = np.zeros_like(sb)
for PIX in range(1, 256):
    # Convert to Qubic soft numerotation
    if PIX < 129:
        TES = PIX
        ASIC = 1
    else:
        TES = PIX - 128
        ASIC = 2
    print(PIX, TES, ASIC)
    if TES not in [4, 36, 68, 100]:
        x, y, FP_index, index_q = scal.TES_Instru2coord(TES, ASIC, q, frame='ONAFP')
    
    sb_measured[index_q, :] = sbfit.get_hpmap(PIX, path)
    if PIX == 93:
        hp.gnomview(sb_measured[index_q, :], reso=9, min=0., max=1e5)
plt.show()
```

### Coordinates of the TES in ONAFP

```{python}
xONAFP, yONAFP, vONAFP = scal.get_TEScoordinates_ONAFP(q)
print(xONAFP.shape)
```

### Plot

To compare simu/measurement, it looks we have to do the following (not sure):
* Measurement: centered on (lon=0, lat=0, phi=0)
* Simulation: centered on (lon=0, lat=90, phi=180)

```{python}
# Choose a TES (Instrument numerotation)
TES, ASIC = 6, 1
x0, y0, FP_index, index_q = scal.TES_Instru2coord(TES, ASIC, q, frame='ONAFP')

plt.subplots(1, 3, figsize=(12, 7))
plt.suptitle(f'TES {TES} - ASIC {ASIC} - Index_q {index_q}')

# Focal plane
plt.subplot(131)
plt.scatter(xONAFP, yONAFP, marker='s', s=50, alpha=0.3)
plt.xlabel('X_ONAFP')
plt.ylabel('Y_ONAFP')
plt.plot(x0, y0, 'ro')
plt.axis('square')
plt.title('Focal plane')

# Simulation
plt.subplot(132)
plt.axis('off')
hp.gnomview(sb[index_q], min=0, max=1e5, rot=(0, 90, 180), reso=12, sub=(132), 
            title='Simulation', cbar=False)
hp.graticule()
# for p in range(npeaks):
#     th = theta[index_q, p]
#     ph = phi[index_q, p]
#     th2 = theta_order[index_q, p]
#     ph2 = phi_order[index_q, p]
#     hp.visufunc.projtext(th-0.02, ph-0.02, str(p), color='w', fontsize=10) 
#     hp.visufunc.projtext(th2+0.02, ph2+0.02, str(p), color='r', fontsize=10) 

# Measurement
plt.subplot(133)
plt.axis('off')
hp.gnomview(sb_measured[index_q], min=0, max=1e4, rot=(0, 0, 0), reso=12, sub=(133), 
            title='Measurement', cbar=False)
hp.graticule()
```

### Animation to see the beam moving

```{python}
def animate(det):
    index = q.detector.index[det]
       
    # Focal plane
#     ax1.annotate(str(tes_index[tes]),  xy=(x, y), fontsize=10, color='r')
    
    x = xONAFP[det]
    y = yONAFP[det]
    point.set_data(x, y)
#     ax1.set_title('TES {}'.format(index))
    
    
    # Simulation
    hp.gnomview(sb[det], min=0, max=1e5, rot=(0, 90), reso=30, sub=(222), 
                title='Simulation', cbar=False)
    hp.graticule()
    for p in range(npeaks):
        th = theta[det, p]
        ph = phi[det, p]
        th2 = theta_order[det, p]
        ph2 = phi_order[det, p]
#         hp.visufunc.projscatter(th, ph, color='w', marker='+')
        hp.visufunc.projtext(th-0.02, ph-0.02, str(p), color='w', fontsize=12) 
        hp.visufunc.projtext(th2+0.02, ph2+0.02, str(p), color='r', fontsize=12) 
    
    # Measurement
    hp.gnomview(sb_measured[det], rot=(0, 0, 180), reso=15, sub=(223), 
                title='Measurement', cbar=False)
    hp.graticule()


def init():
#     ax1.set_title('Synthetic beam on the sky')
    ax1.axis('square')
    ax2.axis('off')
    ax3.axis('off')
    ax4.axis('off')
    
    

fig, axs = plt.subplots(2, 2, figsize=(12, 12))
ax1, ax2, ax3, ax4 = np.ravel(axs)
ax1.scatter(xONAFP, yONAFP, marker='s', s=200, alpha=0.3)
ax1.set_xlabel('X_ONAFP')
ax1.set_ylabel('Y_ONAFP')

det0 = 130
x0 = xONAFP[det0]
y0 = yONAFP[det0]
point, = ax1.plot(x0, y0, 'ro')
steps = np.arange(det0, det0+20, 2)

ani = FuncAnimation(fig, animate, steps, init_func=init, interval=1000, blit=True, repeat=False)


```

```{python}

```
