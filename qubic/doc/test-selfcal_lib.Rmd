---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Simulations for calibration (fringes on the FP)

#### Edited by Louise 26-11-2020
selfcal_lib.py allows to do several simulations concerning the calibration, especially the simlation of the signal on the focal plane. This notebook gives some examples of what you can do with.

```{python pycharm={'is_executing': False}}
from __future__ import division, print_function

# %matplotlib inline
# %matplotlib notebook

import numpy as np
import scipy
import matplotlib.pyplot as plt
import matplotlib.ticker as plticker
from matplotlib.colors import SymLogNorm

from qubicpack.utilities import Qubic_DataDir
import qubic
from qubic import selfcal_lib as scal

plt.rcParams['figure.figsize'] = (12, 6)

```

```{python}
# Use a tool from qubicpack to get a path
basedir = Qubic_DataDir(datafile='instrument.py', ) 
print('basedir : ', basedir)


# Get a dictionary
dictfilename = basedir + '/dicts/global_source_oneDet.dict'
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictfilename)
print(d['detarray'])
print(d['MultiBand'])
print(d['nf_sub'])

d['MultiBand'] = False
d['nf_sub'] = 1
d['config'] = 'TD'
d['beam_shape'] = 'gaussian'
```

## Instrument detector and horn config

```{python}
# QubicInstrument
q = qubic.QubicInstrument(d)

plt.figure(figsize=(6, 4))
q.detector.plot(fill=True)
plt.xlabel('X_GRF')
plt.ylabel('Y_GRF')
plt.title('q.detector.plot()')

# q.optics.focal_length = 0.30 # Change the focal length
```

```{python}
# Open or close switches
scal.close_switches(q, np.arange(1, 64))
scal.open_switches(q, [1, 45, 50])

# Plot the horn array and a baseline
plt.subplots(1, 2, figsize=(12, 6))

plt.subplot(121)
q.horn.plot()
plt.xlabel('$X_{GRF}$ [m]', fontsize=20)
plt.ylabel('$Y_{GRF}$ [m]', fontsize=20)
plt.axis('equal')

# Numbering on the horns
a = 1
x = q.horn.center[:, 0]
y = q.horn.center[:, 1]
for i,j in zip(x, y):
    corr = -0.002 # add a little correction to put annotation in marker's centrum
    plt.annotate(str(a),  xy=(i + corr, j + corr), fontsize=14, color='r')
    a += 1
    
plt.subplot(122)
q.horn.plot()
scal.plot_baseline(q, [25, 57])
plt.xlabel('$X_{GRF}$ [m]', fontsize=20)
plt.ylabel('$Y_{GRF}$ [m]', fontsize=20)
plt.axis('equal')
```

## Analytical function

```{python}
baseline = [25, 57]
Model_Ana = scal.Model_Fringes_Ana(q, baseline, theta_source=0., nu_source=150e9, fwhm=20., amp=1., frame='ONAFP')
print(Model_Ana.focal)

xONAFP, yONAFP, fringes = Model_Ana.get_fringes(times_gaussian=True)

plt.figure()
scal.scatter_plot_FP(q, xONAFP, yONAFP, fringes, frame='ONAFP')

```

# Qubic soft simulation (no aberrations)

This is a simulation that doesn't take into account optical aberrations (only geometrical optics). If the point source is on the optical axis, then you get a symmetrical image.

In general Qubic Soft uses only the GRF frame. However, selfcal_lib allows to use the ONAFP frame which is the one uned on the instrument.


#### Create an Fringes object

```{python}
# baseline = [142, 230] # for the FI
baseline = [25, 57]     # for the TD

Model_QS = scal.Model_Fringes_QubicSoft(q, baseline,
                                        theta_source=0., phi_source=0.,
                                        nu_source=150e9, spec_irrad_source=1.,
                                        frame='ONAFP', external_A=None, hwp_position=0)
```

```{python}
# Information are store in the object
print(Model_QS.frame)
print(Model_QS.nu_source)
print(Model_QS.baseline)
```

#### Get fringes 

You can choose ONAFP or GRF frame.
Each pointing is defined by a position of the source (theta, phi).

```{python}
xONAFP, yONAFP, fringes = Model_QS.get_fringes(doplot=True, verbose=True, norm=None)

print('fringes shape:', fringes.shape)
```

```{python}
# Information are store in the object
print(Model_QS.x)
print(Model_QS.fringes)
```

#### Plot the fringes

There are 2 functions, one with scatter plot and the other with pcolor.
It is convenient to be sure of the coordinates and the image orientation. 

```{python}
plt.subplots(1, 2)
plt.suptitle(f'Baseline: {baseline}', fontsize=18)
plt.subplots_adjust(wspace=0.3)

plt.subplot(121)
scal.scatter_plot_FP(q, xONAFP, yONAFP, fringes, frame='ONAFP', title='Scatter plot', norm=None)

plt.subplot(122)
scal.pcolor_plot_FP(q, xONAFP, yONAFP, fringes, frame='ONAFP', title='pcolor plot', norm=None)
```

#### Get fringes from the combination 

```{python}
# Get all combinations
x, y, S, Cminus_i, Sminus_ij, Cminus_j, Ci, Cj, Sij = Model_QS.get_all_combinations_power(doplot=True, 
                                                                                          verbose=True, 
                                                                                          norm=SymLogNorm(5e-8))

print('shape of each combination :', Cminus_i.shape)
```

```{python}
# Make the combination to get the fringes

# Complete one: S_tot - Cminus_i - Cminus_j + Sminus_ij + Ci +Cj
x, y, fringes_true = Model_QS.get_fringes_from_combination(measured_comb=False,
                                                           doplot=True, verbose=False)

# Measured one: S_tot - Cminus_i - Cminus_j + Sminus_ij
x, y, fringes_meas = Model_QS.get_fringes_from_combination(measured_comb=True,
                                                           doplot=True, verbose=False)
```

```{python}
# Look at the difference between both combinations

plt.subplots(1, 2)
plt.suptitle(f'Baseline: {baseline}', fontsize=18)
plt.subplots_adjust(wspace=0.3)

plt.subplot(121)
scal.scatter_plot_FP(q, x, y, fringes_true, frame='ONAFP', title='Complete combination', norm=None)

plt.subplot(122)
scal.scatter_plot_FP(q, x, y, fringes_meas, frame='ONAFP', title='Measured combination', norm=None)
```

# Power on the focal plane with Maynooth simulations

Those simulations include optical aberrations.
You need to download the files at : https://drive.google.com/open?id=19dPHw_CeuFZ068b-VRT7N-LWzOL1fmfG

```{python}
# Path to the simulated files 
rep = Qubic_DataDir(datafile='detcentres.txt', datadir='/home/lmousset/QUBIC/')
print('rep:', rep)
```

#### Get the power on the FP for an arbitrary horn configuration

This simulations are done in the ONAFP frame. The resolution is high (241 x 241) and it assumes an area bigger than the focal plane.

```{python}
open_horns = [1, 6, 7, 34, 10, 16]
xONAFP, yONAFP, power = scal.get_power_Maynooth(rep, open_horns, 
                                                0., 150e9, 
                                                q.horn.center,  
                                                hwp_position=0,
                                                verbose=True)
print(xONAFP.shape)
print(power.shape)

plt.figure()
scal.scatter_plot_FP(q, xONAFP, yONAFP, power, s=1, 
                   frame='ONAFP', 
                   title='Maynooth full resolution', 
                   norm=None)
```

The following is an other way to do the same.

Qubic soft has an option `external_A` in `get_response()`. So I tried to use this option by passing Maynooth results in `external_A` but it is not fully working for now. There is a small bug.

```{python}
scal.open_switches(q, open_horns)

external_A = scal.make_external_A(rep, open_horns)

xONAFP, yONAFP, power = scal.get_response_power(q,
                                              theta=0., phi=0.,
                                              nu=150e9, spectral_irradiance=1.,
                                              frame='ONAFP',
                                              external_A=external_A, hwp_position=0, 
                                              verbose=True)

plt.figure()
scal.scatter_plot_FP(q, xONAFP, yONAFP, power, s=100, 
                       frame='ONAFP', 
                       title='Maynooth full resolution', 
                       norm=None)
```

#### Get the fringes at TES resolution
To decrease the resolution, you can either make a real interpolation (`interp=True`) and then integrate or you can just make the mean inside each TES (`interp=False`). The second way is much faster.

```{python}
# baseline = [142, 230] # for the FI
baseline = [25, 57]     # for the TD

Model_Maynooth = scal.Model_Fringes_Maynooth(q, baseline, rep, 
                                             theta_source=0., nu_source=150e9,
                                             frame='ONAFP', interp=False)
```

```{python}
# Information are store in the object
print(Model_Maynooth.frame)
print(Model_Maynooth.nu_source)
print(Model_Maynooth.baseline)
```

```{python}
xONAFP, yONAFP, fringes = Model_Maynooth.get_fringes(verbose=True)

plt.figure()
scal.scatter_plot_FP(q, xONAFP, yONAFP, fringes, s=None, 
                       frame='ONAFP', 
                       title='Maynooth at TES resolution', 
                       norm=None)
```

#### Get the fringes at TES reso doing the combination

You can make the "true" combination or the measured one.

```{python}
xONAFP, yONAFP, fringes_comb = Model_Maynooth.get_fringes_from_combination(measured_comb=True, verbose=True)

plt.figure()
scal.scatter_plot_FP(q, xONAFP, yONAFP, fringes_comb, s=None, 
                   frame='ONAFP', 
                   title='Maynooth TES resolution', 
                   norm=None)
```

```{python}

```
