---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.16.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Importation

```{python}
import numpy as np
import matplotlib.pyplot as plt 
import healpy as hp
import yaml

import qubic
from qubic.lib.MapMaking.Qatmosphere_2d import AtmosphereMaps
from qubic.lib.Instrument.Qacquisition import QubicAcquisition
from qubic.lib.Instrument.Qinstrument import QubicInstrument
from qubic.lib.Qscene import QubicScene
from qubic.lib.Qsamplings import get_pointing, equ2gal

from qubic.lib.MapMaking.Qcg import PCGAlgorithm
from pyoperators.iterative.core import AbnormalStopIteration

from pyoperators import MPI, BlockDiagonalOperator, DiagonalOperator, ReshapeOperator

comm = MPI.COMM_WORLD
rank = comm.Get_rank()

# %matplotlib inline 
```

# Atm class

```{python}
# Import simulation parameters
with open('params.yml', 'r') as file:
    params = yaml.safe_load(file) 
```

```{python}
# Call the class which build the atmosphere maps
atm = AtmosphereMaps(params)
qubic_dict = atm.qubic_dict
```

```{python}
wv_fluctuations = atm.rho_map
print(wv_fluctuations.shape[0])
plt.imshow(wv_fluctuations, cmap='jet')
plt.title('Water vapor density fluctuations')
plt.colorbar(label=r'$g/m^{3}$')
```

```{python}
atm.frequencies
```

```{python}
temp_fluctuations = np.zeros((wv_fluctuations.shape[0], wv_fluctuations.shape[1], 3))
temp_fluctuations[..., 0] = atm.get_temp_maps(wv_fluctuations)[0]
temp_fluctuations[..., 0] -= np.mean(temp_fluctuations[:, 0])

plt.imshow(temp_fluctuations[..., 0], cmap='jet', extent=[-params['size_atm'], params['size_atm'], -params['size_atm'], params['size_atm']])
plt.title('Water vapor density fluctuations')
plt.xlabel('m')
plt.ylabel(('m'))
plt.colorbar(label=r'$g/m^{3}$')
```

```{python}
healpy_temp_fluctuations = np.zeros((hp.nside2npix(params['nside']), 3))
healpy_temp_fluctuations[..., 0] = atm.get_healpy_atm_maps_2d(atm.get_temp_maps(wv_fluctuations))[0]

index = np.where(healpy_temp_fluctuations!=0)[0]
healpy_temp_fluctuations[index, 0] -= np.mean(healpy_temp_fluctuations[index, 0])
min = np.min(healpy_temp_fluctuations[index, 0])
max = np.max(healpy_temp_fluctuations[index, 0])

hp.mollview(healpy_temp_fluctuations[..., 0], min=min, max=max, cmap='jet', title='Temperature fluctuations')
hp.gnomview(healpy_temp_fluctuations[..., 0], min=min, max=max, rot=equ2gal(0, -57), reso=15, cmap='jet', title='Temperature fluctuations')
```

```{python}
print('Angular speed', qubic_dict['angspeed'])
print('Delta azimtuh', qubic_dict['delta_az'])
print('Sweeps per elevation', qubic_dict['nsweeps_per_elevation'])
print('Angular speed psi', qubic_dict['angspeed_psi'])
print('Maximum psi', qubic_dict['maxppsi'])
print('latitude', qubic_dict['latitude'])
print('longitude', qubic_dict['longitude'])
print('Fix_azimuth', qubic_dict['fix_azimuth'])
print('period', qubic_dict['period'])
print('duration', qubic_dict['duration'])
print('Observation date', qubic_dict['date_obs'], type(qubic_dict['date_obs']))
```

# Scanning strategy

```{python}
### Random pointing
qubic_dict['random_pointing'] = False

### Sweepingpointing
qubic_dict['sweeping_pointing'] = True
qubic_dict['fix_azimuth']['apply'] = False 
qubic_dict['duration'] = 1
qubic_dict['period'] = 90
qubic_dict['nsweeps_per_elevation'] = 1

### Repeat pointing
qubic_dict['repeat_pointing'] = False

q_sampling = get_pointing(qubic_dict)
print(q_sampling)
```

```{python}
plt.plot(q_sampling.azimuth, q_sampling.elevation, 'o')
plt.xlabel('Azimuth (deg)')
plt.ylabel('Elevation (deg)')
```

```{python}
from pysimulators.interfaces.healpy import Spherical2HealpixOperator
from pysimulators import SphericalHorizontal2EquatorialOperator, SphericalEquatorial2GalacticOperator
from astropy.time import Time, TimeDelta

def _format_sphconv(a, b, date_obs=None, time=None):
    incoords = np.empty(np.broadcast(a, b).shape + (2,))
    incoords[..., 0] = a
    incoords[..., 1] = b
    if date_obs is None:
        return incoords
    time = Time(date_obs, scale='utc') + TimeDelta(time, format='sec')
    return incoords, time

incoords, time = _format_sphconv(q_sampling.azimuth, q_sampling.elevation, date_obs=qubic_dict['date_obs'], time=q_sampling.time)
h2e = SphericalHorizontal2EquatorialOperator(
        'NE', time, qubic_dict['latitude'], qubic_dict['longitude'], degrees=True)
e2g = SphericalEquatorial2GalacticOperator(degrees=True)
outcoords = e2g(h2e(incoords))
```

```{python}
test = np.zeros(hp.nside2npix(params['nside']))
azel = np.asarray([q_sampling.azimuth, q_sampling.elevation]).T
index = np.array(Spherical2HealpixOperator(params['nside'], 'azimuth, elevation')(np.radians(outcoords)), dtype='int')
test[index] = 1
print(len(index))
hp.mollview(test)
hp.gnomview(test, rot=equ2gal(0, -57), reso=15)
```

# Wind

```{python}
def random_wind(npointing, wind_mean, wind_std):
    wind_x = np.random.normal(wind_mean, wind_std, npointing)
    wind_y = np.random.normal(wind_mean, wind_std, npointing)
    
    return wind_x, wind_y

def constant_wind(npointing, wind_x, wind_y):
    ones = np.ones(npointing)
    return wind_x*ones, wind_y*ones

def random_wind_corrected(npointing, wind_mean, wind_std):
    
    wind_x = np.cumsum(np.random.normal(wind_mean, wind_std, npointing))
    wind_y = np.cumsum(np.random.normal(wind_mean, wind_std, npointing))
    
    return wind_x, wind_y
```

```{python}
wind_x, wind_y = random_wind_corrected(len(q_sampling.index), 0, 5)

plt.plot(wind_x, wind_y, '.')
```

```{python}
def azel_to_cartesian(azimuth, elevation, altitude):
    x = altitude / np.sin(elevation) * np.cos(elevation) * np.cos(azimuth)
    y = altitude / np.sin(elevation) * np.cos(elevation) * np.sin(azimuth)
    return x, y

def cartesian_to_azel(x, y ,altitude):
    r = np.sqrt(x**2 + y**2 + altitude**2)
    el = np.pi/2 - np.arccos(altitude/r)
    az = np.arctan2(y, x)
    return az, el
```

```{python}
x, y = azel_to_cartesian(np.radians(q_sampling.azimuth), np.radians(q_sampling.elevation), params['altitude_atm_2d'])
plt.plot(x, y, 'ok', label='Scanning Strategy', markersize=2)
plt.imshow(temp_fluctuations[..., 0], cmap='jet', extent=[-params['size_atm'], params['size_atm'], -params['size_atm'], params['size_atm']])
plt.title('Water vapor density fluctuations')
plt.xlabel('m')
plt.ylabel('m')
plt.legend()
# plt.xlim(-1100, -600)
# plt.ylim(-800, -200)
plt.colorbar(label=r'$g/m^{3}$')
```

```{python}
# Attention, il faut que j'ajoute le fait que le vent est en m/s, et qu'il y a du temps entre chaque point,
# pour pouvoir calculer correctement le décalage dû au vent

def get_deviation_index(position_x, position_y, wind_x, wind_y, delta_time):
    deviated_index_x = (np.round(wind_x) + np.round(position_x)).astype(int)
    deviated_index_y = (np.round(wind_y) + np.round(position_y)).astype(int)
    return deviated_index_x, deviated_index_y
delta_time = qubic_dict['duration']*3600/qubic_dict['period']
deviated_index_x, deviated_index_y = get_deviation_index(x, y, wind_x, wind_y, delta_time)
```

```{python}
plt.figure()
plt.plot(x, y, 'k', label='Scanning Strategy', markersize=2)
plt.plot(deviated_index_x, deviated_index_y, 'r', label='Deviated Scanning Strategy', markersize=2)
plt.imshow(temp_fluctuations[..., 0], cmap='jet', extent=[-params['size_atm'], params['size_atm'], -params['size_atm'], params['size_atm']])
plt.title('Water vapor density fluctuations')
plt.xlabel('m')
plt.ylabel('m')
plt.legend()
plt.colorbar(label=r'$g/m^{3}$')

plt.figure()
plt.plot(x, y, 'k', label='Scanning Strategy', markersize=2)
plt.plot(deviated_index_x, deviated_index_y, 'r', label='Deviated Scanning Strategy', markersize=2)
plt.imshow(temp_fluctuations[..., 0], cmap='jet', extent=[-params['size_atm'], params['size_atm'], -params['size_atm'], params['size_atm']])
plt.title('Water vapor density fluctuations - Zoom')
plt.xlabel('m')
plt.ylabel('m')
plt.xlim(-1100, -600)
plt.ylim(-800, -200)
plt.legend()
plt.colorbar(label=r'$g/m^{3}$')
```

```{python}
deviated_az, deviated_el = cartesian_to_azel(deviated_index_x, deviated_index_y, params['altitude_atm_2d'])

plt.plot(q_sampling.azimuth, q_sampling.elevation, 'k', label='original')
plt.plot(np.degrees(deviated_az%(2*np.pi)), np.degrees(deviated_el), 'r', label='deviated')
plt.xlabel('Azimuth (Degrees)')
plt.ylabel('Elevation (Degrees)')
plt.legend()
plt.show()
plt.title('Scanning Strategy')
```

```{python}
q_sampling_deviated = q_sampling.copy()
q_sampling_deviated.azimuth = np.degrees(deviated_az)
q_sampling_deviated.elevation = np.degrees(deviated_el)
```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}
stop
```

# Build MM

```{python}
q_instrument = QubicInstrument(qubic_dict)
q_scene = QubicScene(qubic_dict)

q_acquisition = QubicAcquisition(q_instrument, q_sampling, q_scene, qubic_dict)
```

```{python}
coverage = q_acquisition.get_coverage()

covnorm = coverage / coverage.max()
seenpix = covnorm > params['coverage_cut']

center = np.array([0, -57])
qubic_patch = qubic.lib.Qsamplings.equ2gal(center[0], center[1])
```

```{python}
hp.mollview(coverage)
hp.mollview(test)
hp.gnomview(coverage, rot=equ2gal(0, -57), reso=15, title='Coverage')
hp.gnomview(test, rot=equ2gal(0, -57), reso=15)
```

```{python}
H_qubic = q_acquisition.get_operator()
R_qubic = ReshapeOperator(H_qubic.shapeout, H_qubic.shape[0])
invN_qubic = R_qubic(q_acquisition.get_invntt_operator(False, False)(R_qubic.T))
d_qubic = H_qubic(healpy_temp_fluctuations).ravel()
```

```{python}
H = R_qubic(H_qubic)
invN = invN_qubic
d = d_qubic
```

```{python}
A = H.T * invN * H
b = H.T * invN * d.flatten()
x0 = healpy_temp_fluctuations*0
true_maps = healpy_temp_fluctuations
```

```{python}
stacked_dptdp_inv = np.zeros((1,12*params['nside']**2))

D = H.operands[2]
P = H.operands[-1]
sh = P.matrix.data.index.shape
no_det = 992
point_per_det = int(sh[0] / no_det)
mapPtP_perdet_seq = np.zeros((no_det, 12 * params['nside']**2))
sample_ranges = [(det * point_per_det, (det + 1) * point_per_det) for det in range(no_det)]
for det, (start, end) in enumerate(sample_ranges):
    indices = P.matrix.data.index[start:end, :]  
    weights = P.matrix.data.r11[start:end, :]
    flat_indices = indices.ravel()
    flat_weights = weights.ravel()

    mapPitPi = np.zeros(12 * params['nside']**2)
    np.add.at(mapPitPi, flat_indices, flat_weights**2)

    mapPtP_perdet_seq[det, :] = mapPitPi
D_elements = D.data
D_sq = D_elements**2
mapPtP_seq_scaled = D_sq[:, np.newaxis] * mapPtP_perdet_seq 
dptdp = mapPtP_seq_scaled.sum(axis = 0)
dptdp_inv = 1 / dptdp
dptdp_inv[np.isinf(dptdp_inv)] = 0.
stacked_dptdp_inv[0] = dptdp_inv
M = BlockDiagonalOperator( \
            [DiagonalOperator(ci, broadcast='rightward') for ci in stacked_dptdp_inv],
            new_axisin=0)
```

# Map-Making

```{python}
# Run PCG
algo = PCGAlgorithm(
    A,
    b,
    comm,
    x0=x0,
    tol=1e-10,
    maxiter=200,
    disp=True,
    M=M,
    center=[0, -57],
    reso=15,
    seenpix=seenpix,
    input=true_maps,
)
try:
    output = algo.run()
    success = True
    message = 'Success'
except AbnormalStopIteration as e:
    output = algo.finalize()
    success = False
    message = str(e)
```

```{python}
plt.plot(output['convergence'])
plt.yscale('log')
plt.xlabel('Iteration')
plt.ylabel('Convergence')
```

```{python}
plt.figure(figsize=(10, 12), dpi=200)
k=1
true_maps[~seenpix, :] = hp.UNSEEN
output['x'][~seenpix, :] = hp.UNSEEN

istk = 0
n_sig = 3

sigma = np.std(true_maps[seenpix, istk])
hp.gnomview(true_maps[:, istk], min=np.min(true_maps[seenpix, istk]), max=np.max(true_maps[seenpix, istk]), cmap='jet', rot=qubic_patch, reso=15, sub=(1, 3, k), title='Input', notext=True)
hp.gnomview(output['x'][:, istk], min=np.min(true_maps[seenpix, istk]), max=np.max(true_maps[seenpix, istk]), cmap='jet', rot=qubic_patch, reso=15, sub=(1, 3, k+1), title='Output', notext=True)
hp.gnomview(output['x'][:, istk] - true_maps[:, istk], cmap='jet', rot=qubic_patch, reso=15, sub=(1, 3, k+2), title='Residual', notext=True)
k+=3
```

```{python}
plt.figure(figsize=(12, 25))
k=1
true_maps[~seenpix, :] = hp.UNSEEN
output['x'][~seenpix, :] = hp.UNSEEN

istk = 0
n_sig = 3

sigma = np.std(true_maps[seenpix, istk])
hp.mollview(true_maps[:, istk], min=np.min(true_maps[seenpix, istk]), max=np.max(true_maps[seenpix, istk]), cmap='jet', sub=(1, 3, k), title='Input', notext=True)
hp.mollview(output['x'][:, istk], min=np.min(true_maps[seenpix, istk]), max=np.max(true_maps[seenpix, istk]), cmap='jet', sub=(1, 3, k+1), title='Output', notext=True)
hp.mollview(output['x'][:, istk] - true_maps[:, istk], cmap='jet', sub=(1, 3, k+2), title='Residual', notext=True)
k+=3
```

```{python}
plt.figure(figsize=(10, 12), dpi=200)
k=1
true_maps[~seenpix, :] = hp.UNSEEN
output['x'][~seenpix, :] = hp.UNSEEN

istk = 1
n_sig = 3

sigma = np.std(true_maps[seenpix, istk])
hp.gnomview(true_maps[:, istk], min=np.min(true_maps[seenpix, istk]), max=np.max(true_maps[seenpix, istk]), cmap='jet', rot=qubic_patch, reso=15, sub=(1, 3, k), title='Input', notext=True)
hp.gnomview(output['x'][:, istk], min=np.min(true_maps[seenpix, istk]), max=np.max(true_maps[seenpix, istk]), cmap='jet', rot=qubic_patch, reso=15, sub=(1, 3, k+1), title='Output', notext=True)
hp.gnomview(output['x'][:, istk] - true_maps[:, istk], cmap='jet', rot=qubic_patch, reso=15, sub=(1, 3, k+2), title='Residual', notext=True)
k+=3
```

```{python}

```
