---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.5.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Try to detect the CO line emission

```{python}
from __future__ import division, print_function
# %matplotlib inline
import os
import sys
import time
import datetime
import shutil

# Specific science modules
import healpy as hp
import numpy as np
import matplotlib.pyplot as plt

# Specific qubic modules
import qubic
from qubic.polyacquisition import compute_freq
from qubic import QubicSkySim as qss
from qubic import SpectroImLib as si
from pysm3 import COLines
rc('figure', figsize=(13, 10))
rc('font', size=13)
```

## Dictionary 

```{python}
d = qubic.qubicdict.qubicDict()
d.read_from_file('pipeline_demo.dict')

# Adapt the parameters
d['config'] = 'FI'

nside = 128
d['nside'] = nside

d['dtheta'] = 10

freq = 220 #GHz
d['filter_nu']= freq * 1e9

nf_sub = 25
d['nf_sub'] = nf_sub

d['MultiBand'] = True
nf_recon = 5
d['nf_recon'] = nf_recon

nptg = 1000
d['npointings'] = nptg

d['tol'] = 1e-4

# Galactic center
d['RA_center'] = 266.41 #deg
d['DEC_center'] = -28.94 #deg
center = qubic.equ2gal(d['RA_center'], d['DEC_center'])
```

## Make a sky

```{python}
# Make a sky using PYSM with only dust
sky_config = {'dust': 'd1'}
Qubic_sky = qss.Qubic_sky(sky_config, d)
dustsky = Qubic_sky.get_simple_sky_map()
print('Input Map with shape (nf_sub, #pixels, #stokes) : ', np.shape(dustsky))
```

### Make CO sky

```{python}
# Select the sub-band

CO21 = 230.5
Nfreq_edges, nus_edge, nus, deltas, Delta, Nbbands = compute_freq(freq, nf_sub)

def select_subband(nus_edge, CO21=230.5, doplot=True):
    if doplot:
        plt.figure(figsize=(8, 6))

    for i, ed in enumerate(nus_edge):
        if doplot:
            plt.axvline(ed, linestyle='--')
        if CO21 > ed and CO21< nus_edge[i+1]:
            COband = i
    if doplot:
        plt.axvline(CO21, color='r')
        plt.xlabel('f [GHz]')
        plt.axvline(nus[COband], color='g')
    print(f'CO line contained in sub-band {COband}.')
    return COband

COband = select_subband(nus_edge, CO21=230.5, doplot=True)
```

```{python}
co = COLines(target_nside=nside, output_units="uK_CMB", line="21")
#pysm_map += bandpass_weight * hp.smoothing(co.signal(), fwhm=fwhm)
COsky = np.zeros_like(dustsky)
COsky[COband, :, :]+= co.signal().T

dustCOsky = dustsky + COsky
```

```{python}
imap = COband
istk = 0
plt.figure(figsize=(13,8))
plt.subplots_adjust(wspace=0.9)
hp.mollview(dustsky[imap,:,istk], cmap='jet', sub=(1,3,1),
            title = 'Dust', min=0, max=1000)
hp.mollview(COsky[imap,:,istk], cmap='jet', sub=(1,3,2),
            title = 'CO', min=0, max=1000)
hp.mollview(dustCOsky[imap,:,istk], cmap ='jet', sub=(1,3,3),
            title = 'dust + CO', min=0, max=1000)
```

## Plot the SED

```{python}
# Convolve the input sky at the reso of the reconstructed sub-bands
_, nus_edge_rec, nus_rec, _, _, _ = compute_freq(freq, d['nf_recon'])
print(nus_rec)

p = qubic.get_pointing(d)
s = qubic.QubicScene(d)
q = qubic.QubicMultibandInstrument(d) 
arec = qubic.QubicMultibandAcquisition(q, p, s, d, nus_edge_rec)

_, dust_conv = arec.get_observation(dustsky, noiseless=d['noiseless'], convolution=True)
_, dustCO_conv = arec.get_observation(dustCOsky, noiseless=d['noiseless'], convolution=True)

dust_conv = np.array(dust_conv)
dustCO_conv = np.array(dustCO_conv)
```

```{python}
# Plot the SED of the input sky and input convolved sky

# Choose a pixel
lon = 10
lat = 0
pix = hp.ang2pix(d['nside'], lon, lat, lonlat=True)
print(pix)

istk = 0
fig, axs = plt.subplots(1, 2, figsize=(15, 6))
ax0, ax1 = axs.ravel()
ax0.plot(nus, dustCOsky[:, pix, istk], 'go-', label='Input sky')
#plt.plot(nus, maps_recon_CO[:, pix, istk], 'ro', label='Recon CO')
ax0.plot(nus_rec, dustCO_conv[:, pix, istk], 'bo-', label='Convolved')

ax0.legend()
ax0.set_title(f'Pixel at [{lon},{lat}], NSIDE={nside}')
ax0.set_xlabel('Frequency [GHz]')
ax0.set_ylabel('I (µK)')

hp.mollview(dustCOsky[COband, :, istk], sub=(1, 2, 2), min=0, max=2000, title='Pixel chosen')
hp.graticule(dpar=30, dmer=30)
ax1.axis('off')
hp.projplot(lon, lat, 'ro', lonlat=True)
```

### Try to decrease NSIDE

```{python}
nside_dg = 32
npix_dg = 12*nside_dg**2
dustCO_conv_dg = np.zeros((nf_recon, npix_dg, 3))
for i in range(nf_recon):
    for istk in range(3):
        dustCO_conv_dg[i, :, istk] = hp.ud_grade(dustCO_conv[i, :, istk], nside_dg)
        
dustCO_dg = np.zeros((nf_sub, npix_dg, 3))
for i in range(nf_sub):
    for istk in range(3):
        dustCO_dg[i, :, istk] = hp.ud_grade(dustCOsky[i, :, istk], nside_dg)
```

```{python}
lon = 10
lat = 0
pix = hp.ang2pix(nside_dg, lon, lat, lonlat=True)
print(pix)

istk = 0
fig, axs = plt.subplots(1, 2, figsize=(15, 6))
ax0, ax1 = axs.ravel()
ax0.plot(nus, dustCO_dg[:, pix, istk], 'go-', label='Input sky')
ax0.plot(nus_rec, dustCO_conv_dg[:, pix, istk], 'bo', label='Convolved')

ax0.legend(loc='upper left')
ax0.set_title(f'Pixel at [{lon},{lat}], NSIDE={nside_dg}')
ax0.set_xlabel('Frequency [GHz]')
ax0.set_ylabel('I (µK)')

hp.mollview(dustCO_dg[COband, :, istk], sub=(1, 2, 2), min=0, max=1000)
hp.graticule(dpar=30, dmer=30)
ax1.axis('off')
hp.projplot(lon, lat, 'ro', lonlat=True)

```

## Make TOD

```{python}
a = qubic.QubicMultibandAcquisition(q, p, s, d, nus_edge)

print('\n Starting TOD dust')
TOD_dust, _ = a.get_observation(dustsky, noiseless=d['noiseless'])

print('\n Starting TOD CO + dust')
TOD_dustCO, _ = a.get_observation(dustCOsky, noiseless=d['noiseless'])
```

## Coverage map

```{python}
cov = arec.get_coverage()
```

```{python}
hp.mollview(cov.sum(axis=0))
```

## Map-making

```{python}
# From TOD reconstruct sky maps.
print('\n ======== Starting map-making only dust ==========')
recon_dust, nit, error = arec.tod2map(TOD_dust, d, cov=cov)

print('\n ======== Starting map-making with CO ==========')
recon_dustCO, nit_dustCO, error_dustCO = arec.tod2map(TOD_dustCO, d, cov=cov)

print('The shape of the reconstructed maps is (nf_recon, #pixels, #stokes) :', recon_dust.shape)
print('{} iterations were needed to get an error of {}'.format(nit, error))
```

```{python}
hp.mollview(recon_dustCO[0, :, 0])
```

```{python}
# Compute the residuals
diff_dust = recon_dust - dust_conv
diff_dustCO = recon_dustCO - dustCO_conv
```

```{python}
# Keeping only the sky region which has been significantly observed
# Pixels not seen enough are replaced by UNSEEN value
cov = cov.sum(axis=0) #Sum over subbands
maxcov = np.max(cov)

unseen = cov < maxcov * 0.1
print(unseen)
dust_conv[:, unseen, :] = hp.UNSEEN
recon_dust[:, unseen, :] = hp.UNSEEN
diff_dust[:, unseen, :] = hp.UNSEEN

dustCO_conv[:, unseen, :] = hp.UNSEEN
recon_dustCO[:, unseen, :] = hp.UNSEEN
diff_dustCO[:, unseen, :] = hp.UNSEEN
```

```{python}
rr = 15 # Resolution in arcmin
ifreq = 0
for istokes in [0,1,2]:
    plt.figure(istokes,figsize=(12,12)) 
    hp.gnomview(dust_conv[ifreq, :,istokes], cmap='jet', rot=center, sub=(3,3,3*istokes+1), reso=rr,
                title='Input '+d['kind'][istokes]+' SubFreq {}'.format(ifreq))
    hp.gnomview(recon_dust[ifreq,:,istokes], cmap='jet',rot=center, sub=(3,3,3*istokes+2), reso=rr,
                title='Output '+d['kind'][istokes]+' SubFreq {}'.format(ifreq))
    hp.gnomview(diff_dust[ifreq,:,istokes], cmap='jet', rot=center, sub=(3,3,3*istokes+3), reso=rr,
                title='diff '+d['kind'][istokes]+' SubFreq {}'.format(ifreq))
plt.show()
```

## Compute the SED

### Dust + CO

```{python}
# Plot the SED of the input sky and input convolved sky

# Choose a pixel
lon = 3
lat = 0
pix = hp.ang2pix(d['nside'], lon, lat, lonlat=True)
print(pix)

istk = 0
fig, axs = plt.subplots(1, 2, figsize=(15, 6))
ax0, ax1 = axs.ravel()
ax0.plot(nus, dustCOsky[:, pix, istk], 'go-', label='Input sky')
ax0.plot(nus_rec, dustCO_conv[:, pix, istk], 'bo-', label='Convolved')
ax0.plot(nus_rec, recon_dustCO[:, pix, istk], 'ro-', label='Reconstruction')

ax0.legend()
ax0.set_title(f'Pixel at [{lon},{lat}], NSIDE={nside}')
ax0.set_xlabel('Frequency [GHz]')
ax0.set_ylabel('I (µK)')

hp.mollview(dustCOsky[COband, :, istk], sub=(1, 2, 2), min=0, max=2000, title='Pixel chosen')
hp.graticule(dpar=30, dmer=30)
ax1.axis('off')
hp.projplot(lon, lat, 'ro', lonlat=True)
```

### Only dust

```{python}
# Choose a pixel
lon = 0
lat = 0
pix = hp.ang2pix(d['nside'], lon, lat, lonlat=True)
print(pix)

istk = 0
fig, axs = plt.subplots(1, 2, figsize=(15, 6))
ax0, ax1 = axs.ravel()
ax0.plot(nus, dustsky[:, pix, istk], 'go-', label='Input sky')
ax0.plot(nus_rec, dust_conv[:, pix, istk], 'bo-', label='Convolved')
ax0.plot(nus_rec, recon_dust[:, pix, istk], 'ro-', label='Reconstruction')

ax0.legend()
ax0.set_title(f'Pixel at [{lon},{lat}], NSIDE={nside}')
ax0.set_xlabel('Frequency [GHz]')
ax0.set_ylabel('I (µK)')

hp.mollview(dustCOsky[COband, :, istk], sub=(1, 2, 2), min=0, max=2000, title='Pixel chosen')
hp.graticule(dpar=30, dmer=30)
ax1.axis('off')
hp.projplot(lon, lat, 'ro', lonlat=True)
```

```{python}
plt.figure()
plt.title('Sum over pixels')
plt.plot(nus_rec, np.sum(recon_dustCO[:, pix, 0], axis=1), 'ro', label='Recon with CO')
#plt.plot(nus_rec, np.sum(maps_recon[:, pix_indices, 0], axis=1), 'go', label='Recon no CO')
plt.axvline(CO21, color='k', label='CO-21')
plt.xlabel('Frequency [GHz]')
plt.ylabel('I (µK)')
plt.grid()
plt.legend()
```

```{python}

```

```{python}

```
