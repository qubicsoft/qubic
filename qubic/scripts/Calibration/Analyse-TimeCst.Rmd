---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.1.0
  kernelspec:
    display_name: Python [default]
    language: python
    name: python2
---

```{python}
# #%matplotlib notebook
# %matplotlib inline
from matplotlib import rc
rc('figure',figsize=(15, 8))
rc('font',size=12)
rc('text',usetex=False)

from qubicpack import qubicpack as qp
import fibtools as ft
import plotters as p
import lin_lib as ll
import demodulation_lib as dl
import satorchipy as stpy
from pysimulators import FitsArray

import numpy as np
from matplotlib.pyplot import *
import matplotlib.mlab as mlab
import scipy.ndimage.filters as f
import glob
import string
import scipy.signal as scsig
from scipy import interpolate
import datetime as dt
import pickle

```

```{python}
files = glob.glob('/Users/hamilton/Qubic/Calib-TD/TimeConstants/TimeCst*_data.txt')
label = []
voltage = np.zeros(len(files))
fmod = np.zeros(len(files))
amp = np.zeros(len(files))
offset = np.zeros(len(files))
dutycycle = np.zeros(len(files))
for i in range(len(files)):
    d = files[i]
    bla = str.split(d,'_')
    print(bla)
    label.append(bla[3])
    voltage[i] = bla[4][0]
    fmod[i] = bla[6]
    amp[i] = bla[9]
    offset[i] = bla[11]
    dutycycle[i] = bla[13]
print(voltage)
print(fmod)
print(amp)
print(offset)
print(dutycycle)
```

```{python}
nv = len(files)
alldata = np.zeros((nv, 256, 6))
for i in range(nv):
    alldata[i,:,:] = np.loadtxt(files[i])[:,1:]
ok = (np.sum(alldata[:,:,0], axis=0) != 0)
print(ok.sum()*1./256*100)
```

```{python}
mean_rise = np.zeros(nv)
sig_rise = np.zeros(nv)
mean_fall = np.zeros(nv)
sig_fall = np.zeros(nv)
mean_relative_amp = np.zeros(nv)
sig_relative_amp = np.zeros(nv)
for i in range(nv):
    thisok = alldata[i,:,1] != 0
    mean_rise[i], sig_rise[i] = ft.meancut(alldata[i,thisok,0],3)
    sig_rise[i] /= np.sqrt(thisok.sum())
    mean_fall[i], sig_fall[i] = ft.meancut(alldata[i,thisok,2],3)
    sig_fall[i] /= np.sqrt(thisok.sum())
    ratio = alldata[i,thisok,4]/np.mean(alldata[0,thisok,4])
    mean_relative_amp[i], sig_relative_amp[i] = ft.meancut(ratio[isfinite(ratio)],3)
    sig_relative_amp[i] /= np.sqrt(thisok.sum())

```

```{python}
subplot(1,2,1)
errorbar(voltage, mean_rise, yerr=sig_rise,fmt='ro', label='Rise Time')
errorbar(voltage, mean_fall, yerr=sig_fall,fmt='bo', label='Fall Time')
# for i in range(256):
#     if np.product(alldata[:,i,0] != 0):
#         plot(voltage, alldata[:,i,0], 'r', alpha=0.1)
#     if np.product(alldata[:,i,2] != 0):
#         plot(voltage, alldata[:,i,2], 'b', alpha=0.1)
ylabel('Average Fall/Rise Time [sec]')
xlabel('TES Bias [V]')
legend()
ylim(0,0.25)

subplot(1,2,2)
errorbar(voltage, mean_relative_amp, yerr=sig_relative_amp,fmt='go', label='Relative Amplitude')
# for i in range(256):
#     if np.product(alldata[:,i,4] != 0):
#         plot(voltage, alldata[:,i,4] / np.mean(alldata[0,:,4]), 'g', alpha=0.1)
ylabel('Relative Amplitude')
xlabel('TES Bias [V]')
legend()
ylim(0,1.5)
```

<!-- #region -->
From https://kicp-workshops.uchicago.edu/CMB-School/resources/depot/benson__2.pdf I find:


The power on a TES is the sum of the optical power $P_{opt}$ and the electrical power $P_{elec}=V^2/R$.
When the TES receives radiation itheats up and its resistance increases, this reduces the electrical power and tends to maintain the total power constant. This speeds-up the TES as it helps it going back to a lower power when illuminated.

The speedup is:
$$\tau(\mathcal{L}) = \frac{\tau_0}{1+\mathcal{L}}$$
where $\mathcal{L}$ is the ETF loop-gain:
$$\mathcal{L} = \frac{P_{elec}\alpha}{GT}$$
and $\alpha$ is the the TES gain:
$$\alpha = \frac{T}{R}\frac{dR}{dT}$$

Finally the time constant scales as:
\begin{eqnarray}
\tau(\mathcal{L}) &=& \frac{\tau_0}{1+\mathcal{L}} \\\
&=& \frac{\tau_0}{1+\frac{P_{elec}\alpha}{GT}} \\\
&=& \frac{\tau_0}{1+\frac{V^2\alpha}{GTR}}
\end{eqnarray}

So we can fit its evolution with bias as:
$$\tau(V) =  \frac{\tau_0}{1+kV^2}$$

The response of the TES scales as:
$$S_I = \frac{-1}{V}\frac{\mathcal{L}}{1+\mathcal{L}} \sim \frac{-1}{V}$$
because $\mathcal{L}$ is large.

### NB: Of course, all the above is only true in the ETF mode, which is not quite the case now... So the fitting here is a bit meaningless in reality...###
<!-- #endregion -->

```{python}
def tau(x, pars, extra_args=None):
    return pars[0]/(1+pars[1]*x**2)

guess = [1., 1.]
fitrise = ft.do_minuit(voltage, mean_rise, sig_rise, guess, functname=tau,
        force_chi2_ndf=False, verbose=False, print_level=0,nsplit=3)

guess = [1., 1.]
fitfall = ft.do_minuit(voltage, mean_fall, sig_fall, guess, functname=tau,
        force_chi2_ndf=False, verbose=False, print_level=0,nsplit=3)


vvv=np.linspace(0,6,100)
errorbar(voltage, mean_rise, yerr=sig_rise,fmt='ro', label='Rise Time')
plot(vvv, tau(vvv, fitrise[1]), 'r',lw=2, 
     label=r'Fit $\tau_0$={0:5.3f} +/- {1:5.3f} s ; k = {2:5.3f} +/- {3:5.3f} $/V^2$'.format(fitrise[1][0], fitrise[2][0], 
                                                                   fitrise[1][1], fitrise[2][1]))
errorbar(voltage, mean_fall, yerr=sig_fall,fmt='bo', label='Fall Time')
plot(vvv, tau(vvv, fitfall[1]), 'b',lw=2, 
     label=r'Fit $\tau_0$={0:5.3f} +/- {1:5.3f} ; k = {2:5.3f} +/- {3:5.3f} V'.format(fitfall[1][0], fitfall[2][0], 
                                                                   fitfall[1][1], fitfall[2][1]))
ylabel('Average Fall/Rise Time [sec]')
xlabel('TES Bias [V]')
legend()

```

```{python}
def response(x, pars, extra_args=None):
    return pars[0]/x

guess = [1.]
fitamp = ft.do_minuit(voltage, mean_relative_amp, sig_relative_amp, guess, functname=response,
        force_chi2_ndf=False, verbose=False, print_level=0,nsplit=3)



vvv=np.linspace(0.9,6,100)
errorbar(voltage, mean_relative_amp, yerr=sig_relative_amp,fmt='go', label='Relative Amplitude')
plot(vvv, response(vvv, fitamp[1]), 'g',lw=2, 
     label=r'Fit $V_0$={0:5.3f} +/- {1:5.3f} V'.format(fitamp[1][0], fitamp[2][0]))
ylabel('Relative amplitude')
xlabel('TES Bias [V]')
legend()
#yscale('log')

```

### Looking amplitudes individually


```{python}
TESNum = 95
good = alldata[:,TESNum-1,4] != 0
errorbar(voltage[good],alldata[good,TESNum-1,4],yerr=alldata[good,TESNum-1,5],fmt='ro-')
print(alldata[:,TESNum-1,4])
```

```{python}

```
