---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.15.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

Tutorial to calculate the time samples of the flux jumps using the script jumps_functions.py

```{python}
import numpy as np
from qubicpack.qubicfp import qubicfp
import sys,os
import numpy as np
import glob

from qubic import fibtools as ft

import matplotlib.pyplot as plt
from pysimulators import FitsArray

from qubic import fibtools as ft
from qubic.plotters import *
from qubicpack.qubicfp import qubicfp
import qubic.demodulation_lib as dl
import qubic.sb_fitting as sbfit
from qubic.io import write_map

import matplotlib.mlab as mlab
import scipy.ndimage.filters as f

from scipy.signal import argrelextrema, find_peaks, find_peaks_cwt, savgol_filter 

import bottleneck as bn
from sklearn.cluster import DBSCAN
```

```{python}
import jumps_functions
```

Choose a dataset and read it (sky dip example)

```{python}
day = '2023-04-18'
data_dir = '/home/qubic/Calib-TD/'+day+'/'
words = ['skydip']
keywords = ['*{}*'.format(word) for word in words]
for keyword in keywords:
    dirs = np.sort(glob.glob(data_dir+keyword))
    print(dirs)
```

```{python}
if len(dirs)==1: 
    dataset0 = dirs[0]
    a = qubicfp()
    a.read_qubicstudio_dataset(dataset0)


else: 
    for ifile in range(len(dirs)):
        thedir = dirs[ifile]
        print('================', thedir,)
        locals()['qfp_{}'.format(ifile)] = qubicfp()
        locals()['qfp_{}'.format(ifile)].read_qubicstudio_dataset(thedir)
        locals()['tod_{}'.format(ifile)] = locals()['qfp_{}'.format(ifile)].tod()
```

```{python}
tod = a.tod()
timeaxis = tod[0]
todarray = tod[1]


```

```{python}
init = timeaxis[0]
tt = timeaxis - init
```

"Saturation" is a function that will give you the TES saturated, we are going to discard most of them, but can be used to study the flux jumps

```{python}
ok, bad_idx, frac, number = jumps_functions.saturation(todarray)

```

```{python}
print('number of TES saturated in the focal plane:', number)
```

```{python}
print('index TES saturated:')
print(bad_idx)
```

```{python}
TES_saved = (frac < 0.1) & (frac >0.)
TES_number = np.arange(256)
index_TES_saved = TES_number[TES_saved]
print('TES with saturation less than 10% and the signal can be saved')
print(index_TES_saved)
```

We can find the jumps in the TES with not so much saturation

The function 'jumps_detection' gives the number (nc) of flux jumps in a given TES, the time samples of the beginning of these jumps (xc) and the time samples of the end of the flux jumps (xcf)

```{python}
for i in range(len(index_TES_saved)):
    idx_good = index_TES_saved[i]
    print('Analisis TES', idx_good)
    locals()['nc_{}'.format(idx_good)], locals()['xc_{}'.format(idx_good)],  locals()['xcf_{}'.format(idx_good)],  locals()['delta_{}'.format(idx_good)]=jumps_functions.jumps_detection(todarray[idx_good])
```

```{python}
plt.plot(tt, todarray[102])
plt.plot(tt[xc_102], todarray[102][xc_102], 'r.', label='beginning of the jumps')
plt.plot(tt[xcf_102], todarray[102][xcf_102], 'g.', label='end of the jumps')
plt.title('TES 103')
plt.legend()
```

```{python}
plt.plot(tt, todarray[187])
plt.plot(tt[xc_187], todarray[187][xc_187], 'r.', label='beginning of the jumps')
plt.plot(tt[xcf_187], todarray[187][xcf_187], 'g.', label='end of the jumps')
plt.title('TES 188')
plt.legend()
```

(optional) We can calculate the offset of the jumps detected. Not all of the jumps detected are real flux jumps, so seeing the amplitude can give an idea of the false jump

```{python}
for i in range(len(index_TES_saved)):
    index = index_TES_saved[i]
    tod = todarray[index]
    if index != 20:
        locals()['off_lin_{}'.format(index)], locals()['off_pol_{}'.format(index)] = jumps_functions.offset_funct(tt, tod, locals()['xc_{}'.format(index)], locals()['xcf_{}'.format(index)], locals()['nc_{}'.format(index)])
  
```

```{python}
for i in range(len(index_TES_saved)):
    index = index_TES_saved[i]
    if index != 20:
        print('TES', index)
        number = locals()['nc_{}'.format(index)]
        for i in range(number):
            print('offset jump %s: %.2f' % (i, abs(locals()['off_lin_{}'.format(index)][i])))
            #print('offset lineal jump', i, locals()['off_lin_{}'.format(index)][])
```

```{python}

```

Now we can continue with the other TES with no saturation and see if they have flux jumps

```{python}
print('index TES with no saturation:')
good_tod = np.array(np.where(ok==True))
good_tod = np.reshape(good_tod, (good_tod.shape[1]))
print(good_tod)
```

```{python}
for i in range(len(good_tod)):
    idx_good = good_tod[i]
    print('Analisis TES', idx_good)
    locals()['nc_{}'.format(idx_good)], locals()['xc_{}'.format(idx_good)],  locals()['xcf_{}'.format(idx_good)],  locals()['delta_{}'.format(idx_good)]=jumps_functions.jumps_detection(todarray[idx_good])
```

```{python}
TES_jump = np.ones(len(good_tod), dtype=int)
for i in range(len(good_tod)):
    idx = good_tod[i]   
    result = locals()['nc_{}'.format(idx)]
    if result == 0.:
        TES_jump[i] = 0 
        
TES_yes = np.array(np.where(TES_jump==1))
TES_yes = good_tod[TES_yes]
TES_no = np.array(np.where(TES_jump==0))
TES_no = good_tod[TES_no]
```

```{python}
print('index of TES with candidates to flux jumps detected:')
print(TES_yes)
```

```{python}
TES_yes = np.reshape(TES_yes, TES_yes.shape[1])
TES_no = np.reshape(TES_no, TES_no.shape[1])
```

```{python}
len(TES_yes)
```

We have 116 TES with flux jumps detected, but if we plot some of them we can see that many of them are not real flux jumps (confused by the data itself)

```{python}

```

```{python}
plt.plot(tt, todarray[206])
plt.plot(tt[xc_206], todarray[206][xc_206], 'r.')
plt.plot(tt[xcf_206], todarray[206][xcf_206], 'g.')
```

```{python}
plt.plot(tt, todarray[140])
plt.plot(tt[xc_140], todarray[140][xc_140], 'r.')
plt.plot(tt[xcf_140], todarray[140][xcf_140], 'g.')
```

```{python}
plt.plot(tt, todarray[103])
plt.plot(tt[xc_103], todarray[103][xc_103], 'r.')
plt.plot(tt[xcf_103], todarray[103][xcf_103], 'g.')
```

```{python}
xc_119
```

```{python}
plt.plot(tt, todarray[58])
plt.plot(tt[xc_58], todarray[58][xc_58], 'r.')
plt.plot(tt[xcf_58], todarray[58][xcf_58], 'g.')
```

```{python}
plt.plot(tt, todarray[54])
plt.plot(tt[xc_54], todarray[54][xc_54], 'r.')
plt.plot(tt[xcf_54], todarray[54][xcf_54], 'g.')
```

```{python}
plt.plot(tt, todarray[19])
plt.plot(tt[xc_19], todarray[19][xc_19], 'r.')
plt.plot(tt[xcf_19], todarray[19][xcf_19], 'g.')
```

```{python}
plt.plot(tt, todarray[15])
plt.plot(tt[xc_15], todarray[15][xc_15], 'r.')
plt.plot(tt[xcf_15], todarray[15][xcf_15], 'g.')
```

Apply discrimination functions that can estimate if it's a real jump or not: 

- Threshold to the size of a jump (very tiny jumps are probably not jumps)
- Take a region near the jump detected and analyze the derivation, the derivative of a peak won't change a lot as the derivative of a jump (in general it's deeper). Here we made an iteration over many characteristic thresholds in the derivative 

```{python}
thr_deriv = np.array([4000,3000,2500, 2300, 1800])
idx_real = np.zeros(len(TES_yes), dtype=int)
for i in range(len(TES_yes)):
    index = TES_yes[i]
    tod = todarray[index] 
    nc_old = locals()['nc_{}'.format(index)]
    xc_old = locals()['xc_{}'.format(index)]
    xcf_old = locals()['xcf_{}'.format(index)]
    delta = locals()['delta_{}'.format(index)]
    locals()['nc_new_{}'.format(index)], locals()['xc_new_{}'.format(index)], locals()['xcf_new_{}'.format(index)] = jumps_functions.redefine_jumps(tt, nc_old, xc_old, xcf_old, delta)
    
    nc_new = locals()['nc_new_{}'.format(index)]    
    xc_new = locals()['xc_new_{}'.format(index)]
    xcf_new = locals()['xcf_new_{}'.format(index)]
    
    for j in range(nc_new):            
        time_portion, tod_portion, smooth_tod, deriv_tod = jumps_functions.derivation(tt, tod, xc_new[j], xcf_new[j], region=10)
        for k in range(len(thr_deriv)):
            if max(abs(deriv_tod)) > thr_deriv[k]:
                idx_real[i] = 1
```

```{python}
tes_real_jump = TES_yes[idx_real==1]
tes_no_jump = TES_yes[idx_real == 0]
```

```{python}
TES_yesjumps = tes_real_jump
```

```{python}
TES_yesjumps  #these are probably the TES with real flux jumps. The only one detected as jumps is TES 90
```

```{python}
for i in TES_yesjumps:
    plt.plot(tt, todarray[i])
    #plt.legend()
```

```{python}
# %matplotlib notebook
```

```{python}
plt.plot(tt, todarray[90])
plt.plot(tt[xc_new_90], todarray[90][xc_new_90], 'r.')
plt.plot(tt[xcf_new_90], todarray[90][xcf_new_90], 'g.')
```

```{python}
tes_no_jump
```

```{python}
for i in tes_no_jump:
    plt.plot(tt, todarray[i])
    #plt.legend()
```

Whit all these functions, I'm detecting in general all the flux jumps but I'm losing only one in the TES (140). Also I'm confusing only one TES with no real flux jumps (TES 90)


This pipeline so far works very well. In the future I think is important to study the amplitude of the real flux jumps (already detected) in order to see a pattern and help the detection function.

Also I think it can be used to train a Machine learning algorithm like a Decision Tree

```{python}
for i in TES_yesjumps:
    tod = todarray[i]    
    locals()['off_lin_{}'.format(i)], locals()['off_pol_{}'.format(i)] = jumps_functions.offset_funct(tt, tod, locals()['xc_new_{}'.format(i)], locals()['xcf_new_{}'.format(i)], locals()['nc_new_{}'.format(i)])
  
```

```{python}
for i in index_TES_saved:
    if i!=20:
        plt.plot(abs(locals()['off_lin_{}'.format(i)]), marker='s', label='TES_{}'.format(i))
        plt.legend()
```

```{python}
for i in TES_yesjumps:
    if i!=254:
        plt.plot(abs(locals()['off_lin_{}'.format(i)]), marker='s', label='TES_{}'.format(i))
        plt.legend()
```

```{python}

```
