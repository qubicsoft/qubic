---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

## Fit the fringe measurements

```{python}
from __future__ import division, print_function

# %matplotlib inline
import matplotlib
matplotlib.use('nbagg')

import glob
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as sop
import pandas as pd
from matplotlib.backends.backend_pdf import PdfPages
import scipy.optimize as sop

import qubic
from qubic import selfcal_lib as scal
from qubicpack.utilities import Qubic_DataDir
from qubic import fringes_lib as fl

import qubic.fibtools as ft
```

## Get the measurement

```{python}
global_dir = '/home/lmousset/QUBIC/Qubic_work/Calibration/datas/Fringes/'
myfringes = 'Fringes_2020-10-27_TypeEq0_with_10BLs.fits'
#'Fringes_2020-10-27_TypeEq2_with_2BLs.fits'

header, fdict = fl.read_fits_fringes(global_dir + myfringes)
print(fdict.keys())

nBLs = header['NBLS']
BLs_eq = fdict['BLS-EQ']
print(BLs_eq)
```

```{python}
# Make a QUBIC instrument
basedir = Qubic_DataDir(datafile='instrument.py', )
dictfilename = basedir + '/dicts/global_source_oneDet.dict'
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictfilename)
q = qubic.QubicInstrument(d)


# Horn array with all baselines
plt.figure(figsize=(6, 6))
scal.plot_horns(q)
for i in range(nBLs):
    scal.plot_baseline(q, BLs_eq[i])

# Plot fringes on the FP
BL_index = 0
fl.plot_fringes_onFP(q, BL_index, header, fdict)

# Plot folded signal and the fit for one TES 
TES = 95
fl.plot_folded_fit(TES, BL_index, header, fdict)

```

## Fringes models

```{python}
baseline = fdict['BLS-EQ'][BL_index]
print(baseline)
```

### QUBIC soft simulation

```{python}
Model_QS = scal.Model_Fringes_QubicSoft(q, baseline,
                                        theta_source=np.array([0.]), phi_source=np.array([0.]),
                                        nu_source=150e9, spec_irrad_source=1.,
                                        frame='ONAFP',)

rc('figure', figsize=(12, 6))
xONAFP, yONAFP, fringes = Model_QS.get_fringes(doplot=True, verbose=True, norm=None, s=100)

print('fringes shape:', fringes.shape)
```

### Maynooth simu

```{python}
# Path to the simulated files 
rep = Qubic_DataDir(datafile='detcentres.txt', datadir='/home/lmousset/QUBIC/')
print('rep:', rep)

Model_Maynooth = scal.Model_Fringes_Maynooth(q, baseline, rep, 
                                             theta_source=np.array([0.]), nu_source=150e9,
                                             frame='ONAFP', interp=False)

xONAFP, yONAFP, fringes = Model_Maynooth.get_fringes(verbose=True)

plt.figure()
scal.scatter_plot_FP(q, xONAFP, yONAFP, fringes, s=None, 
                       frame='ONAFP', 
                       title='Maynooth at TES resolution', 
                       norm=None)
```

### Analytical function

```{python}
theta_deg = 0.
Model_Ana = scal.Model_Fringes_Ana(q, baseline, theta_source=np.deg2rad(theta_deg), nu_source=150e9, fwhm=20., amp=1., frame='ONAFP')
print(Model_Ana.focal)

xONAFP, yONAFP, fringes = Model_Ana.get_fringes(times_gaussian=True)

plt.figure()
scal.scatter_plot_FP(q, xONAFP, yONAFP, fringes, frame='ONAFP')

```

```{python}
def get_fit_model(params, model, **kwargs):
    focal, theta_source = params
    
    model.q.optics.focal_length = focal
    model.theta_source = theta_source
    
    x, y, fringes = model.get_fringes(**kwargs)
    
    return x, y, fringes


def get_chi2(params, model, invcov, data, **kwargs):
    
    x, y, M = get_fit_model(params, model, **kwargs)
    
    ndet = len(data)
    chi2 = 0.
    for idet in range(ndet):
        # Amplitude factor (linear so we can compute it analitically)
        sigma_A = 1 / (M[idet].T @ invcov @ M[idet])
        A = sigma_A * M[idet].T @ invcov @ data[idet]
    
        R = A * M[idet] - data[idet]
        chi2 += R.T @ invcov @ R  
    return chi2
    
```

```{python}
np.array([1, 2, 3])* np.array([5, 5, 5])
```

```{python}
# Analytical function
def sim_fringe(param):
    Amp = param[0]
    focal = param[1]
    phase = param[2]
    alpha = param[3]
        
    yc = 0.
    xc = 0. 
    
    nu = 150.e9
    lam = 3.e8/nu
    alpha_rad = np.deg2rad(alpha)
    
    det_dist = 3e-3
    baseline = 14.e-3*4.
    
    ndet = 17
    fringe = np.zeros((ndet, ndet))
    i, j = np.mgrid[0:ndet, 0:ndet]
    
    w = 40.87e-3 # From Creidhe
    #w=np.sqrt(2*(12.9*np.pi/180*f/2.355)**2)
    
    gaussian = np.exp(-((16-i+xc)**2 + (j-yc)**2) * det_dist**2 / (w**2))
    xprime = (i * np.cos(alpha_rad) + j * np.sin(alpha_rad)) * det_dist
    interfrange = lam * focal / baseline
    fringe = Amp * np.cos((2. * np.pi / interfrange * xprime) + phase)# * gaussian
    
    return fringe

def sim_fringe_flat(param):
    fff = sim_fringe(param)
    return fff.ravel()

def sim_fringe_flat2(param):
    fff = sim_fringe(param)
    res = np.zeros(256)
    for xx in range(17):
        for yy in range(17):
            TESNum=int(tes_grid[xx,yy])
            AsicNum = int(10.*(tes_grid[xx,yy]-TESNum))+1
            TESindex = (TESNum-1) + 128 *(AsicNum -1)
            res[TESindex] = fff[xx,yy]
    return res

def compute_residuals(param, observation):
    """
    Return array: observation - model
    """
    model = sim_fringe_flat(param)
    err = 2000
    residual = (observation - model) / err
    print("residual: ", np.nansum(residual**2))
    
    return residual.astype(np.float64)
```

```{python}
param = [13e3, 300e-3, 0., -45.]#,40.87e-3]#,0.]
lim = 1e4
plt.imshow(sim_fringe(param), vmin=-lim, vmax=lim)

# Fit the measurement with the analytical model
param_guess = [13e3, 300e-3, 0, -50.]

tofit = (fringe).ravel()
tofit[np.isnan(tofit)] = 0.

param_est, cov_x, infodict, mesg_result, ret_value = sop.leastsq(compute_residuals, 
                                                                 param_guess, 
                                                                 args=(tofit.astype(np.float64)),
                                                                 full_output=True, 
                                                                 maxfev=10000, 
                                                                 epsfcn=np.finfo(np.float32).eps)

sigma_param_est = np.sqrt(np.diagonal(cov_x))

print("Return value:", ret_value)
print("Return message:", mesg_result)

if ret_value not in (1, 2, 3, 4):
    raise RuntimeError(mesg_result)

print("guess    :", param_guess)
print("solution :", param_est)
print("Error :", sigma_param_est)
print("Precision (%):",sigma_param_est/param_est*100)

```

```{python}
rcParams["image.cmap"]='viridis'

lim = 3
plt.figure()
plt.subplots_adjust(wspace=0.5)
plt.subplot(131)
plt.imshow(sim_fringe(param_est), vmin=-lim, vmax=lim)

plt.subplot(132)
imshow(fringe, vmin=-lim, vmax=lim)
# plt.colorbar()

maskresp = np.abs(fringe / sim_fringe(param_est))

plt.subplot(133)
imshow(maskresp)#, vmin=0, vmax=1)#,interpolation='bicubic')
plt.colorbar()
```

# Fit with the simulation

```{python}
def compute_diff(param, q, baseline, files, labels, observation):
    """
    Return array: observation - model
    """
    model = sc.get_simulation(param, q, baseline, files, labels, doplot=False, verbose=False)
    err = 200
    residual = (observation - np.ravel(model)) / err
    residual[np.isnan(residual)] = 0.
    print('param :', param)
    print("residual sum: ", np.nansum(residual**2))
    
    return residual.astype(np.float64)
```

```{python}
# Prepare the simulation
# Get a dictionary
basedir = Qubic_DataDir(datafile='instrument.py', ) 
print('basedir : ', basedir)
dictfilename = basedir + '/dicts/global_source_oneDet.dict'

d = qubic.qubicdict.qubicDict()
d.read_from_file(dictfilename)

# Path to the simulated files 
rep = Qubic_DataDir(datafile='detcentres.txt')
print('rep:', rep)

# Get simulation files
files = sorted(glob.glob(rep + '/*.dat'))

# Get the sample number from the first file
data0 = pd.read_csv(files[0], sep='\t', skiprows=0)
nn = data0['X_Index'].iloc[-1] + 1
print('Sampling number = {}'.format(nn))

# Make an instrument
baseline = [52, 28]
q = qubic.QubicInstrument(d)
q.horn.open = False
q.horn.open[np.asarray(baseline) - 1] = True

# Make labels
readv, labels = sc.make_labels(rep)
print(files)

```

```{python}
# Make a simulation
param = [0., 150.]
img = sc.get_simulation(param, q, baseline, files, labels, doplot=True)

residual = compute_diff(param, q, baseline, files, labels, np.ravel(fringe))

plt.figure()
plt.hist(residual)
```

```{python}
# Fit
param_guess = [0., 150.]

tofit = np.ravel(fringe)
tofit[np.isnan(tofit)] = 0.
tofit = tofit.astype(np.float64)

# Method 1
# param_est, cov_x, infodict, mesg, flag  = sop.leastsq(compute_diff, 
#                      param_guess,
#                      args=(q, baseline, files, labels, tofit),
#                      factor=1.,
#                      full_output=True,
#                      epsfcn=np.finfo(np.float32).eps)
# sigma_param_est = np.sqrt(np.diagonal(cov_x))

# print('====================== FIT DONE ==========================')
# print("Return value:", param_est)
# print('Flag', flag)
# print("Return message:", mesg)
# print("Error :", sigma_param_est)
# print("Precision (%):", sigma_param_est / param_est * 100)

# Method 2
myfit = sop.least_squares(compute_diff,
                         param_guess,
                         args=(q, baseline, files, labels, tofit),
#                          method='lm',
                         bounds=([-30., 30.], [130., 170.]),
                         ftol=1e-9)

print('====================== FIT DONE ==========================')
print('Estimation:', myfit.x)
print('Cost:', myfit.cost)
# print('Residuals:', myfit.fun)
print('Cost fct gradient:', myfit.grad)
print('Message:', myfit.message)
print('Success:', myfit.success)
```

```{python}
thefit = sc.get_simulation(myfit.x, q, baseline, files, labels, doplot=True)
```

```{python}

```
