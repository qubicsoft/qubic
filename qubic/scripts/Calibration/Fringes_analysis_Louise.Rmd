---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Fringes measurement analysis

```{python}
from __future__ import division, print_function

import glob
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# %matplotlib notebook
# %matplotlib inline
from matplotlib import rc
rc('figure',figsize=(9, 4.5))
rc('font',size=12)
rc('text',usetex=False)

from qubic import selfcal_lib as sc
from qubicpack.utilities import Qubic_DataDir
import qubic

from qubicpack import qubicpack as qp
from qubicpack.qubicfp import qubicfp
import qubic.fibtools as ft

from pysimulators import FitsArray

import scipy.ndimage.filters as f
from scipy.ndimage.filters import gaussian_filter1d
import scipy.optimize as spo
import string

from importlib import reload

from qubicpack.pix2tes import assign_tes_grid
tes_grid = assign_tes_grid()
```

```{python}
global_dir = '/home/louisemousset/QUBIC/Qubic_work/Calibration/datas/'
# June measurement
# data_dir = global_dir + '2019-06-07/'

# December measurement
# data_dir = global_dir + 'fringes2019-12-19/'

# January measurement
data_dir = global_dir + '2020-01-13/'

dirs = np.sort(glob.glob(data_dir+'*switch*'))
print('# simu:', len(dirs))

labels = []
for i, d in enumerate(dirs):
    bla = str.split(d,'/')
    labels.append(bla[-1])
    print(i, labels[i])
```

```{python slideshow={'slide_type': '-'}}
def get_data(dirs, nf, asic, tes, doplot=True):
    asic = str(asic)
    thedir = dirs[nf]
    # print(thedir)

    # Qubicpack object
    a = qubicfp()
    a.verbosity = 0
    a.read_qubicstudio_dataset(thedir)
    data = a.azel_etc(TES=None)
    
    # Signal for one TES
    t0 = data['t_data ' + asic][0]
    t_data = data['t_data ' + asic] - t0
    data = data['data ' + asic]
    
    if doplot :
        fig, axs = plt.subplots(1, 2, figsize=(15,3))
        plt.subplots_adjust(wspace=0.5)

        axs[0].plot(t_data, data[tes-1, :])
        axs[0].set_title(thedir[-5:])

        axs[1].plot(t_data, data[tes-1, :])
        axs[1].set_title(thedir[-5:])
        axs[1].set_xlim(0, 40)  
    
    return t_data, data


    
```

```{python}
# Look at all simulations for one TES
TESNum = 28 #105#39
asic = 1

for nf in range(6, 28):
    t_data, data = get_data(dirs, nf, asic, TESNum)
```

```{python}
# Select a simulation
nf = 8
TESNum = 28 #105#39
asic = 1

t_data, data = get_data(dirs, nf, asic, TESNum)

```

```{python}
# Cut the data
def cut_data(tstart, tend, t_data, data):
    ok = (t_data > tstart) & (t_data < tend)
    t_data_cut = t_data[ok] - tstart
    data_cut = data[:, ok]
    
    return t_data_cut, data_cut

tstart =  4 #5.1 #+6.075*10# 41.7# 5.1
tend =  1750 #400 #tdeb+6.075*10

t_data_cut, data_cut = cut_data(tstart, tend, t_data, data)

plt.plot(t_data_cut, data_cut[TESNum-1, :])
plt.xlim(0, 30)
```

```{python}
def make_spectrum(t_data, data_oneTES, period):
    # Sampling frequency
    npoints = len(t_data)
    t0, tf = t_data[0], t_data[-1]
    f_sampling = npoints / (tf - t0)

    # Spectrum
    spectrum_f, freq_f = mlab.psd(data_oneTES, 
                                  Fs=f_sampling, 
                                  NFFT=2**int(np.log(len(data_oneTES)) / np.log(2)), 
                                  window=mlab.window_hanning)
    plt.plot(freq_f, spectrum_f)
    plt.loglog()
    plt.xlim(0.1, 10)
    for i in range(1, 10):
        plt.axvline(x=i/period, color='orange')
    plt.grid()
    
    return spectrum_f, freq_f

# Filter the data (just to give an idea because it is done when folding)
lowcut = 0.001
highcut = 10.
nharm = 10
notch = np.array([[1.724, 0.005, nharm]])

newdata = ft.filter_data(t_data_cut, data_cut[TESNum-1, :], lowcut, highcut, notch=notch, 
                         rebin=True, verbose=True, order=5)

spectrum_f, freq_f = make_spectrum(t_data_cut, data_cut[TESNum-1, :], period)

spectrum_f2, freq_f2 = make_spectrum(t_data_cut, newdata, period)

# compute spectrum with fibtools
spectrum_f3, freq_f3 = ft.power_spectrum(t_data_cut, newdata, rebin=True)

plt.subplot(2,1,1)
plt.plot(freq_f, spectrum_f, label='Original')
plot(freq_f2, spectrum_f2, label='filtered')
plot(freq_f3, spectrum_f3, label='filtered2')
legend()
plt.loglog()
ylim(1e1, 1e17)

subplot(2,1,2)
plot(t_data_cut, data_cut[TESNum-1, :], label='Original')
plot(t_data_cut, newdata, label='Filtered')
plt.xlim(200, 1700)
plt.legend()
```

```{python}
# Find the right period
def find_right_period(guess, t_data, data_oneTES):
    ppp = np.linspace(guess-1.5, guess+1.5, 250)
    rms = np.zeros(len(ppp))
    for i in range(len(ppp)):
        xin = t_data % ppp[i]
        yin = data_oneTES
        xx, yy, dx, dy, o = ft.profile(xin, yin, nbins=100, plot=False)
        rms[i] = np.std(yy)
    period = ppp[np.argmax(rms)]
    
    return ppp, rms, period

ppp, rms, period = find_right_period(18, t_data_cut, data_cut[TESNum-1, :])
print('period : ', ppp[np.argmax(rms)])
    
plt.figure()
rc('figure',figsize=(9, 4.5))
plt.subplots_adjust(wspace=2)

plt.subplot(211)
plot(ppp, rms, '.')
plt.axvline(x=period, color='orange')

plt.subplot(212)
plt.plot(t_data % period, data[TESNum-1, :],'.')
plt.xlim(0, period)
```

```{python}
# Fold and filter the data using the period determined before
lowcut = 0.001
highcut = 10.
nharm = 10
notch = np.array([[1.724, 0.005, nharm]])

nbins = 120
med = False
folded, t, folded_nonorm, truc = ft.fold_data(t_data_cut, 
                                              data_cut, 
                                              period, 
                                              lowcut, 
                                              highcut,
                                              nbins, 
                                              notch=notch,
                                              median=med)

plt.subplot(211)
plt.plot(t_data_cut, data_cut[TESNum-1, :])
plt.xlim(0, period)

plt.subplot(212)
plt.plot(t, folded[TESNum-1, :])
plt.xlim(0, period)

t
```

```{python}
def simsig(x, params):#pp, ctime, x0, amp1, amp2, amp3, amp4, amp5, amp6):
    dx = x[1] - x[0]
    npoints = len(x)
    tf = x[-1]
    
    pp = params[0]
    ctime = params[1]
    x0 = params[2]
    amp = params[3:9]
#     print(amp)
    
    sim_init = np.zeros(len(x))
#     amp = [amp1, amp2, amp3, amp4, amp5, amp6]
    
    for i in range(6):
        a = int(npoints/tf * 3 * i) 
        b = int((3 * i + 3) * npoints/tf)
#         print(a, b)
        sim_init[a : b] = amp[i]
    
    # Add a phase
    sim_init_shift = np.interp((x - x0) % max(x), x, sim_init)
    thesim = sim_init_shift
    
    # Convolved by an exponential filter
#     thesim = -1 * gaussian_filter1d(sim_init_shift, ctime, mode='wrap')
#     thesim = -1 * ft.exponential_filter1d(sim_init_shift, ctime / dx, mode='wrap')
    
    return np.array(thesim).astype(np.float64)

def make_diff_sig(params, t, data):
    thesim = simsig(t, params)
    diff = data - thesim
    return diff

param_guess = [3., 0.2, 2, 1, 1, 1, 1, 1, 1]

diff = make_diff_sig(param_guess, t, folded[TESNum-1, :])
print(diff)
fit = spo.least_squares(make_diff_sig, 
                         param_guess, 
                         args=(t, 
                               folded[TESNum-1, :]),
                         bounds= ([0, 0., -2, -2, -2, -2, -2, -2, -2], 
                                 [10, 1., 2, 2, 2, 2, 2, 2, 2]),
                         verbose=1
                              )
param_est = fit.x
print('Param_est :', param_est)

x0_est = param_est[2]
amps_est = param_est[3:9]
plt.figure()
plt.plot(t, simsig(t, param_est))
plt.plot(t,folded[TESNum-1, :] )
plt.plot(np.arange(0, 18, 3) + x0_est, amps_est, 'ro' )
plt.grid()

def make_combination(param_est):
    amps = param_est[3:9]
    comb = amps[0] + amps[3] - amps[1] - amps[2]
    print('Check:', amps[2], amps[4])
    return comb

comb = make_combination(param_est)
print(comb)    
```

```{python}
# w is made to make the combination to see fringes
tm1 = 8
tm2 = 2
ph = 5
w = np.zeros_like(t)
wcheck = np.zeros_like(t)
print(len(w))
per = len(w) / 6
for i in range(len(w)):
#         print(i)
        if (((i-ph) % per) >= tm1) and (((i-ph) % per) < per-tm2):
            if ((((i-ph)//per) == 0) | (((i-ph)//per) == 3)) : w[i]=1.
            if ((((i-ph)//per) == 1) | (((i-ph)//per) == 2)) : w[i]=-1.
                
npts = np.sum(w!=0.) / 4.
# w = w / npts
# wcheck = wcheck / npts
print(npts)
print(np.sum(np.abs(w[int(per+ph):int(2*per+ph)])))
print(np.sum(w))

themax = np.max(folded[TESNum-1, :])

plt.plot(t, folded[TESNum-1, :])
plt.plot(t, w * themax, 'o')
plt.plot(t, wcheck * themax, 'x')
plt.xlim(0, period)
plt.grid()
```

```{python}
# Analysis for both ASICs
allres_w = np.zeros(256)
allres_fit = np.zeros(256)

for asic in [1, 2]:
    t_data, data = get_data(dirs, nf, asic, TESNum, doplot=False)
    t_data_cut, data_cut = cut_data(tstart, tend, t_data, data)

    folded, t, folded_nonorm, truc = ft.fold_data(t_data_cut, 
                                                  data_cut,
                                                  period, 
                                                  lowcut, 
                                                  highcut, 
                                                  nbins, 
                                                  median=med)
    for TESNum in range(1, 129):
        TESindex = (TESNum - 1) + 128 * (asic - 1)
        allres_w[TESindex] = np.sum(folded[TESNum-1, :] * w)

        fit = spo.least_squares(make_diff_sig, 
                         param_guess, 
                         args=(t, 
                               folded[TESNum-1, :]),
                         bounds= ([0, 0., -2, -2, -2, -2, -2, -2, -2], 
                                 [10, 1., 2, 2, 2, 2, 2, 2, 2]),
                         verbose=1
                              )
        
        param_est = fit.x
        allres_fit[TESindex] = make_combination(param_est)
        
        x0_est = param_est[2]
        amps_est = param_est[3:9]
        plt.figure()
        plt.plot(t, folded[TESNum-1, :])
        plt.plot(t, simsig(t, param_est))
        plt.plot(t, w, 'g+')
        plt.plot(np.arange(0, 18, 3) + x0_est, amps_est, 'ro' )
        plt.title('ASIC {}, TES {}'.format(asic, TESNum))
        plt.grid()
```

```{python}
fringe_w = ft.image_asics(all1=allres_w)
fringe_fit = ft.image_asics(all1=allres_fit)

lim1 = 15.
lim2 = 1.
plt.figure()

plt.subplot(121)
plt.imshow(fringe_w, vmin=-lim1, vmax=lim1)
plt.title('with w')
colorbar(orientation ='horizontal')

plt.subplot(122)
plt.imshow(fringe_fit, vmin=-lim2, vmax=lim2)
plt.title('with fit')
colorbar(orientation ='horizontal')


```

### Try different masks

```{python}
# Mask to remove the 8 thermometer pixels
mask = np.ones_like(fringe)
mask[0, 12:] = np.nan
mask[1:5, 16] = np.nan

# Mask to remove bad pixels
# bad1 = np.array([1,2,3,29,30,31,32,33,34,35,61,62,63,64,65,66,67,93,
#                94,95,96,97,98,99,125,126,127,128,108,105,116,7,17,47,102,114,28,25])-1
# bad2 = np.array([1,2,3,29,30,31,32,33,34,35,61,62,63,64,65,66,67,93,
#                94,95,96,97,98,99,125,126,127,128,120,122,24,55,123,118,112,114,113,18,28,41,104,102,116,107])+127

bad1 = np.array([4, 5, 11, 12, 15, 17, 18, 19, 20, 21, 23, 29, 30, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 
                46, 47, 48, 49, 50, 51, 52, 58, 63, 65, 66, 68, 69, 78, 79, 80, 82, 83, 89, 90, 91, 92, 93, 97, 100,
                102, 104, 108, 111, 112, 114, 115, 116, 119, 121, 122, 124, 126])-1
bad2 = np.array([2, 4, 6, 8, 11, 12, 16, 21, 22, 23, 26, 27, 28, 29, 31, 33, 36, 37, 40, 46, 49, 51, 53, 55, 58, 62,
                63, 64, 68, 69, 74, 76, 78, 80, 83, 89, 92, 94, 95, 98, 99, 100, 101, 102, 103, 104, 107, 108, 
                109, 110, 117, 119, 120, 121, 125, 126, 127])+127

maskres = np.ones_like(allres)
maskres[bad1] = np.nan
maskres[bad2] = np.nan

mask2 = ft.image_asics(all1 = maskres)

# Mask to remove max values from check
lim = 10000
mask3 = np.ones_like(fringe) 
mask3[np.abs(fringe)<lim] = np.nan
plt.imshow(mask2, vmin=-1e5, vmax=1e5)
plt.title('mask3')
colorbar()
```

```{python}
# Apply masks on fringes

rcParams["image.cmap"]='viridis'
# rcParams["image.cmap"]='bwr'
plt.imshow(fringe * mask * mask3, vmin=-1e5, vmax=1e5)#,interpolation='bicubic')

```

```{python}
# Good if the fringes are vertical or horizontal
plt.plot(np.nanmean(fringe*mask4, axis=0), label='Med axis 0 norm')
plt.plot(np.nanmean(fringe*mask4, axis=1), label='Med axis 1 norm')
#plt.ylim(-3000,3000)
plt.grid()
plt.legend()
plt.title(labels[nf])
```

#### truc qui pourraient être utiles

```{python}
# Weighting factor to have just 1 difference
tm1=5
tm2=0
w=np.zeros_like(t)
per = len(w)/6.
for i in range(len(w)):
        if ((i % per) >= tm1) and ((i % per) < per-tm2):
            if ((i//per) == 1): w[i]=1.
            if ((i//per) == 0) : w[i]=-1.
npts=np.sum(w<>0.)
print(npts)
print(np.sum(w))
```

```{python}
# T stability
plot(a.hk['MMR_HK']['MMR3_CH2_X'])
```

```{python}
spectrum_f, freq_f = mlab.psd(a.hk['MMR_HK']['MMR3_CH1_X'], Fs=1., NFFT=len(a.hk['MMR_HK']['MMR3_CH3_X']), 
                              window=mlab.window_hanning,detrend='mean')
plot(freq_f, np.sqrt(spectrum_f))
yscale('log')
xscale('log')
grid()
#xlim(0.001, 1)
```

```{python}
a.max_bias
```

```{python}
a.hk['MMR_HK'].keys()
```

```{python}
tMMR=a.hk['MMR_HK']['ComputerDate']
print(tMMR[21]-tMMR[20])
plot(np.diff(tMMR))
print(np.median(np.diff(tMMR)))
```

```{python}

```
