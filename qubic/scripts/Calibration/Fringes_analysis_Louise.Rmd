---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
from __future__ import division, print_function

import glob
import numpy as np
import matplotlib.pyplot as plt

# %matplotlib notebook
# %matplotlib inline
from matplotlib import rc
rc('figure',figsize=(9, 4.5))
rc('font',size=12)
rc('text',usetex=False)

from qubicpack import qubicpack as qp
from qubicpack.qubicfp import qubicfp
import qubic.fibtools as ft

from pysimulators import FitsArray

import scipy.optimize as spo
import string

from importlib import reload

from qubicpack.pix2tes import assign_tes_grid
tes_grid = assign_tes_grid()
```

```{python}
global_dir = '/home/louisemousset/QUBIC/Qubic_work/Calibration/datas/'
# June measurement
data_dir = global_dir + '2019-06-07/'

# December measurement
# data_dir = global_dir + 'fringes2019-12-19/'

dirs = np.sort(glob.glob(data_dir+'*switch*'))
print('# simu:', len(dirs))

labels = []
for i, d in enumerate(dirs):
    bla = str.split(d,'/')
    labels.append(bla[-1])
    print(i, labels[i])
```

```{python slideshow={'slide_type': '-'}}
# Select a simulation
nf = 7
thedir = dirs[nf]
print(thedir)

# Qubicpack object
AsicNum = 1
a = qp()
a.verbosity = 0
a.read_qubicstudio_dataset(thedir, asic=AsicNum)
data = a.azel_etc(TES=None)

# Signal for one TES
TESNum = 95 #105#39
t0 = data['t_data'][0]
plt.plot(data['t_data']-t0, data['data'][TESNum-1, :])
# plt.xlim(0, 40)
```

```{python}
# Select only good data
tdeb =  5.3 #5.1 #+6.075*10# 41.7# 5.1
tfin =  400 #400 #tdeb+6.075*10 
ok = ((data['t_data']-t0) > tdeb) & ((data['t_data']-t0) < tfin)
data['t_data'] = data['t_data'][ok] - t0 - tdeb
data['data'] = data['data'][:, ok]

plt.plot(data['t_data'], data['data'][TESNum-1, :])
# plt.xlim(0, 30)
```

```{python}
# Find the right period

ppp = np.linspace(5, 7, 250)
rms = np.zeros(len(ppp))
for i in range(len(ppp)):
    xin = data['t_data'] % ppp[i]
    yin = data['data'][TESNum-1, :]
    xx, yy, dx, dy, o = ft.profile(xin, yin, nbins=100, plot=False)
    rms[i] = np.std(yy)

plt.figure()
rc('figure',figsize=(9, 4.5))
plt.subplots_adjust(wspace=2)

plt.subplot(211)
plot(ppp, rms, '.')
plt.axvline(x=ppp[np.argmax(rms)], color='orange')
print('period : ', ppp[np.argmax(rms)])

period = ppp[np.argmax(rms)] #6.07 #6.069 #14.09
plt.subplot(212)
plt.plot(data['t_data'] % period, data['data'][TESNum-1, :],'.')
plt.xlim(0, period)
```

```{python}
# Sampling frequency
npoints = len(data['t_data'])
t0, tf = data['t_data'][0], data['t_data'][-1]
f_sampling = npoints / (tf - t0)
print(npoints, t0, tf, f_sampling)

# Spectrum
spectrum_f, freq_f = mlab.psd(data['data'][TESNum-1, :], 
                              Fs=f_sampling, 
                              NFFT=2**int(np.log(len(data['data'][TESNum-1,:]))/np.log(2)), 
                              window=mlab.window_hanning)
plt.plot(freq_f, spectrum_f)
plt.loglog()
plt.xlim(0.1, 10)
for i in range(1, 10):
    plt.axvline(x=i/period, color='orange')
plt.grid()
```

```{python}
# Fold the data using the period determined before
lowcut = 0.0001
highcut = 10.
nbins = 120
med = False
folded, t, folded_nonorm, truc = ft.fold_data(data['t_data'], 
                                              data['data'], 
                                              period, 
                                              lowcut, 
                                              highcut, 
                                              nbins, 
                                              median=med)

plt.subplot(211)
plt.plot(data['t_data'], data['data'][TESNum-1, :])
plt.xlim(0, period)

plt.subplot(212)
plt.plot(t, folded_nonorm[TESNum-1, :])
plt.xlim(0, period)
```

```{python}
# w is made to make the combination to see fringes
tm1 = 8
tm2 = 2
ph = 0
w = np.zeros_like(t)
wcheck = np.zeros_like(t)
per = 20.
for i in range(len(w)):
#         print(i)
        if (((i-ph) % per) >= tm1) and (((i-ph) % per) < per-tm2):
            if ((((i-ph)//per) == 0) | (((i-ph)//per) == 3)) : w[i]=1.
            if ((((i-ph)//per) == 1) | (((i-ph)//per) == 2)) : w[i]=-1.
            if (((i-ph)//per) == 2) : wcheck[i]=1.
            if (((i-ph)//per) == 4) : wcheck[i]=-1.
                
npts = np.sum(w!=0.) / 4.
# w = w / npts
# wcheck = wcheck / npts
print(npts)
print(np.sum(np.abs(w[int(per+ph):int(2*per+ph)])))
print(np.sum(w))

themax = np.max(folded_nonorm[TESNum-1, :])
```

```{python}
plt.plot(t, folded_nonorm[TESNum-1, :])
plt.plot(t, w * themax, 'o')
plt.plot(t, wcheck * themax, 'x')
plt.xlim(0, period)
plt.grid()
```

```{python}
# Analysis for both ASICs
allres = np.zeros(256)
allrescheck = np.zeros(256)

a = qp()
a.verbosity = 0 
for AsicNum in [1, 2]:
    a.read_qubicstudio_dataset(thedir, asic=AsicNum)
    data = a.azel_etc(TES=None)
    t0 = data['t_data'][0]
    
    ok = ((data['t_data']-t0) > tdeb) & ((data['t_data']-t0) < tfin)
    data['t_data'] = data['t_data'][ok] - t0 - tdeb 
    data['data'] = data['data'][:, ok]

    folded, t, folded_nonorm, truc = ft.fold_data(data['t_data'], 
                                                  data['data'],
                                                  period, 
                                                  lowcut, 
                                                  highcut, 
                                                  nbins, 
                                                  median=med)
    for TESNum in range(1, 129):
        TESindex = (TESNum - 1) + 128 * (AsicNum - 1)
        allres[TESindex] = np.sum(folded_nonorm[TESNum-1, :] * w)
        allrescheck[TESindex] = np.sum(folded_nonorm[TESNum-1, :] * wcheck)
        
        plt.plot(t, folded_nonorm[TESNum-1, :])
        plt.xlim(0, period)
        plt.plot(t, w * np.abs(np.max(folded_nonorm[TESNum-1, :])),'+')
        plt.plot(t, wcheck * np.abs(np.max(folded_nonorm[TESNum-1, :])),'x')
        plt.grid()
        plt.title('ASIC {}, TES {}'.format(AsicNum, TESNum))
        plt.pause(0.1)
```

```{python}
fringe = ft.image_asics(all1=allres)
fringecheck = ft.image_asics(all1=allrescheck)

lim = 1e4
plt.figure()

plt.subplot(121)
plt.imshow(fringe, vmin=-lim, vmax=lim)
plt.title('with w')
colorbar(orientation ='horizontal')

plt.subplot(122)
plt.imshow(fringecheck, vmin=-lim, vmax=lim)
plt.title('with wcheck')
colorbar(orientation ='horizontal')


```

### Try different masks

```{python}
# Mask to remove the 8 thermometer pixels
mask = np.ones_like(fringe)
mask[0, 12:] = np.nan
mask[1:5, 16] = np.nan

# Mask to remove bad pixels
bad1 = np.array([1,2,3,29,30,31,32,33,34,35,61,62,63,64,65,66,67,93,
               94,95,96,97,98,99,125,126,127,128,108,105,116,7,17,47,102,114,28,25])-1
bad2 = np.array([1,2,3,29,30,31,32,33,34,35,61,62,63,64,65,66,67,93,
               94,95,96,97,98,99,125,126,127,128,120,122,24,55,123,118,112,114,113,18,28,41,104,102,116,107])+127
maskres = np.ones_like(allres)
maskres[bad1] = np.nan
maskres[bad2] = np.nan

mask2 = ft.image_asics(all1 = maskres)

# Mask to remove max values from check
lim = 4000
mask3 = np.ones_like(fringe) 
mask3[np.abs(fringe)<lim] = np.nan
plt.imshow(mask3, vmin=-1e5, vmax=1e5)
plt.title('mask3')
colorbar()
```

```{python}
# Apply masks on fringes

rcParams["image.cmap"]='viridis'
# rcParams["image.cmap"]='bwr'
plt.imshow(fringe * mask * mask3, vmin=-1e5, vmax=1e5)#,interpolation='bicubic')

```

```{python}
# Good if the fringes are vertical or horizontal
plt.plot(np.nanmean(fringe*mask4, axis=0), label='Med axis 0 norm')
plt.plot(np.nanmean(fringe*mask4, axis=1), label='Med axis 1 norm')
#plt.ylim(-3000,3000)
plt.grid()
plt.legend()
plt.title(labels[nf])
```

### Fit with an analytical function

```{python}
# Analytical function
def sim_fringe(param):
    Amp = param[0]
    focal = param[1]
    phase = param[2]
    alpha = param[3]
        
    yc = 0.
    xc = 0. 
    
    nu = 150.e9
    lam = 3.e8/nu
    alpha_rad = np.deg2rad(alpha)
    
    det_dist = 3e-3
    baseline = 14.e-3*4.
    
    ndet = 17
    fringe = np.zeros((ndet, ndet))
    i, j = np.mgrid[0:ndet, 0:ndet]
    
    w = 40.87e-3 # From Creidhe
    #w=np.sqrt(2*(12.9*np.pi/180*f/2.355)**2)
    
    gaussian = np.exp(-((16-i+xc)**2 + (j-yc)**2) * det_dist**2 / (w**2))
    xprime = (i * np.cos(alpha_rad) + j * np.sin(alpha_rad)) * det_dist
    interfrange = lam * focal / baseline
    fringe = Amp * np.cos((2. * np.pi / interfrange * xprime) + phase)# * gaussian
    
    return fringe
```

```{python}
def sim_fringe_flat(param):
    fff = sim_fringe(param)
    return fff.ravel()

def sim_fringe_flat2(param):
    fff = sim_fringe(param)
    res = np.zeros(256)
    for xx in range(17):
        for yy in range(17):
            TESNum=int(tes_grid[xx,yy])
            AsicNum = int(10.*(tes_grid[xx,yy]-TESNum))+1
            TESindex = (TESNum-1) + 128 *(AsicNum -1)
            res[TESindex] = fff[xx,yy]
    return res
```

```{python}
def compute_residuals(param, observation):
    """
    Return array: observation - model
    """
    model = sim_fringe_flat(param)
    err = 2000
    residual = (observation - model) / err
    print("residual: ", np.nansum(residual**2))
    
    return residual.astype(np.float64)
```

```{python}
param = [13e3, 300e-3, 0., -45.]#,40.87e-3]#,0.]
lim = 1e4
plt.imshow(sim_fringe(param), vmin=-lim, vmax=lim)
```

```{python}
# Fit the measurement with the analytical model
param_guess = [13e3, 300e-3, 0, -50.]

tofit = (fringe * mask4).ravel()
tofit[np.isnan(tofit)] = 0.

param_est, cov_x, infodict, mesg_result, ret_value = spo.leastsq(compute_residuals, 
                                                                 param_guess, 
                                                                 args=(tofit.astype(np.float64)),
                                                                 full_output=True, 
                                                                 maxfev=10000, 
                                                                 epsfcn=np.finfo(np.float32).eps)

sigma_param_est = np.sqrt(np.diagonal(cov_x))

print("Return value:", ret_value)
print("Return message:", mesg_result)

if ret_value not in (1, 2, 3, 4):
    raise RuntimeError(mesg_result)

print("guess    :", param_guess)
print("solution :", param_est)
print("Error :", sigma_param_est)
print("Precision (%):",sigma_param_est/param_est*100)
```

```{python}
rcParams["image.cmap"]='viridis'
# rcParams["image.cmap"]='bwr'

lim = 1e5

subplot(121)
imshow(sim_fringe(param_est), vmin=-lim,vmax=lim)

subplot(122)
imshow(fringe * mask * mask4, vmin=-lim, vmax=lim)
# plt.title(labels[nf])
# plt.colorbar()
```

```{python}
maskresp = fringe / sim_fringe(param_est) * mask3 * mask
```

```{python}
rcParams["image.cmap"]='viridis'
# rcParams["image.cmap"]='bwr'
imshow(maskresp, vmin=-10, vmax=10)#,interpolation='bicubic')
plt.title(labels[nf])
plt.colorbar()
```

### Fit with the simulation

```{python}
from qubic import selfcal_lib as sc
from qubicpack.utilities import Qubic_DataDir
import qubic
import pandas as pd
# Use a tool from qubicpack to get a path
basedir = Qubic_DataDir(datafile='instrument.py', ) 
print('basedir : ', basedir)
dictfilename = basedir + '/dicts/global_source_oneDet.dict'

# Get a dictionary
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictfilename)
print(d['detarray'])

# Create an object
baseline = [25, 57]
ca = sc.SelfCalibration(baseline, [], d)

# Path to the simulated files 
rep = Qubic_DataDir(datafile='detcentres.txt')
print('rep:', rep)
```

```{python}
fringes = ca.get_power_fp_aberration(rep, theta_source=0., doplot=False)
readv, labels = sc.make_labels(rep)

counts_perTES, sum_perTES, mean_perTES = sc.fulldef2tespixels(fringes, labels)
```

```{python}
print(len(mean_perTES))
fig = sc.make_plot_real_fp(readv, mean_perTES)
plt.title('Baseline {} with aberrations'.format(baseline))
```

```{python}
q = qubic.QubicInstrument(d)

def get_quadrant3(q, signal_perTES, doplot=False):
    quadrant3 = signal_perTES[496:744]
    indice = -(q.detector.center // 0.003)

    img = np.zeros((17, 17))
    for k in range(248):
        i = int(indice[k, 0])
        j = int(indice[k, 1])
        img[i-1, j-1] = quadrant3[k]
    img[img==0.] = np.nan
    img = np.rot90(img)
    
    if doplot :
        plt.imshow(img)
    
    return img

img = get_quadrant3(q, mean_perTES, doplot=True)
```

```{python}
measure = (fringe * mask) / np.nanmax(fringe * mask)
simu = img/np.nanmax(img)

plt.subplot(131)
plt.imshow(measure)
plt.colorbar()

plt.subplot(132)
plt.imshow(simu)
plt.colorbar()

plt.subplot(133)
plt.imshow(measure-simu)
plt.colorbar()
```

```{python}
def get_simulation(param, baseline, d, rep, labels, doplot=True):
    
    theta_source = param[0]
    freq_source = param[1]

    q = qubic.QubicInstrument(d)

    # Get simulation files
    files = sorted(glob.glob(rep + '/*.dat'))

    # This is done to get the right file for each horn
    horn_transpose = np.arange(64)
    horn_transpose = np.reshape(horn_transpose, (8, 8))
    horn_transpose = np.ravel(horn_transpose.T)

    # Get the sample number from the first file
    data0 = pd.read_csv(files[0], sep='\t', skiprows=0)
    nn = data0['X_Index'].iloc[-1] + 1
    print('Sampling number = {}'.format(nn))

    q.horn.open = False
    q.horn.open[np.asarray(baseline) - 1] = True

    allampX = np.empty((2, nn, nn))
    allphiX = np.empty((2, nn, nn))
    allampY = np.empty((2, nn, nn))
    allphiY = np.empty((2, nn, nn))
    for i, swi in enumerate(baseline):
        # Phase calculation
        horn_x = q.horn.center[swi - 1, 0]
        horn_y = q.horn.center[swi - 1, 1]
        d = np.sqrt(horn_x ** 2 + horn_y ** 2)  # distance between the horn and the center
        phi = - 2 * np.pi / 3e8 * freq_source * 1e9 * d * np.sin(np.deg2rad(theta_source))

        thefile = files[horn_transpose[swi - 1]]
        print('Horn ', swi, ': ', thefile[98:104])
        data = pd.read_csv(thefile, sep='\t', skiprows=0)

        allampX[i, :, :] = np.reshape(np.asarray(data['MagX']), (nn, nn)).T
        allampY[i, :, :] = np.reshape(np.asarray(data['MagY']), (nn, nn)).T

        allphiX[i, :, :] = np.reshape(np.asarray(data['PhaseX']), (nn, nn)).T + phi
        allphiY[i, :, :] = np.reshape(np.asarray(data['PhaseY']), (nn, nn)).T + phi

    # Electric field for each open horn
    Ax = allampX * (np.cos(allphiX) + 1j * np.sin(allphiX))
    Ay = allampY * (np.cos(allphiY) + 1j * np.sin(allphiY))

    # Sum of the electric fields
    sumampx = np.sum(Ax, axis=0)
    sumampy = np.sum(Ay, axis=0)

    # Power on the focal plane
    power = np.abs(sumampx) ** 2 + np.abs(sumampy) ** 2

    if doplot:
        plt.figure()
        plt.subplot(121)
        q.horn.plot()
        plt.axis('off')

        plt.subplot(122)
        plt.imshow(power, origin='lower')
        plt.title('Power at the sampling resolution')
        plt.colorbar()
    
    counts_perTES, sum_perTES, mean_perTES = sc.fulldef2tespixels(power, labels)
    img = get_quadrant3(q, mean_perTES, doplot=doplot)

    return img
```

```{python}
img = get_simulation([0., 150.], baseline, d, rep, labels, doplot=True)
```

```{python}
def compute_diff(param, baseline, d, rep, labels, observation):
    """
    Return array: observation - model
    """
    model = get_simulation(param, baseline, d, rep, labels, doplot=False)
    err = 500000
    residual = (observation - np.ravel(model)) / err
    print('param :', param)
    print("residual: ", np.nansum(residual**2))
    
    return residual.astype(np.float64)
```

```{python}
residual = compute_diff([0., 150.], baseline, d, rep, labels, np.ravel(fringe))
```

```{python}
# Fit the measurement with the analytical model
param_guess = [30., 150.]

tofit = np.ravel(fringe)
tofit[np.isnan(tofit)] = 0.

param_est, cov_x, infodict, mesg_result, ret_value = spo.leastsq(compute_diff, 
                                                                 param_guess, 
                                                                 args=(baseline, d, rep, labels, tofit.astype(np.float64)),
                                                                 full_output=True,
                                                                 factor=2.,
                                                                 maxfev=10000,
                                                                 epsfcn=np.finfo(np.float32).eps)

# sigma_param_est = np.sqrt(np.diagonal(cov_x))

print("Return value:", ret_value)
print("Return message:", mesg_result)

if ret_value not in (1, 2, 3, 4):
    raise RuntimeError(mesg_result)

print("guess    :", param_guess)
print("solution :", param_est)
# print("Error :", sigma_param_est)
# print("Precision (%):", sigma_param_est / param_est * 100)
```

#### truc qui pourraient être utiles

```{python}
# Weighting factor to have just 1 difference
tm1=5
tm2=0
w=np.zeros_like(t)
per = len(w)/6.
for i in range(len(w)):
        if ((i % per) >= tm1) and ((i % per) < per-tm2):
            if ((i//per) == 1): w[i]=1.
            if ((i//per) == 0) : w[i]=-1.
npts=np.sum(w<>0.)
print(npts)
print(np.sum(w))
```

```{python}
# T stability
plot(a.hk['MMR_HK']['MMR3_CH2_X'])
```

```{python}
spectrum_f, freq_f = mlab.psd(a.hk['MMR_HK']['MMR3_CH1_X'], Fs=1., NFFT=len(a.hk['MMR_HK']['MMR3_CH3_X']), 
                              window=mlab.window_hanning,detrend='mean')
plot(freq_f, np.sqrt(spectrum_f))
yscale('log')
xscale('log')
grid()
#xlim(0.001, 1)
```

```{python}
a.max_bias
```

```{python}
a.hk['MMR_HK'].keys()
```

```{python}
tMMR=a.hk['MMR_HK']['ComputerDate']
print(tMMR[21]-tMMR[20])
plot(np.diff(tMMR))
print(np.median(np.diff(tMMR)))
```

```{python}

```
