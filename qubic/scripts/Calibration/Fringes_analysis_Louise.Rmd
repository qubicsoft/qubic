---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
from __future__ import division, print_function

# %matplotlib notebook
# %matplotlib inline
from matplotlib import rc
rc('figure',figsize=(9,4.5))
rc('font',size=12)
rc('text',usetex=False)

from qubicpack import qubicpack as qp

from qubicpack.qubicfp import qubicfp
import qubic.fibtools as ft

from pysimulators import FitsArray

import numpy as np
import matplotlib.pyplot as plt

import scipy.optimize as spo
import glob
import string

from importlib import reload

from qubicpack.pix2tes import assign_tes_grid
tes_grid = assign_tes_grid()
```

```{python}
# Get all simulations
day = '2019-12-19'
# data_dir = '/qubic/Data/Calib-TD/'+day+'/'
data_dir = '/home/louisemousset/QUBIC/Qubic_work/Calibration/datas/2019-06-07/'

# data_dir = '/home/louisemousset/QUBIC/Qubic_work/Calibration/datas/fringes2019-12-19/'
dirs = np.sort(glob.glob(data_dir+'*switch*'))
print('# simu:', len(dirs))

labels = []
for i, d in enumerate(dirs):
    bla = str.split(d,'/')
    labels.append(bla[-1])
    print(i, labels[i])
```

```{python slideshow={'slide_type': '-'}}
# Select a simulation
nf = 0
thedir = dirs[nf]
print(thedir)

# Qubicpack object
AsicNum = 1
a = qp()
a.verbosity = 0
a.read_qubicstudio_dataset(thedir, asic=AsicNum)
data = a.azel_etc(TES=None)

# Signal for one TES
TESNum = 95 #105#39
t0 = data['t_data'][0]
plt.plot(data['t_data']-t0, data['data'][TESNum-1, :])
# plt.xlim(0, 40)
```

```{python}
# Select only good data
tdeb =  5.3 #5.1 #+6.075*10# 41.7# 5.1
tfin =  400 #400 #tdeb+6.075*10 
ok = ((data['t_data']-t0) > tdeb) & ((data['t_data']-t0) < tfin)
data['t_data'] = data['t_data'][ok] - t0 - tdeb
data['data'] = data['data'][:, ok]

plt.plot(data['t_data'], data['data'][TESNum-1, :])
plt.xlim(0, 30)
```

```{python}
# Fold data in one period by hand
# Useful to find the right period to use

period = 6.08 #6.07 #6.069 #14.09
plt.plot(data['t_data'] % period, data['data'][TESNum-1, :],'.')
plt.xlim(0, period)
```

```{python}
# Sampling frequency
npoints = len(data['t_data'])
t0, tf = data['t_data'][0], data['t_data'][-1]
f_sampling = npoints / (tf - t0)
print(npoints, t0, tf, f_sampling)

# Spectrum
spectrum_f, freq_f = mlab.psd(data['data'][TESNum-1, :], 
                              Fs=f_sampling, 
                              NFFT=2**int(np.log(len(data['data'][TESNum-1,:]))/np.log(2)), 
                              window=mlab.window_hanning)
plt.plot(freq_f, spectrum_f)
plt.loglog()
plt.xlim(0.1, 10)
for i in range(1, 10):
    plt.axvline(x=i/period, color='orange')
plt.grid()
```

```{python}
# Fold the data in a better way
lowcut = 0.0001
highcut = 10.
nbins = 120
med = False
folded, t, folded_nonorm, truc_qui_sert_a_rien_ici= ft.fold_data(data['t_data'], 
                                                                 data['data'], 
                                                                 period, 
                                                                 lowcut, 
                                                                 highcut, 
                                                                 nbins, 
                                                                 median=med)
```

```{python}
plt.subplot(211)
plt.plot(data['t_data'], data['data'][TESNum-1, :])
plt.xlim(0, period)

plt.subplot(212)
plt.plot(t, folded_nonorm[TESNum-1,:])
plt.xlim(0, period)
```

```{python}
# w is made to make the combination to see fringes
tm1 = 8
tm2 = 2
ph = 0
w = np.zeros_like(t)
wcheck = np.zeros_like(t)
per = 20.
for i in range(len(w)):
#         print(i)
        if (((i-ph) % per) >= tm1) and (((i-ph) % per) < per-tm2):
            if ((((i-ph)//per) == 0) | (((i-ph)//per) == 3)) : w[i]=1.
            if ((((i-ph)//per) == 1) | (((i-ph)//per) == 2)) : w[i]=-1.
            if (((i-ph)//per) == 2) : wcheck[i]=1.
            if (((i-ph)//per) == 4) : wcheck[i]=-1.
                
npts = np.sum(w!=0.) / 4.
# w = w / npts
# wcheck = wcheck / npts
print(npts)
print(np.sum(np.abs(w[int(per+ph):int(2*per+ph)])))
print(np.sum(w))
```

```{python}
plt.plot(t, folded_nonorm[TESNum-1, :])
plt.plot(t, w * np.max(folded_nonorm[TESNum-1, :]), 'o')
plt.plot(t, wcheck * np.max(folded_nonorm[TESNum-1, :]), 'x')
plt.xlim(0, period)
plt.grid()
```

```{python}
# Analysis for both ASICs
allres = np.zeros(256)
allrescheck = np.zeros(256)

for AsicNum in [1, 2]:
    a = qp()
    a.verbosity = 0 
    a.read_qubicstudio_dataset(thedir, asic=AsicNum)
    data=a.azel_etc(TES=None)
    t0 = data['t_data'][0]
    
    ok = ((data['t_data']-t0) > tdeb) & ((data['t_data']-t0) < tfin)
    data['t_data'] = data['t_data'][ok]-t0-tdeb
    if (AsicNum == 1): 
        data['data'] = data['data'][:, ok]
    else: 
        data['data'] = data['data'][:, ok]

    folded, t, folded_nonorm, truc = ft.fold_data(data['t_data'], 
                                                  data['data'],
                                                  period, 
                                                  lowcut, 
                                                  highcut, 
                                                  nbins, 
                                                  median=med)
    for TESNum in range(1, 129):
        TESindex = (TESNum - 1) + 128 * (AsicNum - 1)
        allres[TESindex] = np.sum(folded_nonorm[TESNum-1, :] * w)
        allrescheck[TESindex] = np.sum(folded_nonorm[TESNum-1, :] * wcheck)
        
        plt.plot(t, folded_nonorm[TESNum-1, :])
        plt.xlim(0, period)
        plt.plot(t, w * np.abs(np.max(folded_nonorm[TESNum-1, :])),'+')
        plt.plot(t, wcheck * np.abs(np.max(folded_nonorm[TESNum-1, :])),'x')
        plt.grid()
        plt.title('ASIC {}, TES {}'.format(AsicNum, TESNum))
        plt.pause(0.1)
```

```{python}
fringe = ft.image_asics(all1=allres)
fringecheck = ft.image_asics(all1=allrescheck)

plt.figure()
plt.subplots_adjust(wspace=1.4)

plt.subplot(121)
plt.imshow(fringe, vmin=-1e5, vmax=1e5)
plt.title(labels[nf])
colorbar(orientation ='horizontal')

plt.subplot(122)
plt.imshow(fringecheck, vmin=-4e3, vmax=4e3)
plt.title(labels[nf])
colorbar(orientation ='horizontal')


```

### Try different masks

```{python}
# Mask to remove the 8 thermometer pixels
mask = np.ones_like(fringe)
mask[0, 12:] = np.nan
mask[1:5, 16] = np.nan

# Mask to remove bad pixels
bad1 = np.array([1,2,3,29,30,31,32,33,34,35,61,62,63,64,65,66,67,93,
               94,95,96,97,98,99,125,126,127,128,108,105,116,7,17,47,102,114,28,25])-1
bad2 = np.array([1,2,3,29,30,31,32,33,34,35,61,62,63,64,65,66,67,93,
               94,95,96,97,98,99,125,126,127,128,120,122,24,55,123,118,112,114,113,18,28,41,104,102,116,107])+127
maskres = np.ones_like(allres)
maskres[bad1] = np.nan
maskres[bad2] = np.nan

mask2 = ft.image_asics(all1 = maskres)

# Mask to remove max values from check
lim = 4000
mask3 = np.ones_like(fringe) 
mask3[np.abs(fringe)<lim] = np.nan
plt.imshow(mask3, vmin=-1e5, vmax=1e5)
plt.title('mask3')
colorbar()
```

```{python}
# Apply masks on fringes

rcParams["image.cmap"]='viridis'
# rcParams["image.cmap"]='bwr'
plt.imshow(fringe * mask * mask3, vmin=-1e5, vmax=1e5)#,interpolation='bicubic')

```

```{python}
# Good if the fringes are vertical or horizontal
plt.plot(np.nanmean(fringe*mask4, axis=0), label='Med axis 0 norm')
plt.plot(np.nanmean(fringe*mask4, axis=1), label='Med axis 1 norm')
#plt.ylim(-3000,3000)
plt.grid()
plt.legend()
plt.title(labels[nf])
```

### Fit with an analytical function

```{python}
# Analytical function
def sim_fringe(param):
    Amp = param[0]
    focal = param[1]
    phase = param[2]
    alpha = param[3]
        
    yc = 0.
    xc = 0. 
    
    nu = 150.e9
    lam = 3.e8/nu
    alpha_rad = np.deg2rad(alpha)
    
    det_dist = 3e-3
    baseline = 14.e-3*4.
    
    ndet = 17
    fringe = np.zeros((ndet, ndet))
    i, j = np.mgrid[0:ndet, 0:ndet]
    
    w = 40.87e-3 # From Creidhe
    #w=np.sqrt(2*(12.9*np.pi/180*f/2.355)**2)
    
    gaussian = np.exp(-((16-i+xc)**2 + (j-yc)**2) * det_dist**2 / (w**2))
    xprime = (i * np.cos(alpha_rad) + j * np.sin(alpha_rad)) * det_dist
    interfrange = lam * focal / baseline
    fringe = Amp * np.cos((2. * np.pi / interfrange * xprime) + phase)# * gaussian
    
    return fringe
```

```{python}
def sim_fringe_flat(param):
    fff = sim_fringe(param)
    return fff.ravel()

def sim_fringe_flat2(param):
    fff = sim_fringe(param)
    res = np.zeros(256)
    for xx in range(17):
        for yy in range(17):
            TESNum=int(tes_grid[xx,yy])
            AsicNum = int(10.*(tes_grid[xx,yy]-TESNum))+1
            TESindex = (TESNum-1) + 128 *(AsicNum -1)
            res[TESindex] = fff[xx,yy]
    return res
```

```{python}
def compute_residuals(param, observation):
    """
    Return array: observation - model
    """
    model = sim_fringe_flat(param)
    err = 2000
    residual = (observation - model) / err
    print("residual: ", np.nansum(residual**2))
    
    return residual.astype(np.float64)
```

```{python}
param = [13e3, 300e-3, 0., -45.]#,40.87e-3]#,0.]
lim = 1e4
plt.imshow(sim_fringe(param), vmin=-lim, vmax=lim)
```

```{python}
# Fit the measurement with the analytical model
param_guess = [13e3, 300e-3, 0, -50.]

tofit = (fringe * mask4).ravel()
tofit[np.isnan(tofit)] = 0.

param_est, cov_x, infodict, mesg_result, ret_value = spo.leastsq(compute_residuals, 
                                                                 param_guess, 
                                                                 args=(tofit.astype(np.float64)),
                                                                 full_output=True, 
                                                                 maxfev=10000, 
                                                                 epsfcn=np.finfo(np.float32).eps)

sigma_param_est = np.sqrt(np.diagonal(cov_x))

print("Return value:", ret_value)
print("Return message:", mesg_result)

if ret_value not in (1, 2, 3, 4):
    raise RuntimeError(mesg_result)

print("guess    :", param_guess)
print("solution :", param_est)
print("Error :", sigma_param_est)
print("Precision (%):",sigma_param_est/param_est*100)
```

```{python}
rcParams["image.cmap"]='viridis'
# rcParams["image.cmap"]='bwr'

lim = 1e5

subplot(121)
imshow(sim_fringe(param_est), vmin=-lim,vmax=lim)

subplot(122)
imshow(fringe * mask * mask4, vmin=-lim, vmax=lim)
# plt.title(labels[nf])
# plt.colorbar()
```

```{python}
maskresp = fringe / sim_fringe(param_est) * mask3 * mask
```

```{python}
rcParams["image.cmap"]='viridis'
# rcParams["image.cmap"]='bwr'
imshow(maskresp, vmin=-10, vmax=10)#,interpolation='bicubic')
plt.title(labels[nf])
plt.colorbar()
```

### Fit with the simulation

```{python}
from qubic import selfcal_lib as sc
from qubicpack.utilities import Qubic_DataDir
import qubic

# Use a tool from qubicpack to get a path
basedir = Qubic_DataDir(datafile='instrument.py', ) 
print('basedir : ', basedir)
dictfilename = basedir + '/dicts/global_source_oneDet.dict'

# Get a dictionary
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictfilename)
print(d['detarray'])

# Create an object
baseline = [25, 57]
ca = sc.SelfCalibration(baseline, [], d)

# Path to the simulated files 
rep = Qubic_DataDir(datafile='detcentres.txt')
print('rep:', rep)

# Finges with aberations
# Directly using the 2 horns opened
fringes_aber = ca.get_power_fp_aberration(rep, theta_source=0., doplot=False)

print(fringes_aber.shape)
```

```{python}
# Get real FP by averaging the signal and using real TES locations.
readv_aber, det_value_aber = sc.averaging_tes_signal(fringes_aber, rep, 0.12)
```

```{python}
quadrant3_mean = det_value_aber[496:744, 2]

q = qubic.QubicInstrument(d)
indice = -(q.detector.center // 0.003)

img = np.zeros((17, 17))
img[0, 0]
for k in range(248):
    i = int(indice[k, 0])
    j = int(indice[k, 1])
#     print(i, j)
    img[i-1, j-1] = quadrant3_mean[k]
img[img==0.] = np.nan
img = np.rot90(img)
plt.imshow(img)
```

```{python}
fig = sc.make_plot_real_fp(readv_aber, det_value_aber)
plt.title('Baseline {} with aberrations'.format(baseline))
```

#### truc qui pourraient être utiles

```{python}
# Weighting factor to have just 1 difference
tm1=5
tm2=0
w=np.zeros_like(t)
per = len(w)/6.
for i in range(len(w)):
        if ((i % per) >= tm1) and ((i % per) < per-tm2):
            if ((i//per) == 1): w[i]=1.
            if ((i//per) == 0) : w[i]=-1.
npts=np.sum(w<>0.)
print(npts)
print(np.sum(w))
```

```{python}
# T stability
plot(a.hk['MMR_HK']['MMR3_CH2_X'])
```

```{python}
spectrum_f, freq_f = mlab.psd(a.hk['MMR_HK']['MMR3_CH1_X'], Fs=1., NFFT=len(a.hk['MMR_HK']['MMR3_CH3_X']), 
                              window=mlab.window_hanning,detrend='mean')
plot(freq_f, np.sqrt(spectrum_f))
yscale('log')
xscale('log')
grid()
#xlim(0.001, 1)
```

```{python}
a.max_bias
```

```{python}
a.hk['MMR_HK'].keys()
```

```{python}
tMMR=a.hk['MMR_HK']['ComputerDate']
print(tMMR[21]-tMMR[20])
plot(np.diff(tMMR))
print(np.median(np.diff(tMMR)))
```

```{python}

```
