---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.7.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

 one thing that wuld be useful by the way, and maybe you could have a lok at this if you want:
we would be in a much better situation for developping the reconstruction code if we had simualted data to play with. I mean simulate the observation of a source in the hall at 150 GHz with the theoretical SB => reproduce the Flat Beam Maps but with the theory, with the exact same pointing values
so that we could:
- test the reconstruction code
- Try the SB Peak fitting on these
- See how the multiband reconstruction behaves with "true peak positions" and with the fitted values


```{python}
# %matplotlib inline

# system packages
import os
import sys
from importlib import reload 
import time
from warnings import warn

# scientific packages
import numpy as np
import healpy as hp
from matplotlib.pyplot import *
from scipy.fftpack import rfft, rfftfreq

# QUBIC packages
import qubic
from qubicpack.utilities import Qubic_DataDir
from pysimulators import FitsArray
from qubic import demodulation_lib as dl
from qubic import sb_fitting as sbfit
import toolfit_hpmap as fh
from qubicpack import pixel_translation as pt
from qubicpack.pix2tes import assign_tes_grid, tes2pix
from pyoperators import (
    Cartesian2SphericalOperator,
    Rotation3dOperator,
    Spherical2CartesianOperator)
from pysimulators import ( 
    CartesianEquatorial2HorizontalOperator,
    CartesianHorizontal2EquatorialOperator)
from astropy.time import Time, TimeDelta
```

- First attemp with nf_sub = 10  , noiseless = True

```{python}
d = qubic.qubicdict.qubicDict()
d.read_from_file(os.environ['QUBIC_DICT']+'/global_source_oneDet.dict')
d['MultiBand'] = True
d['nf_sub'] = 6
d['kind'] = 'I'
d['config'] = 'TD'
d['nside'] = 256
d['dtheta'] = 8
#d['RA_denter'], d['DEC_center'] = 0,0 #qubic.hor2equ(0, 0, 0)
d['synthbeam_fraction'] = 0.99
d['noiseless'] = True
```

Understanding step by step random_pointing... ok, understood it

```{python}
directory = os.environ['QUBIC_TODDIR'] + '150GHz-2019-04-06/'

az = FitsArray(directory + 'Flat/azimuth.fits')
el = FitsArray(directory + 'Flat/elevation.fits')
d['npointings'] = len(az) * len(el)

azcen_fov = np.mean(az)
elcen_fov = np.mean(el)

period = 0.1
p = fh.create_hall_pointing(d, az, el, hor_center = [azcen_fov, elcen_fov], doplot = True,
                            period = period, verbose = False)
```

```{python}
s = qubic.QubicScene(d)
q = qubic.QubicMultibandInstrument(d)

#Compute frequencies
_, nus_edge_in, nus_in, _, _, _ = qubic.compute_freq(d['filter_nu'] / 1e9, d['nf_sub'],
                                                d['filter_relative_bandwidth'])
a = qubic.QubicMultibandAcquisition(q, p, s, d, nus_edge_in)
#del cov
```

pq = qubic.get_pointing(d)
aq = qubic.QubicMultibandAcquisition(q, pq, s, d, nus_edge_in)
if ("covq" not in locals()):
    covq = aq.get_coverage()
    covq = np.mean(covq, axis = 0)
    maskovq = covq > 0.1* np.max(covq)
    covq[~maskovq] = hp.UNSEEN


Testing coverage map.... ok

```{python}
if ("cov" not in locals()):
    cov = a.get_coverage()
    cov = np.mean(cov, axis = 0)
    maskov = cov > 0.1* np.max(cov)
    cov[~maskov] = hp.UNSEEN
centGal = qubic.equ2gal(d['RA_center'], d['DEC_center'])
hp.gnomview(cov, title = "Coverage map", 
            rot = [0,50], reso = 14)
```

subplot(221)
#xlim(28000,28500)
plot(p.azimuth)
subplot(223)
#xlim(28000,28500)
plot(p.elevation)
subplot(222)
xlim(28000,28500)
plot(p.azimuth)
subplot(224)
xlim(28000,28500)
plot(p.elevation)



See at the scan... Ok, works fine

o --->--->--->---> ... --->

                 v

o --->--->--->---> ... --->

                 v

o --->--->--->---> ... --->|


lim = 70
ylim(63,66)
scatter(p.azimuth[:lim], p.elevation[:lim], color = 'k', marker = '.', s = 5)
scatter(p.azimuth[lim:2*lim], p.elevation[lim:2*lim], color = 'r', marker = '.', s = 5)
scatter(p.azimuth[2*lim:3*lim], p.elevation[2*lim:3*lim], color = 'b', marker = '.', s = 5)


#### Generate QUBIC objects (scene, instrument, acquisition)

```{python}
#Create object with TES - PIXEL information and translation between data and simulation
# pix --> qubicsoft (1-256 or 248)
# tes --> qubicdata (1-128)
# index -> TRANSLATOR
FPidentity = pt.make_id_focalplane()
#Check consistncy:

#print("This convert indexes in qinstrument into fp ones")
#print("Index \t TES \t qpix")
#for idet in q[0].detector:
#    print(idet.index[0], '\t', FPidentity[idet.index[0]].TES, '\t', FPidentity[idet.index[0]].PIX)
#    print(" ", "\t", " ", "\t" , tes2pix(FPidentity[idet.index[0]].TES, FPidentity[idet.index[0]].ASIC))
```

#### Generate point source


It doesn't change the equatorial coordinates when changing center...weird. This could be related with the period in QubicSampling

```{python}
#150GHz
idx = 3
psmap = np.zeros((d['nf_sub'], 12 * d['nside'] ** 2))
central_pix = hp.ang2pix(d['nside'], np.deg2rad(90 - elcen_fov), np.deg2rad(azcen_fov))
neig_pixs = hp.get_all_neighbours(d['nside'], central_pix)
psmap[idx, central_pix] = 1e9
psmap[idx] = hp.smoothing(psmap[idx], np.deg2rad(1.0), verbose = False)

fig, ax = subplots(nrows = 1, ncols = 2, figsize = (15,5))
axes(ax[0])
hp.gnomview(psmap[idx], rot = [0,50],#rot = (d['RA_center'], d['DEC_center']), 
            title = 'PS@{:.2f}GHz'.format(nus_in[idx]),
            reso = 10, hold = True)

ax[1].plot(p.equatorial.T[0], label = 'RA')
ax[1].plot(p.equatorial.T[1], label = 'DEC')
ax[1].legend()

```

#### Generate freqs, acquisition operator and observation

```{python}
TOD, maps_convolved_useless = a.get_observation(psmap, noiseless = d['noiseless'])#, convolution = True)
```

Look at the TODs


showtes, showasic = 93, 1
showpix = tes2pix(showtes,showasic)
print(showpix)
imshow(np.reshape(TOD[showpix][::-1], (len(el),len(az)) ))

```{python}
reload(fh)
for ipix in range(len(q[0].detector)):
    idet = q[0].detector[ipix]
    qtes = FPidentity[idet.index[0]].TES
    #print (FPidentity[idet.index[0]].PIX , ipix, qtes)
    FitsArray(np.reshape(TOD[ipix], 
                     (len(el), len(az)))[::-1, :]).save(directory + \
                    'Simulations/Flat/imgflat_TESNum_{}'.format(qtes))
```

#### Choose a qpix (or TES, ASIC) to fit peak position with:

* Flat

* Healpy

```{python}
# Selecting TES number in absolute (1-248) notation:
TES = [149, ] #[149, 28, 37, 60, 96, 101, 122, 124, 137, 140, 149]
tes = np.zeros((len(TES), ), dtype = int)
asic = np.zeros((len(TES), ), dtype = int)
qpix = np.zeros((len(TES), ), dtype = int)
for j, iTES in enumerate(TES):
    tes[j], asic[j] = (iTES, 1) if (iTES < 128) else (iTES - 128, 2)
    # Transform to qubicsoft notation
    print(tes[j], asic[j])
    qpix[j] = tes2pix(tes[j], asic[j]) - 1
    print(qpix[j])

# Select tod to fit in healpy and flat projections (just one)
tod = TOD[qpix[0]]
```

#### Fit flatmap

```{python}
# Build model
sbfitmodel = sbfit.SbModelIndepPeaks(nrings=2, common_fwhm=True, 
                                     no_xy_shift=False, distortion=False)

# Do fit for 1 TES
thexypeaks = np.zeros((len(tes), 4, 9))
flatmaps = np.zeros((len(tes), len(el), len(az) ))
t0 = time.time()

for j, ites in enumerate(tes): 

    print("TES number {} asic number {}".format(ites, asic[j]))
    print("Index number: qpack {} qsoft {} ".format(\
                                pt.tes2index(ites, asic[j]), q[0].detector[qpix[j]].index[0] ))
    print("qubicsoft number: {}".format(qpix[j]))
    _, thexypeaks[j], flatmaps[j] = sbfit.fit_sb(np.reshape(tod, (len(el), len(az))), 
                                                 az, el, sbfitmodel, resample = False, newsize = 150, 
                                                 nsiglo = 100, nsighi = 1e7,
        az_center = azcen_fov, el_center = elcen_fov,
         verbose = False, doplot = True, return_fitted =True,
    figsave = os.environ['QUBIC_DATADIR'] + 'scripts/fit_theoretical_SB/TES{}_flatmap_peaks_fit'.format(ites),
         extra_title='TES #{}'.format(ites))
    clf()

print((time.time()-t0)/60 , 'minutes')
```

#### Saving flat fitting

```{python}
dirfiles = os.environ['QUBIC_TODDIR']+'150GHz-2019-04-06/'
FitsArray(thexypeaks).save(dirfiles + 'FitSB/FlatMaps/fitted_peaks_test')
```

```{python}
#I have to pick len(az)*len(el) data coords from coverage. 
# The fisrt approach is to take the coordinates of the first len(az)*len(el) elements in cov array
#if ("cov" not in locals()):
#    cov = a.get_coverage()
#    cov = np.mean(cov, axis = 0)
#    maskov = cov > 0.1* np.max(cov)
#    cov[~maskov] = hp.UNSEEN
#print(len(np.where(cov != hp.UNSEEN)[0]))

```

To generate Healpix maps from flat projections I need the pointing (az, el) from hk-data. Each (az, el) represents the sky direction towards QUBIC points. Each TES cover a different region in sky. 

* The first point is generate a coverage map for each TES for each frequency in a full scan.

```{python}
#flat to hp with data
hp_pix = hp.ang2pix(d['nside'], np.radians(90 - p.elevation), np.radians(p.azimuth))

regionmap = np.zeros((12*d['nside']**2,))
regionmap[hp_pix] = 1e7
figure(figsize = (11,6))
hp.gnomview(cov, rot = (azcen_fov, elcen_fov), title = 'Coverage', reso = 14, sub = 121)
hp.gnomview(regionmap, rot = (azcen_fov, elcen_fov), title = 'Conv', reso = 14, sub = 122)
```

def select_det(q,idn):
    #### For now the ids are not matched... so we only take the len(id) first detectors...
    detector_i = q.detector[idn]
    q.detector = detector_i
    return(q)


for j, iq in enumerate(q):
    select_det(q[j], qpix[0])
a_ites = qubic.QubicMultibandAcquisition(q_ites, p, s, d, nus_edge_in)



Test if reads is according with format...ok


pruebaxypeaks = np.array(FitsArray(dirfiles + 'FitSB/fitted_peaks_flatmap'))
for i in range(len(TES2fit)):
    scatter(pruebaxypeaks[i,0], pruebaxypeaks[i,1])


Fit peak positions in healpy map (data)

```{python}
reload(fh)
dirfiles = os.environ['QUBIC_TODDIR']+'150GHz-2019-04-06/'
todhp = tod[::-1]
convmap = fh.flat2hp_map(todhp, p.azimuth, p.elevation, nside = d['nside'])
hpnest, thphpeaksnew, absmaxpx = fh.fit_hpmap(TES[0], q[3], s, dirfiles, plot = False, verbose = True,
                                              simulation = True, maps = convmap,
                                       filterbeam = 2, threshold = 4, threshold0 = 3, plotcenter = False)
```

Testing rotation to be implemented in toolfit_healpy.... it works using sbfit tools


auxth,auxph = fh.thph_qsoft(q[2], s, 96, PiRot = True)
auxth, auxph = auxth[0], auxph[0]
hp.mollview(np.zeros((12*d['nside']**2,)), cmap = "bwr" , rot = (0,70))
hp.graticule(verbose = False)
hp.projscatter(auxth, auxph, color = "r", )#rot = [0, 20, 0])
newth, newph = sbfit.rotate_q2m(auxth, auxph, angs = np.radians(np.array([azcen_fov, elcen_fov, azcen_fov])))
#rotation(np.asarray([np.rad2deg(auxth).T, np.rad2deg(auxph).T]).T).T
hp.projscatter(newth, newph, color = "b",)# rot = (0,0,0))

sbfit.rotate_q2m

```{python}
allthetas_M = np.radians(90 - thexypeaks[0,1,:])
allphis_M = np.radians(thexypeaks[0,0,:])#*thecos)
#angs = np.radians(np.array([0, 90, 0]))
##allthetas_Q[idet,:], allphis_Q[idet,:] = sbfit.rotate_q2m(allthetas_M[idet,:], allphis_M[idet,:],  angs=angs, inverse=True)
#allthetas_Q, allphis_Q = sbfit.rotate_q2m(allthetas_M, allphis_M, angs=angs, inverse=True)
## pi rotation of the measured SB w.r.t. simulations => we apply it here
#allphis_Q += np.pi

fig, ax = subplots(nrows = 1, ncols = 2, figsize = (14,8))

axes(ax[0])
funcpr= hp.gnomview
funcpr(hpnest, nest = True, min = 0, cbar= False, rot = (azcen_fov, elcen_fov),
            title = 'Fitting (hp) TES = {}'.format(tes), hold = True, reso = 12)
hp.projscatter(thphpeaksnew.T, color = 'r', marker = '.')
hp.graticule(verbose = False)

im = ax[1].imshow(np.reshape(TOD[qpix[0]], (len(el), len(az))), 
             extent = [np.min(az) * np.cos(np.radians(elcen_fov)),
                               np.max(az) * np.cos(np.radians(elcen_fov)),
                               np.min(el), np.max(el)],  )
ax[1].plot(thexypeaks[0,0,:], thexypeaks[0,1,:], 'r.')
#fig.colorbar(im, ax = ax[1])
ax[1].set_title('Fitting (flat) TES {}'.format(tes))
#ax[1].axvline(d['RA_center'], color = 'k')
#ax[1].axhline(d['DEC_center'], color = 'k')
print(ax[1].get_ylim())
```

Testing fh function to convert from id's systems... it works fine! 


reload(fh)
fh.test_fit(q[2], s, 149, id_fp_sys = "FileName", verbose = True)
fh.test_fit(q[2], s, 21, asic = 2, id_fp_sys = "TESName", verbose = True)
fh.test_fit(q[2], s, 96, id_fp_sys = "qsName", verbose = True)


```{python}

```

```{python}
from lmfit import Model
from lmfit.model import save_modelresult
from scipy.interpolate import interp1d
from scipy.special import j0,j1,jn

class test_fit:
    
    def __init__(self, q, s, pixnum, asic = None, id_fp_sys = "FileName", 
                 npix = None, tes = None, asic = None, qpix = None):
        
        """
        pixnum:
            Could be: pixel detector number (id_fp_sys = "FileName"), 
                      QubicInstrument detector number (id_fp_sys = 'qsName')
                      TES, ASIC detector number (id_fp_sys = 'TESName')
        id_fp_sys: 
            FileName --> user provides the number of TES in this convention: 1 - 256 in continuos way. This
                        convention is not equal to the qubicsoft indexing. 
                    kw needed: npix
            TESName --> user provides (tes, asic)
                    kw needed: tes, asic
            qsName --> qubicsoft indexing
                    kw needed: qpix
            
        """
        
        self.inst = q
        self.scene = s
        self._init_id(id_fp_sys, pixnum, asic = asic)
        
    def _init_id(self, ident_focalplane, num, asic = None):
        """
        Generates focal plane identifications from user input
        Parameter:
            num: is the detector or pixel number. 
            asic: ASIC number if ident_focalplane = TESName and num has to be the tes number.
        """
        FPidentity = pt.make_id_focalplane()
        
        if ident_focalplane == 'FileName':
            self.npix = num
            self.tes, self.asic = (self.npix, 1) if (self.npix < 128) else (self.npix - 128, 2)
            self.qpix = tes2pix(self.tes, self.asic) - 1
        elif ident_focalplane == 'qsName':
            self.qpix = num
            det_index = self.inst[self.qpix].index[0]
            self.tes = FPidentity[det_index].TES
            self.asic = FPidentity[det_index].ASIC
            self.npix = self.tes if self.asic == 1  else self.tes + 128
        elif ident_focalplane == 'TESName':
            if num > 128:
                raise ValueError("Wrong TES value. You gave a TES number greater than 128.")
            else:
                if asic == None:
                    raise ValueError("You choose {} identification but ASIC number is missing.".format(ident_focalplane))
                else: 
                    self.tes = num
                    self.asic = asic
                    self.npix = self.tes if self.asic == 1  else self.tes + 128
                    self.qpix = tes2pix(self.tes, self.asic) - 1
        return
    
#print("Index \t TES \t qpix")
#for idet in q[0].detector:
#    print(idet.index[0], '\t', FPidentity[idet.index[0]].TES, '\t', FPidentity[idet.index[0]].PIX)


        
    def initial_center():
        return a0+a1*x+a2*x**2/2+a3*x**3/3+a4*x**4/4+a5*x**5/5+a6*x**6/6 + \
                a7*x**7/7+a8*x**8/8+a9*x**9/9+a10*x**10/10+a11*x**11/11+a12*x**12/12

#polynomial
gmodel_pol = Model(model_pol, independent_vars=['x',], )
params_pol = gmodel_pol.make_params(a0=1,a1=1,a2=1,a3=1,a4=1,a5=1,a6=1,a7=1,a8=1,a9=1,a10=1,a11=1,a12=1 )
result_pol = gmodel_pol.fit(yFPSF, params_pol, x=xFPSF)
parspol = list(result_pol.best_values.values())
print('Pol. Chi2 {:.3f}'.format(result_pol.chisqr) )

```

```{python}

```

```{python}

```

```{python}

```

Get healpix map for a tes in q instrument

```{python}
hp.gnomview(q[2].get_synthbeam(s)[qpix[0]], rot = [azcen_fov, elcen_fov], reso = 12)
```

```{python}

```

```{python}

```

H = a.get_operator()


print(np.shape(H.T),)# 196608/12/128/128, 12*128**2, d['npointings'] * 248)


#print('Operator ', a.get_operator())
print(len(a.instrument), len(a.sampling))
print(a.comm.allreduce(len(a.instrument)))
print(a.comm.allreduce(len(a.sampling)))
print('Period ', a.sampling.period)
print(a.comm.allreduce(len(a.instrument)) * a.comm.allreduce(len(a.sampling)) * a.sampling.period)

```{python}
cov = a.get_coverage()
```

```{python}
figure(figsize = (14,6))
hp.mollview(cov, sub = (131), rot = (0,0))
hp.mollview(psmap[0], sub=(132), rot = (0,0))
```

d['tol'] = 1e-3
d['nf_recon'] = 1
maps_recon, _, _ = a.tod2map(TOD, d, cov = cov)

```{python}

```
