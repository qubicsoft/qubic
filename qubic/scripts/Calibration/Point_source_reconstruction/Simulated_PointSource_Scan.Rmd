---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.7.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

 one thing that wuld be useful by the way, and maybe you could have a lok at this if you want:
we would be in a much better situation for developping the reconstruction code if we had simualted data to play with. I mean simulate the observation of a source in the hall at 150 GHz with the theoretical SB => reproduce the Flat Beam Maps but with the theory, with the exact same pointing values
so that we could:
- test the reconstruction code
- Try the SB Peak fitting on these
- See how the multiband reconstruction behaves with "true peak positions" and with the fitted values


```{python}
# %matplotlib inline

# system packages
import os
import sys
from importlib import reload 
import time
from warnings import warn

# scientific packages
import numpy as np
import healpy as hp
from matplotlib.pyplot import *
from scipy.fftpack import rfft, rfftfreq

# QUBIC packages
import qubic
from qubicpack.utilities import Qubic_DataDir
from pysimulators import FitsArray
from qubic import demodulation_lib as dl
from qubic import sb_fitting as sbfit
import toolfit_hpmap as fh
from qubicpack import pixel_translation as pt
from qubicpack.pix2tes import assign_tes_grid, tes2pix
from pyoperators import (
    Cartesian2SphericalOperator,
    Rotation3dOperator,
    Spherical2CartesianOperator)
from pysimulators import ( 
    CartesianEquatorial2HorizontalOperator,
    CartesianHorizontal2EquatorialOperator)
from astropy.time import Time, TimeDelta
```

```{python}
def generate_region(az, el):
    """
    Generates the squared region scanned in the hall from the azimuth&elevation coordinates
    saved in housekeeping data.
    
    Return a grid with coordinates
    """
    mult_el = []
    for eachEl in el:
        mult_el.extend(np.tile(eachEl, len(az)))
    mult_el = mult_el[::-1]
    mult_az = []
    mult_az.append(np.tile(az, len(el)))
    
    return mult_az, mult_el

def create_hall_pointing(d, az, el, hor_center, angspeed_psi = 0, maxpsi = 0, period = 0,
                 date_obs = None, latitude = None, longitude = None, doplot = False,
                 fix_azimuth = None, random_hwp = True, verbose = False):
    
    '''
    Model of the pointing used in the hall. No back and forth. 
    
    Input coordinates are az, el. The function authomatically will convert (az, el) into (phi, theta) 
    defined as qubic.sampling.create_random_pointing to match with qubicsoft. 
    
    The coverage map center the region in hor_center coordinates. Take it into account for 
    plotting and projecting maps
    
    Parameters:
        d: QUBIC dictionary
        az, el: azimuth and elevation data from housekeeping data or fits file. 1-d array
        period: QubicSampling parameter. If equal to zero, it matches with transformation from az,el
        to ra, dec using qubic.hor2equ(az, el time = 0). Otherwise is not equal. Default: zero. 
        hor_center: center of the FOV
    Return: 
        QUBIC's pointing object
    '''

    nsamples = len(az)*len(el)
    
    mult_az, mult_el = generate_region(az,el)
    theta = np.array(mult_el) #- np.mean(el)
    phi = np.array(mult_az[0]) #- np.mean(az)
    
    # By defalut it computes HorizontalSampling in with SphericalSamplig
    pp = qubic.QubicSampling(nsamples, #azimuth = mult_az[0], elevation = mult_el[0],
                             date_obs = d['date_obs'], period = period, 
                            latitude = latitude, longitude = longitude)
    
    time = pp.date_obs + TimeDelta(pp.time, format='sec')
    
    c2s = Cartesian2SphericalOperator('azimuth,elevation', degrees=True)
    h2e = CartesianHorizontal2EquatorialOperator(
        'NE', time, pp.latitude, pp.longitude)
    s2c = Spherical2CartesianOperator('elevation,azimuth', degrees=True)
    
    rotation = c2s(h2e(s2c))
    coords = rotation(np.asarray([theta.T, phi.T]).T)

    pp.elevation = mult_el
    pp.azimuth = mult_az[0]
    pp.equatorial[:,0] = coords[:,0]
    pp.equatorial[:,1] = coords[:,1]

    if doplot:
        fig, ax = subplots(nrows = 1, ncols = 2, figsize = (14,6))
        pixsH = hp.ang2pix(d['nside'], np.radians(90 - theta), np.radians(phi))
        mapaH = np.ones((12*256**2))
        mapaH[pixsH] = 100
        axes(ax[0])
        hp.mollview(mapaH, title = "Horizontal coordinates", hold = True)
        hp.graticule(verbose = False)
        pixsEq = hp.ang2pix(d['nside'], np.radians(90 - pp.equatorial[:,1]), np.radians(pp.equatorial[:,0]))
        mapaEq = np.ones((12*256**2))
        mapaEq[pixsEq] = 100
        axes(ax[1])
        hp.mollview(mapaEq, title = "Equatorial coordinates", hold = True)
        hp.graticule(verbose = False)
        
    
    if period < 1e-4:
        newcenter = qubic.hor2equ(azcen_fov, elcen_fov, 0)
    else:
        newcenter = qubic.hor2equ(azcen_fov, elcen_fov, pp.time[int(len(pp.time)/2)])

    warn("Update RA, DEC in dictionary")
    d['RA_center'], d['DEC_center'] = newcenter[0], newcenter[1]
    # center = ra, dec
    #center = (d['RA_center'], d['DEC_center'])

    if verbose: print("Time: len(time) = {} \n t0 {} \n time/2 {} \n tf {}".format(time, 
                                                                                   time[0],
                                                                                   time[int(len(time)/2)],
                                                                                  time[-1])  )
    
    ### scan psi as well,
    pitch = pp.time * angspeed_psi
    pitch = pitch % (4 * maxpsi)
    mask = pitch > (2 * maxpsi)
    pitch[mask] = -pitch[mask] + 4 * maxpsi
    pitch -= maxpsi
    
    pp.pitch = pitch
    
    if random_hwp:
        pp.angle_hwp = np.random.randint(0, 7, nsamples) * 11.25
        
    if d['fix_azimuth']['apply']:
        pp.fix_az=True
        if d['fix_azimuth']['fix_hwp']:
            pp.angle_hwp=pp.pitch*0+ 11.25
        if d['fix_azimuth']['fix_pitch']:
            pp.pitch= 0
    else:
        pp.fix_az=False

    return pp

```

- First attemp with nf_sub = 10  , noiseless = True

```{python}
d = qubic.qubicdict.qubicDict()
d.read_from_file(os.environ['QUBIC_DICT']+'/global_source_oneDet.dict')
d['MultiBand'] = True
d['nf_sub'] = 6
d['kind'] = 'I'
d['config'] = 'TD'
d['nside'] = 256
d['dtheta'] = 8
#d['RA_denter'], d['DEC_center'] = 0,0 #qubic.hor2equ(0, 0, 0)
d['synthbeam_fraction'] = 0.99
d['noiseless'] = True
```

Understanding step by step random_pointing... ok, understood it

```{python}
directory = os.environ['QUBIC_TODDIR'] + '150GHz-2019-04-06/'

az = FitsArray(directory + 'Flat/azimuth.fits')
el = FitsArray(directory + 'Flat/elevation.fits')
d['npointings'] = len(az) * len(el)

azcen_fov = np.mean(az)
elcen_fov = np.mean(el)

period = 0.1
p = create_hall_pointing(d, az, el, hor_center = [azcen_fov, elcen_fov], doplot = True,
                            period = period, verbose = False)
```

```{python}
s = qubic.QubicScene(d)
q = qubic.QubicMultibandInstrument(d)

#Compute frequencies
_, nus_edge_in, nus_in, _, _, _ = qubic.compute_freq(d['filter_nu'] / 1e9, d['nf_sub'],
                                                d['filter_relative_bandwidth'])
a = qubic.QubicMultibandAcquisition(q, p, s, d, nus_edge_in)
#del cov
```

pq = qubic.get_pointing(d)
aq = qubic.QubicMultibandAcquisition(q, pq, s, d, nus_edge_in)
if ("covq" not in locals()):
    covq = aq.get_coverage()
    covq = np.mean(covq, axis = 0)
    maskovq = covq > 0.1* np.max(covq)
    covq[~maskovq] = hp.UNSEEN

```{python}
if ("cov" not in locals()):
    cov = a.get_coverage()
    cov = np.mean(cov, axis = 0)
    maskov = cov > 0.1* np.max(cov)
    cov[~maskov] = hp.UNSEEN
centGal = qubic.equ2gal(d['RA_center'], d['DEC_center'])
hp.gnomview(cov, title = "Coverage map", 
            rot = [0,50], reso = 14)
```

subplot(221)
#xlim(28000,28500)
plot(p.azimuth)
subplot(223)
#xlim(28000,28500)
plot(p.elevation)
subplot(222)
xlim(28000,28500)
plot(p.azimuth)
subplot(224)
xlim(28000,28500)
plot(p.elevation)



See at the scan... Ok, works fine

o --->--->--->---> ... --->

                 v

o --->--->--->---> ... --->

                 v

o --->--->--->---> ... --->|


lim = 70
ylim(63,66)
scatter(p.azimuth[:lim], p.elevation[:lim], color = 'k', marker = '.', s = 5)
scatter(p.azimuth[lim:2*lim], p.elevation[lim:2*lim], color = 'r', marker = '.', s = 5)
scatter(p.azimuth[2*lim:3*lim], p.elevation[2*lim:3*lim], color = 'b', marker = '.', s = 5)


#### Generate QUBIC objects (scene, instrument, acquisition)

```{python}
#Create object with TES - PIXEL information and translation between data and simulation
# pix --> qubicsoft (1-256 or 248)
# tes --> qubicdata (1-128)
# index -> TRANSLATOR
FPidentity = pt.make_id_focalplane()
#FPidentity = FPfull[np.where(FPfull.quadrant == 3)[0]]
#Check consistncy:
print("This convert indexes in qinstrument into fp ones")
print("Index \t TES \t qpix")
for idet in q[0].detector:
    print(idet.index[0], '\t', FPidentity[idet.index[0]].TES, '\t', FPidentity[idet.index[0]].PIX)
    print(" ", "\t", " ", "\t" , tes2pix(FPidentity[idet.index[0]].TES, FPidentity[idet.index[0]].ASIC))
```

#### Generate point source


It doesn't change the equatorial coordinates when changing center...weird. This could be related with the period in QubicSampling

```{python}
#150GHz
idx = 3
psmap = np.zeros((d['nf_sub'], 12 * d['nside'] ** 2))
central_pix = hp.ang2pix(d['nside'], np.deg2rad(90 - elcen_fov), np.deg2rad(azcen_fov))
neig_pixs = hp.get_all_neighbours(d['nside'], central_pix)
psmap[idx, central_pix] = 1e9
psmap[idx] = hp.smoothing(psmap[idx], np.deg2rad(1.0), verbose = False)

fig, ax = subplots(nrows = 1, ncols = 2, figsize = (15,5))
axes(ax[0])
hp.gnomview(psmap[idx], rot = [0,50],#rot = (d['RA_center'], d['DEC_center']), 
            title = 'PS@{:.2f}GHz'.format(nus_in[idx]),
            reso = 10, hold = True)

ax[1].plot(p.equatorial.T[0], label = 'RA')
ax[1].plot(p.equatorial.T[1], label = 'DEC')
ax[1].legend()

```

#### Generate freqs, acquisition operator and observation

```{python}
TOD, maps_convolved_useless = a.get_observation(psmap, noiseless = d['noiseless'])#, convolution = True)
```

Look at the TODs


showtes, showasic = 93, 1
showpix = tes2pix(showtes,showasic)
print(showpix)
imshow(np.reshape(TOD[showpix][::-1], (len(el),len(az)) ))

```{python}
reload(fh)
for ipix in range(len(q[0].detector)):
    idet = q[0].detector[ipix]
    qtes = FPidentity[idet.index[0]].TES
    #print (FPidentity[idet.index[0]].PIX , ipix, qtes)
    FitsArray(np.reshape(TOD[ipix], 
                     (len(el), len(az)))[::-1, :]).save(directory + \
                    'Simulations/Flat/imgflat_TESNum_{}'.format(qtes))
#imshow(np.reshape(TOD[fh.q_pix(ites)[0]], (len(el), len(az)))[::-1, :] )
#colorbar(None)
#subplot(122)
#map_test = sbfit.get_flatmap(100, directory)[0]
#imshow(map_test)
```

#### Choose a qpix (or TES, ASIC) to fit peak position with:

* Flat

* Healpy

```{python}
# Selecting TES number in absolute (1-248) notation:
TES = [149, ] #[149, 28, 37, 60, 96, 101, 122, 124, 137, 140, 149]
tes = np.zeros((len(TES), ), dtype = int)
asic = np.zeros((len(TES), ), dtype = int)
qpix = np.zeros((len(TES), ), dtype = int)
for j, iTES in enumerate(TES):
    tes[j], asic[j] = (iTES, 1) if (iTES < 128) else (iTES - 128, 2)
    # Transform to qubicsoft notation
    print(tes[j], asic[j])
    qpix[j] = tes2pix(tes[j], asic[j]) - 1
    print(qpix[j])

# Select tod to fit in healpy and flat projections (just one)
tod = TOD[qpix[0]]
```

#### Fit flatmap

```{python}
# Build model
sbfitmodel = sbfit.SbModelIndepPeaks(nrings=2, common_fwhm=True, 
                                     no_xy_shift=False, distortion=False)

# Do fit for 1 TES
thexypeaks = np.zeros((len(tes), 4, 9))
flatmaps = np.zeros((len(tes), len(el), len(az) ))
t0 = time.time()

for j, ites in enumerate(tes): 

    print("TES number {} asic number {}".format(ites, asic[j]))
    print("Index number: qpack {} qsoft {} ".format(\
                                pt.tes2index(ites, asic[j]), q[0].detector[qpix[j]].index[0] ))
    print("qubicsoft number: {}".format(qpix[j]))
    _, thexypeaks[j], flatmaps[j] = sbfit.fit_sb(np.reshape(tod, (len(el), len(az))), 
                                                 az, el, sbfitmodel, resample = False, newsize = 150, 
                                                 nsiglo = 100, nsighi = 1e7,
        az_center = azcen_fov, el_center = elcen_fov,
         verbose = False, doplot = True, return_fitted =True,
    figsave = os.environ['QUBIC_DATADIR'] + 'scripts/fit_theoretical_SB/TES{}_flatmap_peaks_fit'.format(ites),
         extra_title='TES #{}'.format(ites))
    clf()

print((time.time()-t0)/60 , 'minutes')
```

#### Saving flat fitting

```{python}
dirfiles = os.environ['QUBIC_TODDIR']+'150GHz-2019-04-06/'
FitsArray(thexypeaks).save(dirfiles + 'FitSB/FlatMaps/fitted_peaks_test')
```

```{python}
#I have to pick len(az)*len(el) data coords from coverage. 
# The fisrt approach is to take the coordinates of the first len(az)*len(el) elements in cov array
if ("cov" not in locals()):
    cov = a.get_coverage()
    cov = np.mean(cov, axis = 0)
    maskov = cov > 0.1* np.max(cov)
    cov[~maskov] = hp.UNSEEN
print(len(np.where(cov != hp.UNSEEN)[0]))

```

To generate Healpix maps from flat projections I need the pointing (az, el) from hk-data. Each (az, el) represents the sky direction towards QUBIC points. Each TES cover a different region in sky. 

* The first point is generate a coverage map for each TES for each frequency in a full scan.

```{python}

```

```{python}
qites = qubic.QubicMultibandInstrument(d)
qites = q.detector_subset(qpix[0])

#flat to hp with data
hp_pix = hp.ang2pix(d['nside'], np.pi - np.radians(p.elevation), np.radians(p.azimuth))
print(hp_pix)

regionmap = np.zeros((12*d['nside']**2,))
regionmap[hp_pix] = 1.
hp.gnomview(cov, rot = (0, 50), title = 'Coverage', reso = 14, sub = 121)
hp.gnomview(regionmap, rot = (0,-elcen_fov, 180), title = 'Conv', reso = 14, sub = 122)
```

```{python}
def select_det(q,idn):
    #### For now the ids are not matched... so we only take the len(id) first detectors...
    detector_i = q.detector[idn]
    q.detector = detector_i
    return(q)
```

```{python}
for j, iq in enumerate(q):
    select_det(q[j], qpix[0])
a_ites = qubic.QubicMultibandAcquisition(q_ites, p, s, d, nus_edge_in)

```

Test if reads is according with format...ok


pruebaxypeaks = np.array(FitsArray(dirfiles + 'FitSB/fitted_peaks_flatmap'))
for i in range(len(TES2fit)):
    scatter(pruebaxypeaks[i,0], pruebaxypeaks[i,1])


Fit peak positions in healpy map (data)

```{python}
reload(fh)
dirfiles = os.environ['QUBIC_TODDIR']+'150GHz-2019-04-06/'

tes_fileconv = TES2fit[0]
hpnest, thphpeaksnew, absmaxpx = fh.fit_hpmap(tes_fileconv, q[3], s, dirfiles, plot = False,
                                       filterbeam = 2, threshold = 2, threshold0 = 2, plotcenter = False)
```

```{python}
allthetas_M = np.radians(90 - (thexypeaks[0,1,:] - elcen_fov))
allphis_M = np.radians(-thexypeaks[0,0,:])#*thecos)
angs = np.radians(np.array([0, 90, 0]))
#allthetas_Q[idet,:], allphis_Q[idet,:] = sbfit.rotate_q2m(allthetas_M[idet,:], allphis_M[idet,:],  angs=angs, inverse=True)
allthetas_Q, allphis_Q = sbfit.rotate_q2m(allthetas_M, allphis_M, angs=angs, inverse=True)
# pi rotation of the measured SB w.r.t. simulations => we apply it here
allphis_Q += np.pi

fig, ax = subplots(nrows = 1, ncols = 2, figsize = (14,8))

axes(ax[0])
hp.gnomview(hpnest, nest = True, reso = 10, min = 0, max= 1e4, cbar= False, rot = (0,0),
            title = 'Fitting (hp) TES = {}'.format(tes_fileconv), hold = True)
hp.projscatter(thphpeaksnew.T, color = 'r', marker = '.')
hp.graticule(verbose = False)
_qidx_ = tes2pix(tes_fileconv if (tes_fileconv < 128) else tes_fileconv -128, _asic_)
#print(TES2fit[0],_asic_,_qidx_)
im = ax[1].imshow(np.reshape(TOD[_qidx_], (len(el), len(az))), 
             extent = [np.min(az) * np.cos(np.radians(elcen_fov)),
                               np.max(az) * np.cos(np.radians(elcen_fov)),
                               np.min(el), np.max(el)],  )
ax[1].plot(thexypeaks[TES2fit.index(tes_fileconv),0,:], thexypeaks[TES2fit.index(tes_fileconv),1,:], 'r.')
#fig.colorbar(im, ax = ax[1])
ax[1].set_title('Fitting (flat) TES {}'.format(tes_fileconv))
ax[1].axvline(d['RA_center'], color = 'k')
ax[1].axhline(d['DEC_center'], color = 'k')
print(ax[1].get_ylim())
```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}
import scipy.signal as scsig
import qubic.fibtools as ft

flatmap = scsig.resample(scsig.resample(np.reshape(TOD[93], (len(el), len(az))), 144, axis=0), 200, axis=1)
azaux = np.linspace(np.min(az), np.max(az), 200)
elaux = np.linspace(np.min(el), np.max(el), 144)
az2d, el2d = np.meshgrid(az * np.cos(np.radians(50)), np.flip(el))
mm, ss = ft.meancut(flatmap, 3)
```

```{python}
subplot(121)
imshow(flatmap, vmin = mm - 100 * ss, vmax = mm + 2000 * ss)
subplot(122)
imshow(np.reshape(TOD[93], (len(el), len(az))))
```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

H = a.get_operator()


print(np.shape(H.T),)# 196608/12/128/128, 12*128**2, d['npointings'] * 248)


#print('Operator ', a.get_operator())
print(len(a.instrument), len(a.sampling))
print(a.comm.allreduce(len(a.instrument)))
print(a.comm.allreduce(len(a.sampling)))
print('Period ', a.sampling.period)
print(a.comm.allreduce(len(a.instrument)) * a.comm.allreduce(len(a.sampling)) * a.sampling.period)

```{python}
cov = a.get_coverage()
```

```{python}
figure(figsize = (14,6))
hp.mollview(cov, sub = (131), rot = (0,0))
hp.mollview(psmap[0], sub=(132), rot = (0,0))
```

d['tol'] = 1e-3
d['nf_recon'] = 1
maps_recon, _, _ = a.tod2map(TOD, d, cov = cov)

```{python}

```
