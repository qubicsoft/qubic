---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.7.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

 one thing that wuld be useful by the way, and maybe you could have a lok at this if you want:
we would be in a much better situation for developping the reconstruction code if we had simualted data to play with. I mean simulate the observation of a source in the hall at 150 GHz with the theoretical SB => reproduce the Flat Beam Maps but with the theory, with the exact same pointing values
so that we could:
- test the reconstruction code
- Try the SB Peak fitting on these
- See how the multiband reconstruction behaves with "true peak positions" and with the fitted values


```{python}
# %matplotlib inline

# system packages
import os
import sys
from importlib import reload 
import time

# scientific packages
import numpy as np
import healpy as hp
from matplotlib.pyplot import *
from scipy.fftpack import rfft, rfftfreq

# QUBIC packages
import qubic
from qubicpack.utilities import Qubic_DataDir
from pysimulators import FitsArray
from qubic import demodulation_lib as dl
from qubic import sb_fitting as sbfit
import toolfit_hpmap as fh
from qubicpack import pixel_translation as pt
from qubicpack.pix2tes import assign_tes_grid, tes2pix
from pyoperators import (
    Cartesian2SphericalOperator,
    Rotation3dOperator,
    Spherical2CartesianOperator)
from pysimulators import ( 
    CartesianEquatorial2HorizontalOperator)
from astropy.time import Time, TimeDelta
```

```{python}
def generate_region(az, el):
    """
    Generates the squared region scanned in the hall from the azimuth&elevation coordinates
    saved in housekeeping data.
    
    Return a grid with coordinates
    """
    mult_el = []
    for eachEl in el:
        mult_el.extend(np.tile(eachEl, len(az)))
    mult_el = mult_el[::-1]
    mult_az = []
    mult_az.append(np.tile(az, len(el)))
    
    return mult_az, mult_el

def create_hall_pointing(d, az, el, center = None, angspeed_psi = 0, maxpsi = 0, period = 0,
                 date_obs = None, latitude = None, longitude = None, 
                 fix_azimuth = None, random_hwp = True, verbose = False):
    
    '''
    Model of the pointing used in the hall. No back and forth. 
    
    Input coordinates are az, el. The function authomatically will convert (az, el) into (phi, theta) 
    defined as qubic.sampling.create_random_pointing to match with qubicsoft. 
    
    Parameters:
        d: QUBIC dictionary
        az, el: azimuth and elevation data from housekeeping data or fits file. 1-d array
        period: QubicSampling parameter. If equal to zero, it matches with transformation from az,el
        to ra, dec using qubic.hor2equ(az, el time = 0). Otherwise is not equal. Default: zero. 
    Return: 
        QUBIC's pointing object
    '''

    nsamples = len(az)*len(el)
    
    mult_az, mult_el = generate_region(az,el)
    theta = np.array(mult_el) - np.mean(el)
    phi = np.array(mult_az[0]) - np.mean(az)
    
    # center = ra, dec
    center = 
    if verbose: print(theta, "\n", phi)
        
    pp = qubic.QubicSampling(nsamples, #azimuth = mult_az[0], elevation = mult_el[0],
                             date_obs = d['date_obs'], period = period, 
                            latitude = latitude, longitude = longitude)
    
    time = pp.date_obs + TimeDelta(pp.time, format='sec')
    
    if verbose: print("Time: len(time) = {} \n t0 {} \n time/2 {} \n tf {}".format(time, 
                                                                                   time[0],
                                                                                   time[int(len(time)/2)],
                                                                                  time[-1])  )
    
    #Same convertion as qubic sampling to obtain equatorial coordinates
    c2s = Cartesian2SphericalOperator('azimuth,elevation', degrees=True)
    if verbose: print("long, lat, time: {} {}".format(pp.longitude, pp.latitude, time) )
    e2h = CartesianEquatorial2HorizontalOperator(
        'NE', time, pp.latitude, pp.longitude)
    rot = Rotation3dOperator("ZY'", center[0], 90 - center[1], degrees=True)
    s2c = Spherical2CartesianOperator('zenith,azimuth', degrees=True)
    rotation = c2s(e2h(rot(s2c)))
    coords = rotation(np.asarray([theta.T, phi.T]).T)
    
    pp.elevation = coords[..., 1]#np.asarray(mult_el)
    pp.azimuth = coords[..., 0]#np.asarray(mult_az[0])
    
    ### scan psi as well,
    pitch = pp.time * angspeed_psi
    pitch = pitch % (4 * maxpsi)
    mask = pitch > (2 * maxpsi)
    pitch[mask] = -pitch[mask] + 4 * maxpsi
    pitch -= maxpsi
    
    pp.pitch = pitch
    
    if random_hwp:
        pp.angle_hwp = np.random.random_integers(0, 7, nsamples) * 11.25
        
    if d['fix_azimuth']['apply']:
        pp.fix_az=True
        if d['fix_azimuth']['fix_hwp']:
            pp.angle_hwp=pp.pitch*0+ 11.25
        if d['fix_azimuth']['fix_pitch']:
            pp.pitch= 0
    else:
        pp.fix_az=False

    return pp

```

- First attemp with nf_sub = 10  , noiseless = True

```{python}
d = qubic.qubicdict.qubicDict()
d.read_from_file(os.environ['QUBIC_DICT']+'/global_source_oneDet.dict')
d['MultiBand'] = True
d['nf_sub'] = 6
d['kind'] = 'I'
d['config'] = 'TD'
d['nside'] = 256
d['dtheta'] = 8
#d['RA_denter'], d['DEC_center'] = 0,0 #qubic.hor2equ(0, 0, 0)
d['synthbeam_fraction'] = 0.99
d['noiseless'] = True
```

Understanding step by step random_pointing... ok, understood it


d['npointings'] = 900
center = [d['RA_center'], d['DEC_center']]
cosdtheta = np.cos(np.radians(d['dtheta']))
seed = np.random.seed(None)
r = np.random.RandomState(seed)
# asumen ser ra, dec
phi2 = r.rand(d['npointings']) * 360
theta2 =np.degrees(np.arccos(cosdtheta + (1 - cosdtheta) * r.rand(d['npointings'])))

ptest = qubic.QubicSampling(
        d['npointings'], date_obs = d['date_obs'], period = d['period'], 
    latitude = None, longitude = None)
print("Before transformations and rotations")
plot(phi2,
     theta2,
     'ko')
time = ptest.date_obs + TimeDelta(ptest.time, format='sec')
c2s = Cartesian2SphericalOperator('azimuth,elevation', degrees=True)
e2h = CartesianEquatorial2HorizontalOperator(
    'NE', time, ptest.latitude, ptest.longitude)
rot = Rotation3dOperator("ZY'", center[0], 90 - center[1], degrees=True)
s2c = Spherical2CartesianOperator('zenith,azimuth', degrees=True)
rotation = c2s(e2h(rot(s2c)))
coords = rotation(np.asarray([theta2.T, phi2.T]).T)
ptest.azimuth = coords[..., 0]
ptest.elevation = coords[..., 1]

figure(figsize = (14,6))
subplot(141)
title("Cart. cenital cap (ph, th)")
plot(phi2, theta2, "ko")
subplot(142)
title("Sp. cenital cap (ph, th)")
plot(np.sin(np.radians(theta2))*np.cos(np.radians(phi2))*360/2/np.pi,
     np.sin(np.radians(theta2))*np.sin(np.radians(phi2))*360/2/np.pi,"k.")
subplot(143)
title("Sp. Equatorial (p.eq[:,0],p.eq[:,1])")
aux = ptest.equatorial[...,0]
aux[aux>50] = aux[aux>50]-360
plot(aux , ptest.equatorial[...,1], "b.")
subplot(144)
title("Horizontal coordinates")
plot(ptest.azimuth, ptest.elevation, "m.")

```{python}
directory = os.environ['QUBIC_TODDIR'] + '150GHz-2019-04-06/'

az = FitsArray(directory + 'Flat/azimuth.fits')
el = FitsArray(directory + 'Flat/elevation.fits')
d['npointings'] = len(az) * len(el)

azcen_fov = np.mean(az)
elcen_fov = np.mean(el)

newcenter = qubic.hor2equ(azcen_fov, elcen_fov, 0)
d['RA_center'], d['DEC_center'] = newcenter[0], newcenter[1]

pp00 = create_hall_pointing(d, az, el, center = newcenter, period = 0., verbose = False)
pp01 = create_hall_pointing(d, az, el, center = newcenter, period = 0.1, verbose = False)

# convert deg in rad
phi00, theta00 = np.radians(pp00.equatorial[:,0]), np.radians(90 - pp00.equatorial[:,1])
phi01, theta01 = np.radians(pp01.equatorial[:,0]), np.radians(90 - pp01.equatorial[:,1])
# convert ang2pix
pix00 = hp.ang2pix(d['nside'], theta00, phi00)
map00 = np.ones((12*256**2))
map00[pix00] = 100

pix01 = hp.ang2pix(d['nside'], theta01, phi01)
map01 = np.ones((12*256**2))
map01[pix01] = 100

hp.gnomview(map00, sub = 121, rot = newcenter, reso = 12, coord = "C")
hp.gnomview(map01, sub = 122, rot = newcenter, reso = 12, coord = "C")
```

```{python}
subplot(221)
xlim(28000,28500)
plot(pp00.azimuth)
subplot(223)
xlim(28000,28500)
plot(pp00.elevation)
subplot(222)
xlim(28000,28500)
plot(pp01.azimuth)
subplot(224)
xlim(28000,28500)
plot(pp01.elevation)

```

```{python}
directory = os.environ['QUBIC_TODDIR'] + '150GHz-2019-04-06/'

az = FitsArray(directory + 'Flat/azimuth.fits')
el = FitsArray(directory + 'Flat/elevation.fits')
d['npointings'] = len(az) * len(el)

azcen_fov = np.mean(az)
elcen_fov = np.mean(el)

print('Central FOV (A,h) = ', azcen_fov, elcen_fov)
usehor = False
if usehor:
    d['RA_center'], d['DEC_center'] = azcen_fov, elcen_fov
    mult_az, mult_el = generate_region(az,el)
    print("Lengths az, el {} {}".format(len(mult_az[0]), len(mult_el)))
    theta = np.array(mult_el) - elcen_fov
    phi = np.array(mult_az[0]) - azcen_fov
else:
    newcenter = qubic.hor2equ(azcen_fov, elcen_fov, 0)
    d['RA_center'], d['DEC_center'] = newcenter[0], newcenter[1]
    mult_az, mult_el = generate_region(az,el)
    print("Lengths az, el {} {}".format(len(mult_az[0]), len(mult_el)))
    theta = np.array(mult_el) 
    phi = np.array(mult_az[0])
    # Convert horizontal coordinates in equatorial 
    theta, phi = qubic.hor2equ(phi, theta, 0.1) 
    # Center in (0,0) to rotate after
    theta = theta - newcenter[1]
    phi = phi - newcenter[0]

pp = qubic.QubicSampling(len(az)*len(el), azimuth = mult_az[0], elevation = mult_el[0],
                             date_obs = d['date_obs'], period = 0, 
                            latitude = None, longitude = None)

time = pp.date_obs + TimeDelta(pp.time, format='sec')

c2s = Cartesian2SphericalOperator('azimuth,elevation', degrees=True)
if True: print("long, lat, time: {} {}".format(pp.longitude, pp.latitude, time) )
e2h = CartesianEquatorial2HorizontalOperator(
    'NE', time, pp.latitude, pp.longitude)
rot = Rotation3dOperator("ZY'", newcenter[0], 90 - newcenter[1], degrees=True)
s2c = Spherical2CartesianOperator('zenith,azimuth', degrees=True)
rotation = c2s(e2h(rot(s2c)))
coords = rotation(np.asarray([theta.T, phi.T]).T)
```

```{python}
thphpix = hp.ang2pix(256, np.pi/2 - np.radians(theta), np.radians(phi))
auxmap = np.ones((12*256**2))
auxmap[thphpix] = 100
figure(figsize=(15,6))
hp.mollview(auxmap, rot = (d['RA_center'], d['DEC_center']), sub = 121, )
hp.gnomview(auxmap, rot = (0,0), sub = 122,
           xsize = 300, ysize =200,reso = 13)
hp.graticule(verbose = False)
```

```{python}
newaz, newel = generate_region(az, el)
print(np.mean(az), np.mean(el))
print(d['RA_center'], d['DEC_center'])
d['npointings'] = len(az)*len(el) 
p = create_hall_pointing(d, az, el, period = 0.1)

interval_time = d['effective_duration'] * 3600 * 24 * 365 #in sec
ra = np.zeros_like(p.azimuth)
dec = np.zeros_like(p.elevation)

#================== WARNING coordinates====================
# I'm using horizontal coordinates in equatorial like projections. It works, 
# I have to change it in near-futher
#
#
# This has to be changed in realistic cases (time != 0)
ra, dec = p.azimuth, p.elevation#qubic.hor2equ(p.azimuth, p.elevation, 0)
#==========================================================
```

```{python}
fig, ax = subplots(nrows= 1, ncols = 3, figsize = (16,5))
        
ax[0].set_xlabel(r'A[째]', fontsize = 20)
ax[0].set_ylabel(r'h[째]', fontsize = 20)
ax[0].set_title('Az, El grid from hk data')
ax[0].plot(np.reshape(newaz, (len(el), len(az))), np.reshape(newel, (len(el), len(az))), 'k.',
          alpha = 0.4)
ax[0].plot(np.mean(az), np.mean(el), 'y*')
maskaux_px = np.zeros((12 * d['nside'] ** 2,))
px_radec = hp.ang2pix(d['nside'], np.deg2rad(90 - dec), np.deg2rad(ra)) 
maskaux_px[...] = hp.UNSEEN
maskaux_px[px_radec] = 1.
maskaux_px[~px_radec] = hp.UNSEEN
axes(ax[1])
hp.mollview(maskaux_px, coord = 'C', cmap = 'jet', #reso = 12, 
            rot = (d['RA_center'], d['DEC_center'] ), cbar = False, #xsize = 300, ysize = 200, 
            title = 'Scanned region in Eq. projection (using hor coordinates)', max = 1, min = 0, hold = True)
hp.graticule()

ax[2].set_xlabel(r'$\alpha$[째]', fontsize = 20)
ax[2].set_ylabel(r'$\delta$[째]', fontsize = 20)
ax[2].set_title('RA,DEC converted from Az, El -hk data- using q.hor2equ ')
ax[2].scatter(np.reshape(ra, (len(el), len(az))), np.reshape(dec, (len(el), len(az)))[:], color = 'k',
              marker = '.',  alpha = 0.4)
#ax[2].plot(d['RA_center'], d['DEC_center'], 'y*')
```

```{python}
rc('font', size=12)
figure(figsize = (14,8))
subplot(221)
ylabel(r'$\alpha$')
xlabel('pointing')
plot(p.equatorial[:,0], alpha = 0.7, label = 'QS')
plot(ra, alpha= 0.7, label = 'Manual')
#axhline(d['RA_center'], c = 'k', ls = '--')
legend()

subplot(222)
ylabel(r'$\delta$')
xlabel('pointing')
plot(p.equatorial[:,1],  alpha = 0.7, label = 'QS')
plot(dec, alpha= 0.7, label = 'Manual')
#axhline(d['DEC_center'], c = 'k', ls = '--')

figure(figsize=(14,4))
subplot(223)
xlim(0,1500)
plot(np.array(p.azimuth).ravel())
subplot(224)
xlim(0,1500)
plot(np.array(p.elevation).ravel())

#subplot(133)
# Note the extra 'r' at the front
#SAMPLE_RATE = 1
#N = d['npointings'] * SAMPLE_RATE
#yf = rfft(ra)
#xf = rfftfreq(N, 1 / SAMPLE_RATE)
#xlim(0,0.1)
#plot(xf, np.abs(yf)/1e6)
```

See at the scan... Ok, works fine

o --->--->--->---> ... --->

                 v

o --->--->--->---> ... --->

                 v

o --->--->--->---> ... --->|


lim = 70
ylim(63,66)
scatter(p.azimuth[:lim], p.elevation[:lim], color = 'k', marker = '.', s = 5)
scatter(p.azimuth[lim:2*lim], p.elevation[lim:2*lim], color = 'r', marker = '.', s = 5)
scatter(p.azimuth[2*lim:3*lim], p.elevation[2*lim:3*lim], color = 'b', marker = '.', s = 5)


#### Generate QUBIC objects (scene, instrument, acquisition)

```{python}
s = qubic.QubicScene(d)
q = qubic.QubicMultibandInstrument(d)

#Compute frequencies
_, nus_edge_in, nus_in, _, _, _ = qubic.compute_freq(d['filter_nu'] / 1e9, d['nf_sub'],
                                                d['filter_relative_bandwidth'])
print(nus_in)
```

```{python}
#Create object with TES - PIXEL information and translation between data and simulation
# pix --> qubicsoft (1-256 or 248)
# tes --> qubicdata (1-128)
# index -> TRANSLATOR
FPidentity = pt.make_id_focalplane()
#FPidentity = FPfull[np.where(FPfull.quadrant == 3)[0]]
#Check consistncy:
print("This convert indexes in qinstrument into fp ones")
print("Index \t TES \t qpix")
for i in range(len(q[0].detector)):
    idet = q[0].detector[i]
    print(idet.index[0], '\t', FPidentity[idet.index[0]].TES, '\t', FPidentity[idet.index[0]].PIX)
    print(" ", "\t", " ", "\t" , tes2pix(FPidentity[idet.index[0]].TES, FPidentity[idet.index[0]].ASIC))
```

#### Generate point source


It doesn't change the equatorial coordinates when changing center...weird. This could be related with the period in QubicSampling

```{python}
#150GHz
idx = 3
psmap = np.zeros((d['nf_sub'], 12 * d['nside'] ** 2))
central_pix = hp.ang2pix(d['nside'], np.deg2rad(90 - elcen_fov), np.deg2rad(azcen_fov))
neig_pixs = hp.get_all_neighbours(d['nside'], central_pix)
psmap[idx, central_pix] = 1e9
psmap[idx] = hp.smoothing(psmap[idx], np.deg2rad(1.0))

fig, ax = subplots(nrows = 1, ncols = 2, figsize = (15,5))
axes(ax[0])
hp.gnomview(psmap[idx], rot = (d['RA_center'], d['DEC_center']), 
            title = 'PS@{:.2f}'.format(nus_in[idx]),
            reso = 10, hold = True)


ax[1].plot(p.equatorial.T[0], label = 'RA')
ax[1].plot(p.equatorial.T[1], label = 'DEC')
ax[1].legend()

```

#### Generate freqs, acquisition operator and observation

```{python}
a = qubic.QubicMultibandAcquisition(q, p, s, d, nus_edge_in)

TOD, maps_convolved_useless = a.get_observation(psmap, noiseless = d['noiseless'])#, convolution = True)
```

Look at the TODs


qpix, asic = 93, 1
newaz = np.interp(newt_demod, time_azel, az)
newel = np.interp(newt_demod, time_azel, el)
azmin = np.min(az)
azmax = np.max(az)
elmin = np.min(el)
elmax = np.max(el)
naz = len(az)
nel = len(el)
mymap, azmap, elmap = dl.coadd_flatmap(TOD[qpix], newaz, newel, 
                                    filtering=None,
                                    azmin=azmin, azmax=azmax, 
                                    elmin=elmin, elmax=elmax, 
                                    naz=naz,nel=nel)


```{python}
#figure(figsize = (14,6))
#subplot(121)
# I havew to invert the elevation to match with dataset. I don't know why. 
reload(fh)
for ipix in range(len(q[0].detector)):
    # WARNING
    #================================================================== HERE == WARNING
    #watch out here. Index didn't match
    idet = q[0].detector[ipix]
    qtes = FPidentity[idet.index[0]].TES
    #print (ipix, qtes)
    #=================================================================== HERE
    FitsArray(np.reshape(TOD[ipix], 
                     (len(el), len(az)))[::-1, :]).save(directory + \
                    'Simulations/Flat/imgflat_TESNum_{}'.format(qtes))
#imshow(np.reshape(TOD[fh.q_pix(ites)[0]], (len(el), len(az)))[::-1, :] )
#colorbar(None)
#subplot(122)
#map_test = sbfit.get_flatmap(100, directory)[0]
#imshow(map_test)
```

#### Choose a qpix (or TES, ASIC) to fit peak position with:

* Flat

* Healpy

```{python}
# Selecting TES number in absolute (1-248) notation:
TES = [149, ] #[149, 28, 37, 60, 96, 101, 122, 124, 137, 140, 149]
tes = np.zeros((len(TES), ), dtype = int)
asic = np.zeros((len(TES), ), dtype = int)
qpix = np.zeros((len(TES), ), dtype = int)
for j, iTES in enumerate(TES):
    tes[j], asic[j] = (iTES, 1) if (iTES < 128) else (iTES - 128, 2)
    # Transform to qubicsoft notation
    print(tes[j], asic[j])
    qpix[j] = tes2pix(tes[j], asic[j])

# Select tod to fit in healpy and flat projections (just one)
tod = TOD[qpix[0]]
```

#### Fit flatmap

```{python}
# Build model
sbfitmodel = sbfit.SbModelIndepPeaks(nrings=2, common_fwhm=True, 
                                     no_xy_shift=False, distortion=False)

# Do fit for 1 TES
thexypeaks = np.zeros((len(tes), 4, 9))
flatmaps = np.zeros((len(tes), len(el), len(az) ))
t0 = time.time()
for j, ites in enumerate(tes): 
    #_asic_ = 1 if (ites < 128) else 2
    #ites = ites if (ites < 128) else ites - 128
    #_qidx_ = tes2pix(ites, _asic_)
    print("TES number {} asic number {}".format(qpix[j], asic[j]))
    print("Index number: qpack {} qsoft {} ".format(\
                                pt.tes2index(ites, asic[j]), q[0].detector[qpix[j]].index[0] ))
    print("qubicsoft number: {}".format(qpix[j]))
    _, thexypeaks[j], flatmaps[j] = sbfit.fit_sb(np.reshape(tod, (len(el), len(az))), 
                                                 az, el, sbfitmodel, resample = False, newsize = 150, 
                                                 nsiglo = 100, nsighi = 2000,
        az_center = azcen_fov, el_center = elcen_fov,
         verbose = False, doplot = True, return_fitted =True,
    figsave = os.environ['QUBIC_DATADIR'] + 'scripts/fit_theoretical_SB/TES{}_flatmap_peaks_fit'.format(ites),
         extra_title='TES #{}'.format(ites))
    clf()
    
print((time.time()-t0)/60 , 'minutes')
```

#### Saving flat fitting

```{python}
dirfiles = os.environ['QUBIC_TODDIR']+'150GHz-2019-04-06/'
FitsArray(thexypeaks).save(dirfiles + 'FitSB/FlatMaps/fitted_peaks_test')
```

```{python}
#I have to pick len(az)*len(el) data coords from coverage. 
# The fisrt approach is to take the coordinates of the first len(az)*len(el) elements in cov array
if ("cov" not in locals()):
    cov = a.get_coverage()
    cov = np.mean(cov, axis = 0)
    maskov = cov > 0.1* np.max(cov)
    cov[~maskov] = hp.UNSEEN
print(len(np.where(cov != hp.UNSEEN)[0]))

```

To generate Healpix maps from flat projections I need the pointing (az, el) from hk-data. Each (az, el) represents the sky direction towards QUBIC points. Each TES cover a different region in sky. 

* The first point is generate a coverage map for each TES for each frequency in a full scan.

```{python}

```

```{python}
qites = qubic.QubicMultibandInstrument(d)
qites = q.detector_subset(qpix[0])

#flat to hp with data
hp_pix = hp.ang2pix(d['nside'], np.pi - np.radians(p.elevation), np.radians(p.azimuth))
print(hp_pix)

regionmap = np.zeros((12*d['nside']**2,))
regionmap[hp_pix] = 1.
hp.gnomview(cov, rot = (0, 50), title = 'Coverage', reso = 14, sub = 121)
hp.gnomview(regionmap, rot = (0,-elcen_fov, 180), title = 'Conv', reso = 14, sub = 122)
```

```{python}
def select_det(q,idn):
    #### For now the ids are not matched... so we only take the len(id) first detectors...
    detector_i = q.detector[idn]
    q.detector = detector_i
    return(q)
```

```{python}
for j, iq in enumerate(q):
    select_det(q[j], qpix[0])
a_ites = qubic.QubicMultibandAcquisition(q_ites, p, s, d, nus_edge_in)

```

Test if reads is according with format...ok


pruebaxypeaks = np.array(FitsArray(dirfiles + 'FitSB/fitted_peaks_flatmap'))
for i in range(len(TES2fit)):
    scatter(pruebaxypeaks[i,0], pruebaxypeaks[i,1])


Fit peak positions in healpy map (data)

```{python}
reload(fh)
dirfiles = os.environ['QUBIC_TODDIR']+'150GHz-2019-04-06/'

tes_fileconv = TES2fit[0]
hpnest, thphpeaksnew, absmaxpx = fh.fit_hpmap(tes_fileconv, q[3], s, dirfiles, plot = False,
                                       filterbeam = 2, threshold = 2, threshold0 = 2, plotcenter = False)
```

```{python}
allthetas_M = np.radians(90 - (thexypeaks[0,1,:] - elcen_fov))
allphis_M = np.radians(-thexypeaks[0,0,:])#*thecos)
angs = np.radians(np.array([0, 90, 0]))
#allthetas_Q[idet,:], allphis_Q[idet,:] = sbfit.rotate_q2m(allthetas_M[idet,:], allphis_M[idet,:],  angs=angs, inverse=True)
allthetas_Q, allphis_Q = sbfit.rotate_q2m(allthetas_M, allphis_M, angs=angs, inverse=True)
# pi rotation of the measured SB w.r.t. simulations => we apply it here
allphis_Q += np.pi

fig, ax = subplots(nrows = 1, ncols = 2, figsize = (14,8))

axes(ax[0])
hp.gnomview(hpnest, nest = True, reso = 10, min = 0, max= 1e4, cbar= False, rot = (0,0),
            title = 'Fitting (hp) TES = {}'.format(tes_fileconv), hold = True)
hp.projscatter(thphpeaksnew.T, color = 'r', marker = '.')
hp.graticule(verbose = False)
_qidx_ = tes2pix(tes_fileconv if (tes_fileconv < 128) else tes_fileconv -128, _asic_)
#print(TES2fit[0],_asic_,_qidx_)
im = ax[1].imshow(np.reshape(TOD[_qidx_], (len(el), len(az))), 
             extent = [np.min(az) * np.cos(np.radians(elcen_fov)),
                               np.max(az) * np.cos(np.radians(elcen_fov)),
                               np.min(el), np.max(el)],  )
ax[1].plot(thexypeaks[TES2fit.index(tes_fileconv),0,:], thexypeaks[TES2fit.index(tes_fileconv),1,:], 'r.')
#fig.colorbar(im, ax = ax[1])
ax[1].set_title('Fitting (flat) TES {}'.format(tes_fileconv))
ax[1].axvline(d['RA_center'], color = 'k')
ax[1].axhline(d['DEC_center'], color = 'k')
print(ax[1].get_ylim())
```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}
import scipy.signal as scsig
import qubic.fibtools as ft

flatmap = scsig.resample(scsig.resample(np.reshape(TOD[93], (len(el), len(az))), 144, axis=0), 200, axis=1)
azaux = np.linspace(np.min(az), np.max(az), 200)
elaux = np.linspace(np.min(el), np.max(el), 144)
az2d, el2d = np.meshgrid(az * np.cos(np.radians(50)), np.flip(el))
mm, ss = ft.meancut(flatmap, 3)
```

```{python}
subplot(121)
imshow(flatmap, vmin = mm - 100 * ss, vmax = mm + 2000 * ss)
subplot(122)
imshow(np.reshape(TOD[93], (len(el), len(az))))
```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

H = a.get_operator()


print(np.shape(H.T),)# 196608/12/128/128, 12*128**2, d['npointings'] * 248)


#print('Operator ', a.get_operator())
print(len(a.instrument), len(a.sampling))
print(a.comm.allreduce(len(a.instrument)))
print(a.comm.allreduce(len(a.sampling)))
print('Period ', a.sampling.period)
print(a.comm.allreduce(len(a.instrument)) * a.comm.allreduce(len(a.sampling)) * a.sampling.period)

```{python}
cov = a.get_coverage()
```

```{python}
figure(figsize = (14,6))
hp.mollview(cov, sub = (131), rot = (0,0))
hp.mollview(psmap[0], sub=(132), rot = (0,0))
```

d['tol'] = 1e-3
d['nf_recon'] = 1
maps_recon, _, _ = a.tod2map(TOD, d, cov = cov)

```{python}

```
