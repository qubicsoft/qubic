---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.1
  kernelspec:
    display_name: Python 2
    language: python
    name: python2
---

# Reconstruction of Calibration Source map with measured synth. beam
#### J.-Ch. Hamilton heavily inspired by Martin Gamboa's notebook scanSource_oneDet.ipynb

```{python}
# %matplotlib inline
# #%matplotlib notebook
from matplotlib import rc
rc('figure', figsize=(15,8))
rc('font', size=12)
rc('text', usetex=False)
rc('image', cmap='viridis')

import healpy as hp
import pickle

import qubic.io
from pysimulators import FitsArray
import fibtools as ft
import demodulation_lib as dl
import sb_fitting as sbfit
import jchinstrument as jcinst


```

```{python}
def hall_pointing(az, el, angspeed_psi, maxpsi,
                 date_obs=None, latitude=None, longitude=None,fix_azimuth=None,random_hwp=True):
    #This method will reproduce the pointing that is used in the hall to take the data. Will start from bottom
    #left and will go up at fixed elevation.
    
    #nsamples = 2*len(az)*len(el) # commented bucause not go and back
    nsamples = len(az)*len(el)
    print('nsamples = ', nsamples)
    pp = qubic.QubicSampling(nsamples,date_obs=date_obs, period=0.1, latitude=latitude,longitude=longitude)
    
    #Comented because we do not go and back in simulations.. 
    #mult_el = []
    #for eachEl in el:
    #    mult_el.append(np.tile(eachEl, 2*len(az)))
    # Azimuth go and back and same elevation. 
    #az_back = az[::-1]
    #az = list(az)
    #az.extend(az_back)
    #mult_az = np.tile(az, len(el))
    #print(i,np.asarray(mult_el).ravel().shape)
    #pp.elevation = np.asarray(mult_el).ravel()
    #pp.azimuth = np.asarray(mult_az).ravel()
    
    mult_el = []
    for eachEl in el:
        mult_el.extend(np.tile(eachEl, len(az)))
    mult_az = []
    mult_az.append(np.tile(az, len(el)))
    #print(len(mult_el))
    pp.elevation = np.asarray(mult_el)#az2d.ravel()
    pp.azimuth = np.asarray(mult_az[0])#el2d.ravel()
    
    ### scan psi as well,
    pitch = pp.time * angspeed_psi
    pitch = pitch % (4 * maxpsi)
    mask = pitch > (2 * maxpsi)
    pitch[mask] = -pitch[mask] + 4 * maxpsi
    pitch -= maxpsi
    
    pp.pitch = pitch
    
    if random_hwp:
        pp.angle_hwp = np.random.random_integers(0, 7, nsamples) * 11.25
        
    if fix_azimuth['apply']:
        pp.fix_az=True
        if fix_azimuth['fix_hwp']:
            pp.angle_hwp=pp.pitch*0+ 11.25
        if fix_azimuth['fix_pitch']:
            pp.pitch= 0
    else:
        pp.fix_az=False

    return pp
    #print(pp.elevation)#, len(pp.elevation))


def select_det(q,id):
    #### For now the ids are not matched... so we only take the len(id) first detectors...
    detector_i = q.detector[:len(id)]
    q.detector = detector_i
    return(q)

def do_some_dets(detnums, directory, fittedpeaksfile, custom=False, 
                 nside=None, tol=5e-3, refit=False, resample=True, newsize=70, 
                 doplot=True, verbose=True, sbfitmodel=None, angs=None):
    if nside is not None:
        d['nside']=nside
    s = qubic.QubicScene(d)
    ids = []
    for n in detnums:
        ids.append(0)
    
    if not custom:
        print('')
        print('Normal Reconstruction')
        qcut = select_det(qubic.QubicInstrument(d),ids)
    else:
        print('')
        print('Custom Reconstruction')
        ### Refit or not the locations of the peaks 
        ### from the synthesized beam images      
        ### First instantiate a jchinstrument (modified from instrument 
        ### to be able to read peaks from a file)
        qcut = select_det(jcinst.QubicInstrument(d),ids)
        nu = qcut.filter.nu
        synthbeam = qcut.synthbeam
        horn = getattr(qcut, 'horn', None)
        primary_beam = getattr(qcut, 'primary_beam', None)
        thecos = np.cos(np.radians(50))

        if refit:
            print('We refit the peak locations')
            ### We call the fitting function for the Synthesized beam
            xypeaks = []
            for i in range(len(detnums)):
                flatmap, az, el = dl.get_flatmap(detnums[i], directory)
                if sbfitmodel is None:
                    sbfitmodel = sbfit.SbModelIndepPeaks(nrings=2, common_fwhm=True, 
                                                         no_xy_shift=False, distortion=False)
                print('Using Fit Model {} for TES #{}'.format(sbfitmodel.name,detnums[i]))
                fit, thexypeaks = sbfit.fit_sb(flatmap, az, el, sbfitmodel, resample=resample, newsize=newsize,
                                               verbose=verbose, doplot=doplot)
                xypeaks.append(thexypeaks)
                
            ### Convert to measurement coordinate system
            xypeaks = np.array(xypeaks)
            allthetas_M = np.radians(90-(xypeaks[:,1,:]-50))
            allphis_M = np.radians(-xypeaks[:,0,:])#*thecos)
            allvals_M = xypeaks[:,2,:]
        else:           
            print('No refitting of the peak locations')
            ### We just read them from the old peak file
            peaks = np.array(FitsArray(fittedpeakfile))
            peaks[:,0,:] = peaks[:,0,:]/thecos
            ### An put them in the expected format
            mypeaks = peaks[np.array(detnums)-1,:,:]
            allthetas_M = np.radians(90-(mypeaks[:,1,:]-50))
            allphis_M = np.radians(-mypeaks[:,0,:]*thecos)
            allvals_M = mypeaks[:,2,:]
        
        ### Now we want to perform the rotation to go to boresight 
        ### reference frame (used internally by QubicSoft)
        if angs is None:
            angs = np.radians(np.array([0, 90, 0]))
        allthetas_Q = np.zeros_like(allthetas_M)
        allphis_Q = np.zeros_like(allthetas_M)
        allvals_Q = np.zeros_like(allthetas_M)
        for ites in xrange(len(detnums)):
            allthetas_Q[ites,:], allphis_Q[ites,:] = sbfit.rotate_q2m(allthetas_M[ites,:], 
                                                                      allphis_M[ites,:], 
                                                                      angs=angs, inverse=True)
            allvals_Q[ites,:] = allvals_M[ites,:]/np.max(allvals_M[ites,:])*synthbeam.peak150.solid_angle * (150e9 / nu)**2 / s.solid_angle * len(horn)
        
        ### We nowwrite the temporary file that contains the peaks locations to be used
        data = np.array([allthetas_Q, allphis_Q, allvals_Q])
        file = open('/Users/hamilton/Qubic/RealistcReconstruction/peaks.pk', 'wb')
        pickle.dump(data, file)
        file.close()
    

    ### Make the TODs from the measured synthesized beams
    # Read azimuth and elevation
    az = FitsArray(directory + 'Flat/azimuth.fits')
    el = FitsArray(directory + 'Flat/elevation.fits')
    # Build pointing from them
    p = hall_pointing(az, el, 0, 0, fix_azimuth=d['fix_azimuth'])
    # Read data and fill TOD
    realTOD = np.zeros((len(detnums),len(p)))
    for i in range(len(detnums)):
        filename = directory + 'Flat/imgflat_TESNum_{}.fits'.format(detnums[i])
        print('Reading {}'.format(detnums[i]))
        img = FitsArray(filename)
        realTOD[i,:] = np.ravel(img) * 5e-28

    ### Cut in azimuth and elevation
    azmin = -15./np.cos(np.radians(50))
    azmax = 15./np.cos(np.radians(50))
    elmin = 20.
    elmax = 80.
    ok = ((p.azimuth >= azmin) & (p.azimuth <= azmax)) & ((p.elevation >= elmin) & (p.elevation <= elmax))
    print('AzEl cuts: Keeping only {} samples out of {}'.format(ok.sum(), len(ok)))
        
    ### And we instantiate the QUBIC isntrument that uses qcut which a 
    ### jchinstrument (modified to read the above file)
    sima = qubic.QubicAcquisition(qcut, p[ok], s, d)

    ### Run the mapmaker
    d['tol'] = tol
    maps_recon, niter, error = sima.tod2map(realTOD[:,ok], d, cov=None)
    print('Mapmaking QUBIC done in {} iterations with error: {}'.format(niter, error))
    return maps_recon




```

```{python}

```

```{python}
# INSTRUMENT
ns = 256
d = qubic.qubicdict.qubicDict()
d.read_from_file('../pointsource/global_source_oneDet.dict')
print(d['kind'])
d['kind']='I'
print(d['kind'])
d['nside']=ns

fittedpeakfile = '/Users/hamilton/Google Drive/QUBIC/Calib-TD/Files/Synthesized Beams/fitted_peaks.fits'
directory = '/Users/hamilton/Google Drive/QUBIC/Calib-TD/Files/Synthesized Beams/Synthesized_Beams_Files/150GHz-2019-04-06/'
```

```{python}
reload(dl)
reload(sbfit)
reload(jcinst)
#detnums = [6, 37, 38, 72, 79, 86, 94, 96, 110, 124, 149, 153, 176, 184, 185, 199, 205, 229, 231, 235, 247]
detnums = [37, 124, 185, 229]
nsrec = 256
tol = 1e-4
all_maps_recon_th = np.zeros((len(detnums), 12*nsrec**2))
all_maps_recon_custom = np.zeros((len(detnums), 12*nsrec**2))
all_maps_recon_custom_new = np.zeros((len(detnums), 12*nsrec**2))
for i in range(len(detnums)):
    d['verbose']=False
    all_maps_recon_th[i,:] = do_some_dets([detnums[i]], directory, fittedpeakfile, 
                                          custom=False, nside=nsrec, tol=tol, refit=False)    
    all_maps_recon_custom[i,:] = do_some_dets([detnums[i]], directory, fittedpeakfile, 
                                              custom=True, nside=nsrec, tol=tol, refit=False)    
    all_maps_recon_custom_new[i,:] = do_some_dets([detnums[i]], directory, fittedpeakfile, 
                                                  custom=True, nside=nsrec, tol=tol, refit=True, 
                                                  verbose=False, doplot=True)
```

```{python}
center = [0,50]
rc('figure', figsize=(15,20))
reso = 20
for i in range(len(detnums)):
    hp.gnomview((all_maps_recon_th[i,:]), reso=reso/2, rot=center, cmap = 'viridis', sub=(len(detnums),3,3*i+1), 
            title='Th. TES{}'.format(detnums[i]),min=0, max=0.01)
    hp.gnomview((all_maps_recon_custom[i,:]), reso=reso/2, rot=center, cmap = 'viridis', sub=(len(detnums),3,3*i+2), 
            title='Custom OldFit TES{}'.format(detnums[i]),min=0, max=0.01)
    hp.gnomview((all_maps_recon_custom_new[i,:]), reso=reso/2, rot=center, cmap = 'viridis', sub=(len(detnums),3,3*i+3), 
            title='Custom Refit TES{}'.format(detnums[i]),min=0, max=0.01)
```

```{python}
d['verbose']=False
angs = np.radians(np.array([0, 90, 0]))

#### Very slow convergence so put tol to 1e-2 for fast results, anyway result is crap
maps_recon_th = do_some_dets(detnums, directory, fittedpeakfile, 
                                          custom=False, nside=nsrec, tol=1e-2, refit=False)    

#### Faster so 1e-3 is OK
maps_recon_custom = do_some_dets(detnums, directory, fittedpeakfile, angs = angs,
                                              custom=True, nside=nsrec, tol=1e-3, refit=False)    

#### faster so 1e-3 is OK
maps_recon_custom_new = do_some_dets(detnums, directory, fittedpeakfile, angs=angs,
                                                  custom=True, nside=nsrec, tol=1e-3, refit=True, 
                                                  verbose=False, doplot=True)
```

```{python}
mm, ss = ft.meancut(maps_recon_custom[maps_recon_custom != 0], 3)
nb = 1.5
hp.gnomview((maps_recon_th), reso=reso/2, rot=center, cmap = 'viridis', sub=(1,3,1), 
        title='Th. TES{}'.format(detnums), min=mm-nb*ss, max=mm+nb*ss)
hp.gnomview((maps_recon_custom), reso=reso/2, rot=center, cmap = 'viridis', sub=(1,3,2), 
        title='Custom OldFit TES{}'.format(detnums), min=mm-nb*ss, max=mm+nb*ss)
hp.gnomview((maps_recon_custom_new), reso=reso/2, rot=center, cmap = 'viridis', sub=(1,3,3), 
        title='Custom Refit TES{}'.format(detnums), min=mm-nb*ss, max=mm+nb*ss)
```

```{python}

```

```{python}

```

```{python}
############# Trying to play with the rotation applied to put the peaks into the boresight reference frame
d['verbose']=False
tol=1e-3
angs = np.radians(np.array([0, 90, 0]))
maps_recon_custom_0 = do_some_dets(detnums, directory, fittedpeakfile, angs = angs,
                                              custom=True, nside=nsrec, tol=tol, refit=False)    

mm, ss = ft.meancut(maps_recon_custom_0[maps_recon_custom_0 != 0], 3)
nb = 1.5
hp.gnomview((maps_recon_custom_0), reso=reso*0.5, rot=center, cmap = 'viridis', sub=(1,2,1),
        title='Custom OldFit TES{}'.format(detnums), min=mm-nb*ss, max=mm+nb*ss)

angs = np.radians(np.array([3, 88, 2]))
maps_recon_custom_1 = do_some_dets(detnums, directory, fittedpeakfile, angs = angs,
                                              custom=True, nside=nsrec, tol=tol, refit=False)    

nb = 1.5
hp.gnomview((maps_recon_custom_1), reso=reso*0.5, rot=center, cmap = 'viridis', sub=(1,2,2),
        title='Custom OldFit TES{}'.format(detnums), min=mm-nb*ss, max=mm+nb*ss)

```

```{python}

```

```{python}

```

```{python}

```
