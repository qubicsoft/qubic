---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Synthetic beam on the focal plane
Edited by Louise 

Using data from 2019-04-06, scan at 150GHz

```{python}
import qubic
```

```{python}
from __future__ import division, print_function

# %matplotlib inline
# # %matplotlib notebook

import healpy as hp
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as plticker
import matplotlib.animation as animation
from IPython.display import HTML

from sklearn.cluster import DBSCAN

from qubicpack.utilities import Qubic_DataDir
from qubicpack.pixel_translation import make_id_focalplane, plot_id_focalplane, tes2index

import qubic
import qubic.fibtools as ft
import qubic.sb_fitting as sbfit
import qubic.selfcal_lib as sc

import matplotlib.animation as animation
from IPython.display import HTML
```

```{python}
# Get the data
freq_source = 130
rep = Qubic_DataDir(datafile='allFitSB_{}.pdf'.format(freq_source))
print(rep)
```

```{python}
# Look at one map
c50 = np.cos(np.radians(50))
azmin = -15./c50
azmax = 15./c50

TES=93
flatmap, az, el, fitmap, newxxyy = sbfit.get_flatmap(TES, rep, fitted_directory=rep+'/FitSB', 
                                                     azmin=azmin, azmax=azmax)

nel, naz = np.shape(flatmap)
print(nel, naz)
npix = nel * naz

print('npix = ', npix)

plt.subplot(121)
plt.imshow(flatmap)

plt.subplot(122)
plt.imshow(fitmap)
```

## Measure the focal length
Using fitted images

```{python}
elev = 75
all_fit = []
for tes in range(1, 257):
    themap, az, el, fitmap, newxxyy = sbfit.get_flatmap(tes, rep, fitted_directory=rep+'/FitSB',
                                                        azmin=azmin, azmax=azmax)
    if tes == 93: 
        print(fitmap.shape)
        plt.imshow(fitmap)
        
    all_fit.append((fitmap[elev, :]) / np.sum(fitmap))    
    
all_fit = np.array(all_fit)
print(all_fit.shape) 
```

```{python}
(ntes, naz) = np.shape(all_fit)
print(ntes, naz)
```

```{python}
# Check if for a given az, you have only 0
j=0
for i in range(naz):
    if np.all(all_fit[:, i])==0.:
        j+=1
        print(i)
print(j)
```

```{python}
# Remove Bad TES
bad_TES = [1, 2, 3, 4, 8, 11, 14, 15, 20, 21, 25, 29, 30, 33, 35, 39, 40, 47, 48, 53, 55, 56, 63, 
           70, 78, 84, 85, 89, 91, 92, 97, 102, 103, 112, 116, 119, 121, 126, 128, 132, 139, 143, 
           144, 145, 146, 147, 148, 155, 156, 174, 178, 179, 187, 190, 202, 211, 217, 221, 227, 228,
          230, 234, 238, 240, 241, 242, 243, 245, 249, 253, 254]
print(len(bad_TES))

for i in bad_TES:
    all_fit[i-1, :] = np.nan
```

```{python}
# TEST to check if TES are at the right place
all_fit[28+128, :] = 1.e7
all_fit[62+128, :] = 1.e7
```

### Image on the focal plane

```{python}
signal = np.empty((128, 2, naz))
signal[:, 0, :] = all_fit[:128, :]
signal[:, 1, :] = all_fit[128:, :]
```

```{python}
all_quartfp = []
for i in range(naz):
    image_fp = sc.tes_signal2image_fp(signal[:, :, i], [1, 2])
    _, quart_fp = sc.get_real_fp(image_fp, quadrant=3)
    all_quartfp.append(quart_fp)
    
    plt.imshow(quart_fp, vmin=0, vmax=2e-3)
    loc = plticker.MultipleLocator(base=1)
    ax = plt.gca();
    ax.xaxis.set_major_locator(loc)
    ax.yaxis.set_major_locator(loc)


#     ax.set_xticks(np.arange(-0.5, 17, 1));
#     ax.set_yticks(np.arange(0.5, 17, 1));
    ax.grid(color='w', linestyle='-', linewidth=1)
    plt.title(i)
    #plt.colorbar()
    plt.pause(0.07)
```

### Focal length measurement

```{python}
all_a = []
for i, quart_fp in enumerate(all_quartfp):
#     print(quart_fp)
#     quart_fp = np.nan_to_num(quart_fp)
#     print(quart_fp[quart_fp != np.nan])
    x = quart_fp[~numpy.isnan(quart_fp)]
    mean, std = ft.meancut(x, nsig=7)
    print(mean, std)
    print(np.std(x))
    threshold = 3 * std
#     threshold = np.nanstd(quart_fp)/2
#     threshold = np.nanmax(quart_fp) / 1000
#     print('threshold: ', threshold)
    bright = quart_fp > threshold 
    print(bright.shape)
    brightpixels = np.column_stack(np.where(bright.T))

    # DBSCAN
    clustering = DBSCAN(eps=1, min_samples=3).fit(brightpixels)
    labels = clustering.labels_
    
    nfound = len(np.unique(np.sort(labels)))
    print('nfound: ', nfound)
    
    if nfound == 3:
        centers = np.zeros((nfound, 2))

        for k in range(nfound):
            ok = labels==k
            centers[k, :] = np.mean(brightpixels[ok, :], axis=0)

    #     centers = centers[~np.isnan(centers).any(axis=1)]
        print(centers)

        plt.figure()
        plt.imshow(bright)
        plt.plot(centers[:,0], centers[:,1], 'ro' )
        plt.title(i)
        
        a = np.sqrt((centers[0, 0] - centers[1, 0])**2 + (centers[0, 1] - centers[1, 1])**2) * 3e-3
#         nu = freq_source * 1e9
#         f = nu * 14e-3 * a / 299792458
        all_a.append(a)
    
print('nf = ', len(all_a))
```

```{python}
17**2
```

```{python}
print(len(all_a))
all_a = np.array(all_a)

f_theo = 0.30
all_a_cut = all_a[all_a > 0.02]
print(len(all_a_cut))

mean = np.mean(all_a_cut)
std = np.std(all_a_cut)

hist = plt.hist(all_a_cut, bins=8)
plt.xlabel('Distance a (m)')
plt.title('Source freq = {}'.format(freq_source))

# plt.axvline(mean, color='r', linestyle='dashed', linewidth=2)

# min_ylim, max_ylim = plt.ylim()
# plt.text(mean*1.02, max_ylim*0.9, 'Mean: {:.3f} m \n Std: {:.3f} m'.format(mean, std))
```

```{python}
plt.plot(hist[0], hist[1])
```

```{python}
all_freq = np.arange(140, 180, 10)
lam = 3e8 / (all_freq * 1e9) 
a_mean = [0.042, 0.039, 0.038, 0.037]
plt.plot(lam, a_mean, 'o')
plt.xlabel('Wavelength (m)')
plt.ylabel('Distance a (m)')
```

```{python}
all_quart_fp = []
fig = plt.figure()
for i in range(20, 170):
    image_fp = sc.tes_signal2image_fp(signal[:, :, i], [1, 2])
    _, quart_fp = sc.get_real_fp(image_fp, quadrant=3)
    
    im = plt.imshow(quart_fp, vmin=0, vmax=4e-3, animated=True)
    all_quart_fp.append([im])


ani = animation.ArtistAnimation(fig, all_quart_fp, interval=1000, repeat=False)

# Show the animation
HTML(ani.to_html5_video())

# Save the animation 
# ani.save('Synthetic_beam_FP.mp4')
```

## Using real data

```{python}
# Estimating the median of all SB images - to be removed - Origin still unexplained...
alldata_renorm = np.zeros((256, npix))
for i in range(256):
    flatmap, az, el = sbfit.get_flatmap(i+1, rep, azmin=azmin, azmax=azmax)
    mm, ss = ft.meancut(flatmap, 3)
    alldata_renorm[i, :] = np.ravel((flatmap - mm) / ss) 
    
med = np.reshape(np.median(alldata_renorm,axis=0), np.shape(flatmap))
mm = np.mean(med)
ss = np.std(med)

imshow(np.reshape(med, np.shape(flatmap)),
       extent=[np.min(az)*c50, np.max(az)*c50, np.min(el), np.max(el)], aspect='equal')
colorbar()
title('Median over all S.B. images')
```

```{python}
all_tes_sig = []
for tes in range(1, 257):
    themap, az, el, fitmap, newxxyy = sbfit.get_flatmap(tes, rep, fitted_directory=rep+'/FitSB', 
                                                        remove=med, azmin=azmin, azmax=azmax)
    if tes == 93: 
        print(themap.shape)
        plt.imshow(themap)
        
    all_tes_sig.append((fitmap[71, :]) / np.sum(fitmap))    
#     all_tes_sig.append(np.ravel(themap))
    
all_tes_sig = np.array(all_tes_sig)
print(all_tes_sig.shape) 
```

### Synth beam on the sky simulation

```{python}
d = qubic.qubicdict.qubicDict()
rep_dict = Qubic_DataDir(datafile = 'global_source_oneDet.dict')
d.read_from_file(rep_dict + '/global_source_oneDet.dict')
# d['config'] = 'FI'
d['nside'] = 256

center = qubic.equ2gal(d['RA_center'], d['DEC_center'])

q = qubic.QubicInstrument(d)
s = qubic.QubicScene(d)
```

```{python}
TESNum = 93
sb = q.get_synthbeam(s, TESNum)
sb.shape
hp.gnomview(sb, rot=[0,90], reso=10)
```

```{python}
# Test for one TES
TESNum = 93
hpmap = sbfit.get_hpmap(TESNum, rep)

if TESNum > 128: 
    asicnum = 2
    thetes = TESNum - 128
else:
    asicnum = 1
    thetes = TESNum

def select_det(q, id):
    #### For now the ids are not matched... so we only take the len(id) first detectors...
    detector_i = q.detector[id]
    q.detector = detector_i
    return(q)

idx = tes2index(thetes, asicnum)
iii = np.where(q.detector.index == idx)[0]

print(idx, iii)
q.detector.index.shape

q = select_det(q, iii)
sb = q.get_synthbeam(s, iii)

hp.gnomview(hpmap, reso=10, sub=(1,2,1), title='Data TES #{}'.format(TESNum))
hp.gnomview(sb, rot=[0,90], reso=10,sub=(1,2,2), title='Theory TES #{}'.format(TESNum))
```

```{python}
all_tes_sig_norm = np.ones_like(all_tes_sig)
all_hpmap = []
all_sb = []

thermos = [4, 36, 68, 100]
for det in range(1, 257):
    if det > 128: 
        asicnum = 2
        thedet = det - 128
    else:
        asicnum = 1
        thedet = det
        
    if thedet not in thermos:
        hpmap = sbfit.get_hpmap(det, rep)
        all_hpmap.append(hpmap)
        
        index = tes2index(thedet, asicnum)
        idet = np.where(q.detector.index == index)[0]

        print(index, idet)

        sb = q.get_synthbeam(s, idet)
        all_sb.append(sb)
        sum_sb = np.sum(sb)
#         print(sum_sb)

        all_tes_sig_norm[det-1, :] = all_tes_sig[det-1, :] / sum_sb
```

```{python}
print(len(all_hpmap), len(all_sb))
j = 39
hp.gnomview(all_hpmap[j], reso=10, sub=(1,2,1), title='Data TES #{}'.format(j))
hp.gnomview(all_sb[j], rot=[0, 90], reso=10, sub=(1,2,2), title='Theory TES #{}'.format(j))
```

```{python}
import qubic.selfcal_lib as sc
from qubicpack.pixel_translation import make_id_focalplane, plot_id_focalplane, tes2index

q = qubic.QubicInstrument(d)
print(q.detector.index)
TES_index = 1100 # Index from 0 to 1155 in the Qubic soft
tes, asic = sc.index2TESandASIC(TES_index) # TES number and Asic on the instrument
index = tes2index(tes, asic) # Inverse transformation
print(index)

# Make this plot to see where it is
plot_id_focalplane()

# Build an instrument with only this detector
ii = np.where(q.detector.index==TES_index)[0]
print(ii)
q.detector = q.detector[ii]
```

### Normalize using meancut in fibtools

```{python}
mean, std = zip(*[ft.meancut(all_tes_sig[i, :], nsig=3) for i in range(ntes)])
```

```{python}
all_tes_sig_norm = np.ones_like(all_tes_sig)
for i in range(ntes):
    #all_tes_sig_norm[i, :] = (all_tes_sig[i, :] - mean[i])/ std[i]    
    all_tes_sig_norm[i, :] = all_tes_sig[i, :]
```

```{python}
plot(all_tes_sig_norm[36,:])
```
