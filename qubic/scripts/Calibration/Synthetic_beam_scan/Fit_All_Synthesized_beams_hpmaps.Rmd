---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
# ##### %matplotlib notebook
# %matplotlib inline
from matplotlib import rc
rc('figure',figsize=(16,4))
rc('font',size=12)
rc('text',usetex=False)
rc('image', cmap='viridis')

from qubicpack import qubicpack as qp
from qubicpack.utilities import Qubic_DataDir
import qubic.fibtools as ft
import qubic.plotters as p
import qubic.lin_lib as ll
import qubic.demodulation_lib as dl
import qubic.io
import qubic.sb_fitting as sbfit
from qubicpack.pixel_translation import make_id_focalplane, plot_id_focalplane, tes2pix, tes2index

from pysimulators import FitsArray

import numpy as np
from matplotlib.pyplot import *
import matplotlib.mlab as mlab
import scipy.ndimage.filters as f
import glob
import string
import pickle
import scipy.signal as scsig
from scipy import interpolate
import os
import healpy as hp
import pandas as pd
import time
import scipy.ndimage.filters as f
```

```{python}
def create_hall_pointing(d, az, el, angspeed_psi, maxpsi,
                 date_obs = None, latitude = None, longitude = None, 
                 fix_azimuth = None, random_hwp = True):
    #This method will reproduce the pointing that is used in the hall to take the data. Will start from bottom
    #left and will go up at fixed elevation.
    
    nsamples = len(az)*len(el)
    pp = QubicSampling(nsamples,date_obs = d['date_obs'], period = 0.1, 
        latitude = latitude, longitude = longitude)
    
    #Comented because we do not back and forth in simulations.. 
    #mult_el = []
    #for eachEl in el:
    #    mult_el.append(np.tile(eachEl, 2*len(az)))
    # Azimuth go and back and same elevation. 
    #az_back = az[::-1]
    #az = list(az)
    #az.extend(az_back)
    #mult_az = np.tile(az, len(el))
    #print(i,np.asarray(mult_el).ravel().shape)
    #pp.elevation = np.asarray(mult_el).ravel()
    #pp.azimuth = np.asarray(mult_az).ravel()
    
    mult_el = []
    for eachEl in el:
        mult_el.extend(np.tile(eachEl, len(az)))
    mult_az = []
    mult_az.append(np.tile(az, len(el)))
    pp.elevation = np.asarray(mult_el)#az2d.ravel()
    pp.azimuth = np.asarray(mult_az[0])#el2d.ravel()
    
    ### scan psi as well,
    pitch = pp.time * angspeed_psi
    pitch = pitch % (4 * maxpsi)
    mask = pitch > (2 * maxpsi)
    pitch[mask] = -pitch[mask] + 4 * maxpsi
    pitch -= maxpsi
    
    pp.pitch = pitch
    
    if random_hwp:
        pp.angle_hwp = np.random.random_integers(0, 7, nsamples) * 11.25
        
    if d['fix_azimuth']['apply']:
        pp.fix_az=True
        if d['fix_azimuth']['fix_hwp']:
            pp.angle_hwp=pp.pitch*0+ 11.25
        if d['fix_azimuth']['fix_pitch']:
            pp.pitch= 0
    else:
        pp.fix_az=False

    return pp
def npp(ipix):
    #neighboring pixel of the peak
    # map in nest
    return np.array(hp.get_all_neighbours(256, ipix,nest=True))

def selectcenter(hpmap, center, delta = 3, nside = 256, nest = True,
                threshold = 3, displaycenters = False, plot = False):
    #return the pixel of the central peak
    npix = 12 * nside ** 2
    centerarr = [center,
                center - delta * np.array([1,0]),
                center - 2 * delta * np.array([1,0]),
                center + delta * np.array([1,0]),
                center + 2 * delta * np.array([1,0])]

    fullvec = hp.pix2vec(nside, range(0,npix), nest = nest)
    relmaxpx = np.zeros((len(centerarr),))
    px = np.zeros((len(centerarr),), dtype = int)

    for j,icenter in enumerate(centerarr):
        ivec = hp.ang2vec(np.deg2rad(icenter[0]), np.deg2rad(icenter[1]))
        imaskpx = np.rad2deg(np.arccos(np.dot(ivec,fullvec))) < threshold
        imaskidx = np.where(imaskpx == True)[0]
        #print(imaskidx)
        relmaxpx[j] = np.max(hpmap[imaskpx])
        px[j] = imaskidx[np.argmax(hpmap[imaskpx])]

    indxmax = np.argmax(relmaxpx)
    pixmax, newcenter = px[indxmax], centerarr[indxmax]
    if plot:
        hp.gnomview(hpnest, reso = 12, rot = np.array([90,0]) - newcenter, nest = nest)
        if displaycenters:
            for each in centerarr:
                hp.projscatter(np.deg2rad(each), marker = '+', color = 'r')
        #print('crux', np.rad2deg(hp.pix2ang(256, pixmax, nest=nest)))
        hp.projscatter(hp.pix2ang(256, pixmax, nest = nest), marker = '+', color = 'r')

    return pixmax, newcenter
```

```{python}
def fit_hpmap(PIXNum, dirfiles, centerini, #el_center, 
              nside = 256, nest = True, filterbeam = 3,
             threshold = 3,threshold0 = 4, plotcenter = False, plot = False,
             plotnine = False, plotneig = False, refilter = False ):
    t0 = time.time()
    npix = 12 * nside ** 2

    hpmap = sbfit.get_hpmap(PIXNum, dirfiles)

    if nest:
        hpnest = hp.reorder(hpmap, r2n = nest, )
    else:
        hpnest = hpmap
    hpnest_filt = f.gaussian_filter(hpnest, filterbeam)

    #centerini = [90-az_center,el_center]
    #px, center = selectcenter(hpnest_filt, centerini+np.array([90,0]), plot = plot)
    centerini = [np.rad2deg(centerini[0]), np.rad2deg(centerini[1])]
    px, center = selectcenter(hpnest_filt, centerini, plot = plot)
    vli = [px,]
    thetaphi=hp.pix2ang(nside,px,nest=nest)
    xlo = px-100
    xhi = px+100
    if plotcenter:
        fig,ax = subplots(nrows = 1, ncols = 2, figsize = (12,4))
        ax[0].set_xlim(xlo,xhi)
        ax[0].plot(hpnest, 'bo--', label = 'raw')
        ax[0].plot(hpnest_filt, 'bo--', alpha = 0.4, label = 'filtered')
        ax[0].legend()
        for i in vli:
            ax[0].axvline(i, c = 'k', alpha = 0.4, ls = '--')
            neig = npp(i)
        hp.gnomview(hpnest, reso = 12, rot = center, nest = True)
        hp.projscatter(np.deg2rad(centerini[0]), np.deg2rad(centerini[1]), marker = '+', color = 'r')

    pxvec = hp.pix2vec(nside, px, nest = nest)
    fullvec = hp.pix2vec(nside, range(0,npix), nest = nest)
    fullpx = np.linspace(0,npix,npix,dtype = int)

    aberr = np.deg2rad(np.array([0,1.]))
    delta = np.deg2rad(12.5)
    #Old peaksordering
    #thphpeaks = [thetaphi,
    #             thetaphi-delta*np.array([1,0]),                 
    #            thetaphi+delta*np.array([1,0]), 
    #            thetaphi-delta*np.array([0,1]+aberr),
    #            thetaphi+delta*np.array([0,1]+aberr),
    #            thetaphi-delta*0.5*np.array([1,1]),
    #            thetaphi+delta*0.5*np.array([1,1]),
    #            thetaphi-delta*0.5*np.array([-1,1]),
    #            thetaphi+delta*0.5*np.array([-1,1]),
    #             ]
    
    #peaks ordering according JCh and instrument module
    thphpeaks = [thetaphi+delta*np.array([1,0]),
                 thetaphi-delta*0.5*np.array([-1,1]),
                 thetaphi-delta*np.array([0,1]+aberr), 
                 thetaphi+delta*0.5*np.array([1,1]),
                 thetaphi,
                 thetaphi-delta*0.5*np.array([1,1]),
                 thetaphi+delta*np.array([0,1]+aberr),
                 thetaphi+delta*0.5*np.array([-1,1]),
                 thetaphi-delta*np.array([1,0])
                 ]

    fullvec = hp.pix2vec(nside, range(0,npix), nest=nest)
    realmaxpx = np.zeros((9,),dtype=int)
    absmaxpx = np.zeros((9,),dtype=int)

    if plotnine: fig, ax = subplots(nrows=9,ncols=1,figsize=(8,8),)#sharex=True, )
    thphpeaksnew = np.zeros((9,2))
    for j,ithphpx in enumerate(thphpeaks):
        c='b'
        if j == 4: 
            threshold = threshold0
        else:
            threshold = threshold
        ivec = hp.ang2vec(ithphpx[0],ithphpx[1], )
        ifullpx = np.linspace(0,npix,npix,dtype=int)
        maskipx = np.rad2deg(np.arccos(np.dot(ivec,fullvec))) < threshold
        if refilter:
            mean, std = np.mean(hpnest_filt[maskipx]),np.std(hpnest_filt[maskipx])
            maskipx2 = hpnest_filt[maskipx] < mean+3*std
            maskipx3 = hpnest_filt[maskipx] > mean-3*std
            maskipx[maskipx]=maskipx2*maskipx3
        maskidx = np.where(maskipx == True)[0]
        #useless max (just to plot in 1d not healpix)
        realmaxpx[j] = np.where(hpnest_filt[maskipx] == np.max(hpnest_filt[maskipx]))[0][0]
        #usefull max (healpix)
        absmaxpx[j] = maskidx[realmaxpx[j]]
        thphpeaksnew[j] = hp.pix2ang(nside,absmaxpx[j],nest=nest)
        #ax[j].set_title('masked values at {}deg from px'.format(threshold))

        if plotnine:
            if j == 3: c = 'r'
            ax[j].axvline(realmaxpx[j], c = 'k', alpha = 0.4, ls = '--')
            ax[j].plot(hpnest_filt[maskipx], 'o--', color = c, alpha = 0.4, label = 'filtered')
            ax[j].legend()        

    return hpnest, thphpeaksnew, absmaxpx#, thphpeaksnew
```

```{python}
DET = 93
AZ, EL = 0, 90

d = qubic.qubicdict.qubicDict()
d.read_from_file(os.environ['QUBIC_DICT']+'/global_source_oneDet.dict')
d['MultiBand'] = False
d['nf_sub'] = 1
d['kind'] = 'I'
d['config'] = 'FI'
d['RA_denter'], d['DEC_center'] = qubic.hor2equ(AZ, EL, 0)
center_gal = qubic.hor2gal(AZ, EL, 0)
sFI = qubic.QubicScene(d)
qFI = qubic.QubicInstrument(d)
dTD = d.copy()
dTD['config'] = 'TD'
sTD = qubic.QubicScene(dTD)
qTD = qubic.QubicInstrument(dTD)
```

```{python}
FPidentity = make_id_focalplane()
for i in range(248):
    print('pix', i+1, 'FP', qTD.detector.index[i], 
          'TES', FPidentity[qTD.detector.index[i]].TES,
         'ASIC', FPidentity[qTD.detector.index[i]].ASIC,
         'q_pix', tes2pix(FPidentity[qTD.detector.index[i]].TES,FPidentity[qTD.detector.index[i]].ASIC) - 1)
#tes2index(120,1), qTD.detector.index
```

```{python}
PIXNum = 93#242#123 #1-256. Numbering of the Healpix Files
if PIXNum in [4,36,68,100]:
    raise ValueError('Thermometer')
else:
    if PIXNum > 128:
        TESNum, ASIC = PIXNum - 128, 2
    else: 
        TESNum, ASIC = PIXNum , 1
    
# busco index # tes2index
PIXq = tes2pix(TESNum, ASIC) - 1 
FPidx = tes2index(TESNum, ASIC)
print(PIXq, FPidx)
#index2qubicsoft

#FPidx = qTD.detector.index[PIXq] #Take FP index from QubicInstrument
#TESNum, ASICNum = FPidentity[FPidx].TES, FPidentity[FPidx].ASIC

```

```{python}
# Take the direction of the central peak of the central detector
dTD['synthbeam_kmax'] = 8
qTD = qubic.QubicInstrument(dTD)
th_cent_all, ph_cent_all, _ = qTD._peak_angles(sTD, qTD.filter.nu, 
                                              qTD.detector[231].center, qTD.synthbeam, 
                                              getattr(qTD, 'horn', None), 
                                              getattr(qTD, 'primary_beam', None))
th_tes_all, ph_tes_all, _ = qTD._peak_angles(sTD, qTD.filter.nu, 
                                           qTD.detector[PIXq].center, qTD.synthbeam, 
                                           getattr(qTD, 'horn', None), 
                                           getattr(qTD, 'primary_beam', None))
#th_test, ph_test, _ = qtest._peak_angles(sTD, qTD.filter.nu, 
#                                         qtest.detector[123].center, qtest.synthbeam, 
#                                         getattr(qtest, 'horn', None), 
#                                         getattr(qtest, 'primary_beam', None))
dTD['synthbeam_kmax'] = 8
qTD = qubic.QubicInstrument(dTD)

#Take the position of the central peak
th_cent, ph_cent = th_cent_all[0,0], ph_cent_all[0,0]
th_tes, ph_tes = th_tes_all[0,0], ph_tes_all[0,0]

```

Look at the maps...

```{python}
hj = 0
figure(figsize = (8,8))
xlabel(r'n$_{x}$ = $\sin{\theta} \cos{\phi}$', fontsize = 15)
ylabel(r'n$_{y}$ = $\sin{\theta} \sin{\phi}$', fontsize = 15)
scatter(np.sin(th_tes_all)*np.cos(ph_tes_all), 
        np.sin(th_tes_all)*np.sin(ph_tes_all), label = 'perif TES')
scatter(np.sin(th_cent_all)*np.cos(ph_cent_all), 
        np.sin(th_cent_all)*np.sin(ph_cent_all), c = 'g', label = 'central TES')
scatter(np.sin(th_tes)*np.cos(ph_tes), 
        np.sin(th_tes)*np.sin(ph_tes), c = 'r')
legend()

vec_cent = np.array([np.sin(th_cent) * np.cos(ph_cent),
           np.sin(th_cent) * np.sin(ph_cent),
           np.cos(th_cent)])
vec_tes = np.array([np.sin(th_tes) * np.cos(ph_tes),
           np.sin(th_tes) * np.sin(ph_tes),
           np.cos(th_tes)])
```

Test for one TES... it works fine!


print(np.rad2deg(th_cent), np.rad2deg(th_tes))
print(np.rad2deg(ph_cent)+360, np.rad2deg(ph_tes)+180)
print(np.tan(ph_cent), np.tan(ph_cent+np.pi) )


np.rad2deg(hp.vec2ang(vec_cent)), np.rad2deg(hp.vec2ang(vec_tes))


hp.vec2ang(np.dot(sbfit.rotmatY(np.pi/2), vec_tes))

```{python}
# Get the data
dirfiles = os.environ['QUBIC_TODDIR']+'150GHz-2019-04-06/'
print('dirfiles :', dirfiles)

c50 = np.cos(np.radians(50))
azmin = -15./c50
azmax = 15./c50

# reload(sbfit)
flatmap, az, el = sbfit.get_flatmap(PIXNum, dirfiles, azmin = azmin, azmax=azmax)
npix = len(np.ravel(flatmap))

#imshow(flatmap,
#       extent=[np.min(az)*c50, np.max(az)*c50, np.min(el), np.max(el)], aspect='equal',
#      vmin=-3000, vmax=3000)
# colorbar()

alldata_renorm = np.zeros((256, npix))
for i in range(256):
    flatmap, az, el = sbfit.get_flatmap(i+1, dirfiles, azmin=azmin, azmax=azmax)
    alldata_renorm[i, :] = np.ravel((flatmap - np.mean(flatmap)) / np.std(flatmap))  

##### Estimating the median of all SB images - to be removed - Origin still unexplained...
med = np.reshape(np.median(alldata_renorm,axis=0),np.shape(flatmap))
mm = np.mean(med)
ss = np.std(med)

az_center = 90
el_center = 0

nside = 256
npix = 12*nside**2
nest = True
fullvec=hp.pix2vec(nside, range(0,npix), nest=nest)

t00 = time.time()
#for ites in range(9,10):

t0 = time.time()
newcenter = [hp.vec2ang(np.dot(sbfit.rotmatY(np.pi/2), vec_tes))[0][0],
            hp.vec2ang(np.dot(sbfit.rotmatY(np.pi/2), vec_tes))[1][0]]
#print(newcenter)
hpnest, thphpeaksnew, absmaxpx = fit_hpmap(PIXNum, dirfiles, 
                                           newcenter,
                                           plot = False,
                                       filterbeam = 2, threshold = 2, threshold0 = 2, plotcenter = False)

fig, ax1 = subplots(nrows = 1, ncols = 2, figsize = (10,8))
axes(ax1[0])
hp.gnomview(hpnest, reso = 10, nest = nest, title = 'Healpy projection (TES#{} ASIC {})'.format(TESNum,
                                                                                               ASICNum),
                  hold = True, cbar = False)
hp.graticule(dpar = 5, dmer = 5, color = 'w')

hp.projscatter(th_cent , ph_cent , rot = (0,0), marker = 'o', color = 'w')
hp.projscatter(th_tes , ph_tes , rot = (0,0), marker = 'o', color = 'g')

for ip in range(9):
    #loc = hp.pix2ang(nside,absmaxpx[jp], nest=nest)
    hp.projscatter(thphpeaksnew[ip], marker = '+', color = 'r')
    hp.projtext(thphpeaksnew[ip,0],thphpeaksnew[ip,1], s = '{}'.format(ip),color = 'w')
print('Done Healpy in {:.2f} minutes'.format((time.time() - t0)/60))

#Flat fit
t1 = time.time()
flatmap, az, el = sbfit.get_flatmap(PIXNum, dirfiles, remove = med, azmin = azmin, azmax = azmax)

#### Instantiate a model
sbfitmodel3 = sbfit.SbModelIndepPeaks(nrings = 2, common_fwhm = True, 
                                      no_xy_shift = False, distortion = False)

fit, xypeaks = sbfit.fit_sb(flatmap, az, el, sbfitmodel3, verbose = False, resample = False, 
                        doplot = False, extra_title = 'TES #{} ASIC {}'.format(TESNum, ASICNum))

axes(ax1[1])
title('Flat projection (TES#{} ASIC {})'.format(TESNum, ASICNum))
imshow(flatmap, extent = [np.min(az)*np.cos(np.radians(50)), 
                               np.max(az)*np.cos(np.radians(50)), 
                               np.min(el), np.max(el)])
scatter(xypeaks[0,:], xypeaks[1,:], marker = '+', color = 'r')
for ir in range(9):
    text(xypeaks[0,ir],xypeaks[1,ir], s = '{}'.format(ir)  , color = 'w')
grid(color = 'w', ls = '--', fillstyle = 'full')
xlabel('Az[deg]*cos(50)')
ylabel('El[deg]')
print('Done Flat in {:.2f} minutes'.format((time.time()-t1)/60))

    
print('All done in {} minutes'.format((time.time()-t00)/60) )
```

```{python}
figure(figsize=(8,8))
plot(qTD.detector[PIXq].center[0,0],qTD.detector[PIXq].center[0,1],'ks',ms=20)
qTD.detector.plot(fill=False)

```

```{python}
hp.gnomview(hpnest, reso = 8, nest = nest, title = 'Healpy projection (TES#{})'.format(PIXNum),
                  hold = True, cbar = False)

```

Saving peaks locations


dirsave = dirfiles+'/fit_HPpeaks/'
try:
    os.mkdir(dirsave)
    print('Fit saved in {}'.format(dirsave))    
except:
    print('Fit saved in {}'.format(dirsave))    
    print(' ')
TESMax = 3
for TESNum in range(1,TESMax+1):
    _, thphpeaks, _ = fit_hpmap(ites, dirfiles, az_center, el_center,
                                           filterbeam=2,threshold=2,threshold0=2,)
    print(thphpeaks)


Make pdf file with all TES... not working

.

.

.

.

.


## The idea is to get the FOV given a detector and the center of the FOV (determined from optical axis). Because of the synthesized bemas, not all the detectors will observe the same region.


```{python}
sbFI = qFI.get_synthbeam(sFI, detector_integrate = None)
sbTD = qTD.get_synthbeam(sTD, detector_integrate = None)
```

```{python}
idet = qFI.detector[231]
idetTD_center = qTD.detector[231]
idetTD_tes = qTD.detector[PIXNum]
#subplot(121)
#plot(idet.center[0,0], idet.center[0,1], 'ob')
#qFI.detector.plot()
#subplot(122)
plot(idetTD_center.center[0,0], idetTD_center.center[0,1], 'ob')
plot(idetTD_tes.center[0,0], idetTD_tes.center[0,1], 'og')
qTD.detector.plot()

```

```{python}
figure(figsize = (12,12))
hp.gnomview(np.sum(sbFI, axis=0), rot = (0, 90), title = 'FI', reso = 12, sub = 221)
hp.gnomview(np.sum(sbTD, axis=0), rot = (0, 90), title = 'TD', reso = 12, sub = 222, 
            min = 0, max = 5e7)
#addingmap = 0
#for i in range(248):
#    addingmap += sbfit.get_hpmap(i+1, dirfiles)
hp.gnomview(addingmap, title = 'Data', reso = 12, sub = 223, 
            min = 0, max = 1e6)
#hp.gnomview(sb[120], rot = (0, 90), reso = 12, sub = 223)
#hp.gnomview(sb[200], rot = (0, 90), reso = 12, sub = 224)
```

```{python}

```
