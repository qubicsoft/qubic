---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.7.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
# ##### %matplotlib notebook
# %matplotlib inline

from matplotlib import rc
rc('figure',figsize=(16,4))
rc('font',size=12)
rc('text',usetex=False)
rc('image', cmap='viridis')

from qubicpack import qubicpack as qp
from qubicpack.utilities import Qubic_DataDir
import qubic.fibtools as ft
import qubic.plotters as p
import qubic.lin_lib as ll
import qubic.demodulation_lib as dl
import qubic.io
import qubic.sb_fitting as sbfit
from qubicpack.pixel_translation import make_id_focalplane, plot_id_focalplane, tes2pix, tes2index

from pysimulators import FitsArray

from astroML.plotting import scatter_contour
import numpy as np
from matplotlib.pyplot import *
import matplotlib.mlab as mlab
import scipy.ndimage.filters as f
import glob
import string
import pickle
import scipy.signal as scsig
from scipy import interpolate
import os
import healpy as hp
import pandas as pd
import time
import scipy.ndimage.filters as f
```

```{python}
def create_hall_pointing(d, az, el, angspeed_psi, maxpsi,
                 date_obs = None, latitude = None, longitude = None, 
                 fix_azimuth = None, random_hwp = True):
    
    #This method will reproduce the pointing that is used in the hall to take the data. 
    #Will start from bottom left and will go up at fixed elevation.
    
    nsamples = len(az)*len(el)
    pp = QubicSampling(nsamples,date_obs = d['date_obs'], period = 0.1, 
        latitude = latitude, longitude = longitude)
    
    #Comented because we do not back and forth in simulations.. 
    #mult_el = []
    #for eachEl in el:
    #    mult_el.append(np.tile(eachEl, 2*len(az)))
    # Azimuth go and back and same elevation. 
    #az_back = az[::-1]
    #az = list(az)
    #az.extend(az_back)
    #mult_az = np.tile(az, len(el))
    #print(i,np.asarray(mult_el).ravel().shape)
    #pp.elevation = np.asarray(mult_el).ravel()
    #pp.azimuth = np.asarray(mult_az).ravel()
    
    mult_el = []
    for eachEl in el:
        mult_el.extend(np.tile(eachEl, len(az)))
    mult_az = []
    mult_az.append(np.tile(az, len(el)))
    pp.elevation = np.asarray(mult_el)#az2d.ravel()
    pp.azimuth = np.asarray(mult_az[0])#el2d.ravel()
    
    ### scan psi as well,
    pitch = pp.time * angspeed_psi
    pitch = pitch % (4 * maxpsi)
    mask = pitch > (2 * maxpsi)
    pitch[mask] = -pitch[mask] + 4 * maxpsi
    pitch -= maxpsi
    
    pp.pitch = pitch
    
    if random_hwp:
        pp.angle_hwp = np.random.random_integers(0, 7, nsamples) * 11.25
        
    if d['fix_azimuth']['apply']:
        pp.fix_az=True
        if d['fix_azimuth']['fix_hwp']:
            pp.angle_hwp=pp.pitch*0+ 11.25
        if d['fix_azimuth']['fix_pitch']:
            pp.pitch= 0
    else:
        pp.fix_az=False

    return pp

def npp(ipix):
    
    #neighboring pixel of the peak
    # map in nest
    return np.array(hp.get_all_neighbours(256, ipix,nest=True))

def selectcenter(hpmap, center, delta = 3, nside = 256, nest = True,
                threshold = 3, displaycenters = False, plot = False):
    
    #return the pixel of the central peak
    npix = 12 * nside ** 2
    centerarr = [center,
                center - delta * np.array([1,0]),
                center - 2 * delta * np.array([1,0]),
                center + delta * np.array([1,0]),
                center + 2 * delta * np.array([1,0])]

    fullvec = hp.pix2vec(nside, range(0,npix), nest = nest)
    relmaxpx = np.zeros((len(centerarr),))
    px = np.zeros((len(centerarr),), dtype = int)

    for j,icenter in enumerate(centerarr):
        ivec = hp.ang2vec(np.deg2rad(icenter[0]), np.deg2rad(icenter[1]))
        imaskpx = np.rad2deg(np.arccos(np.dot(ivec,fullvec))) < threshold
        imaskidx = np.where(imaskpx == True)[0]
        #print(imaskidx)
        relmaxpx[j] = np.max(hpmap[imaskpx])
        px[j] = imaskidx[np.argmax(hpmap[imaskpx])]

    indxmax = np.argmax(relmaxpx)
    pixmax, newcenter = px[indxmax], centerarr[indxmax]
    if plot:
        hp.gnomview(hpnest, reso = 12, rot = np.array([90,0]) - newcenter, nest = nest)
        if displaycenters:
            for each in centerarr:
                hp.projscatter(np.deg2rad(each), marker = '+', color = 'r')
        #print('crux', np.rad2deg(hp.pix2ang(256, pixmax, nest=nest)))
        hp.projscatter(hp.pix2ang(256, pixmax, nest = nest), marker = '+', color = 'r')

    return pixmax, newcenter


```

```{python}
def fit_hpmap(PIXNum, dirfiles, centerini, #el_center, 
              nside = 256, nest = True, filterbeam = 3,
             threshold = 3, threshold0 = 4, plotcenter = False, plot = False,
             plotnine = False, plotneig = False, refilter = False ):
    
    npix = 12 * nside ** 2

    hpmap = sbfit.get_hpmap(PIXNum, dirfiles)

    if nest:
        hpnest = hp.reorder(hpmap, r2n = nest, )
    else:
        hpnest = hpmap
    hpnest_filt = f.gaussian_filter(hpnest, filterbeam)

    centerini = [np.rad2deg(centerini[0]), np.rad2deg(centerini[1])]
    px, center = selectcenter(hpnest_filt, centerini, plot = plot)
    thetaphi = hp.pix2ang(nside, px, nest = nest)
    
    if plotcenter:
        vli = [px,]
        xlo = px-100
        xhi = px+100
        
        fig, ax = subplots(nrows = 1, ncols = 2, figsize = (12,4))
        ax[0].set_xlim(xlo,xhi)
        ax[0].plot(hpnest, 'bo--', label = 'raw')
        ax[0].plot(hpnest_filt, 'bo--', alpha = 0.4, label = 'filtered')
        ax[0].legend()
        for i in vli:
            ax[0].axvline(i, c = 'k', alpha = 0.4, ls = '--')
            neig = npp(i)
        hp.gnomview(hpnest, reso = 12, rot = center, nest = True)
        hp.projscatter(np.deg2rad(centerini[0]), np.deg2rad(centerini[1]), marker = '+', color = 'r')

    pxvec = hp.pix2vec(nside, px, nest = nest)
    fullvec = hp.pix2vec(nside, range(0,npix), nest = nest)
    fullpx = np.linspace(0, npix, npix, dtype = int)

    aberr = np.deg2rad(np.array([0,1.]))
    delta = np.deg2rad(12.5)
    #Old peaksordering
    #thphpeaks = [thetaphi,
    #             thetaphi-delta*np.array([1,0]),                 
    #            thetaphi+delta*np.array([1,0]), 
    #            thetaphi-delta*np.array([0,1]+aberr),
    #            thetaphi+delta*np.array([0,1]+aberr),
    #            thetaphi-delta*0.5*np.array([1,1]),
    #            thetaphi+delta*0.5*np.array([1,1]),
    #            thetaphi-delta*0.5*np.array([-1,1]),
    #            thetaphi+delta*0.5*np.array([-1,1]),
    #             ]
    
    #peaks ordering according JCh and instrument module
    thphpeaks = [thetaphi + delta * np.array([1,0]),
                 thetaphi - delta * 0.5 * np.array([-1,1]),
                 thetaphi - delta * np.array([0,1] + aberr), 
                 thetaphi + delta * 0.5 * np.array([1,1]),
                 thetaphi,
                 thetaphi - delta * 0.5 * np.array([1,1]),
                 thetaphi + delta * np.array([0,1] + aberr),
                 thetaphi + delta * 0.5 * np.array([-1,1]),
                 thetaphi - delta * np.array([1,0])
                 ]

    fullvec = hp.pix2vec(nside, range(0,npix), nest = nest)
    realmaxpx = np.zeros((9,), dtype = int)
    absmaxpx = np.zeros((9,), dtype = int)

    if plotnine: fig, ax = subplots(nrows = 9, ncols = 1, figsize = (8,8),)
    thphpeaksnew = np.zeros((9,2))
    
    for j, ithphpx in enumerate(thphpeaks):
        c = 'b'
        if j == 4: 
            threshold = threshold0
        else:
            threshold = threshold
            
        ivec = hp.ang2vec(ithphpx[0], ithphpx[1], )
        ifullpx = np.linspace(0, npix, npix, dtype = int)
        maskipx = np.rad2deg(np.arccos(np.dot(ivec,fullvec))) < threshold
        
        if refilter:
            mean, std = np.mean(hpnest_filt[maskipx]),np.std(hpnest_filt[maskipx])
            maskipx2 = hpnest_filt[maskipx] < mean+3*std
            maskipx3 = hpnest_filt[maskipx] > mean-3*std
            maskipx[maskipx] = maskipx2 * maskipx3
        maskidx = np.where(maskipx == True)[0]
        #useless max (just to plot in 1d not healpix)
        realmaxpx[j] = np.where(hpnest_filt[maskipx] == np.max(hpnest_filt[maskipx]))[0][0]
        #usefull max (healpix)
        absmaxpx[j] = maskidx[realmaxpx[j]]
        thphpeaksnew[j] = hp.pix2ang(nside,absmaxpx[j],nest = nest)

        if plotnine:
            if j == 3: c = 'r'
            ax[j].axvline(realmaxpx[j], c = 'k', alpha = 0.4, ls = '--')
            ax[j].plot(hpnest_filt[maskipx], 'o--', color = c, alpha = 0.4, label = 'filtered')
            ax[j].legend()        

    return hpnest, thphpeaksnew, absmaxpx
```

```{python}
AZ, EL = 0, 90

d = qubic.qubicdict.qubicDict()
d.read_from_file(os.environ['QUBIC_DICT']+'/global_source_oneDet.dict')
d['MultiBand'] = False
d['nf_sub'] = 1
d['kind'] = 'I'
d['config'] = 'FI'
d['RA_denter'], d['DEC_center'] = qubic.hor2equ(AZ, EL, 0)
d['synthbeam_fraction'] = 0.99
center_gal = qubic.hor2gal(AZ, EL, 0)
sFI = qubic.QubicScene(d)
qFI = qubic.QubicInstrument(d)
dTD = d.copy()
dTD['config'] = 'TD'
sTD = qubic.QubicScene(dTD)
qTD = qubic.QubicInstrument(dTD)
```

```{python}
PIXNum = 123#93#242#150# #1-256. Numbering of the Healpix Files

def q_pix(PIXNum):
    if PIXNum in [4,36,68,100]:
        raise ValueError('Thermometer')
    else:
        if PIXNum > 128:
            TESNum, ASIC = PIXNum - 128, 2
        else: 
            TESNum, ASIC = PIXNum , 1

    # busco index # tes2index
    PIXq = tes2pix(TESNum, ASIC) - 1 
    return PIXq, TESNum, ASIC

#FPidx = tes2index(TESNum, ASIC)
#print(PIXq, FPidx)

## Central pix
#FPidx_central = tes2index(96, 1)
#PIXcentral = np.where(qTD.detector.index == FPidx_central)[0][0]

#FP_index = tes2index(TESNum, ASIC)
#print('FP_index', FP_index)
#index_q = np.where(qTD.detector.index == FP_index)[0][0]
#print('a', index_q)
def _argsort_reverse(a, axis=-1):
    i = list(np.ogrid[[slice(x) for x in a.shape]])
    i[axis] = a.argsort(axis)[:, ::-1]
    return i

def _peak_angles_ref(scene, nu, position, synthbeam, horn, primary_beam,
                detector_ref = False, index_ref = None):
    """
    Compute the angles and intensity of the synthetic beam peaks which
    accounts for a specified energy fraction.

    """
    theta, phi = qubic.QubicInstrument._peak_angles_kmax(
        synthbeam.kmax, horn.spacing, horn.angle, nu, position)
    val = np.array(primary_beam(theta, phi), dtype=float, copy=False)
    val[~np.isfinite(val)] = 0
    
    if detector_ref:
        index = _argsort_reverse(val)
    elif not detector_ref:
        #if index_ref is None:
        #    raise ValueError("You have to give an indexes array from reference detector")
        index = index_ref
    
    #print('detector_ref', detector_ref)
    #print(type(theta),)
    #print(type(index))
    
    theta = theta[tuple(index)]
    phi = phi[tuple(index)]
    val = val[tuple(index)]
    cumval = np.cumsum(val, axis=-1)
    imaxs = np.argmax(cumval >= synthbeam.fraction * cumval[:, -1, None],
                      axis=-1) + 1
    imax = max(imaxs)

    # slice initial arrays to discard the non-significant peaks
    theta = theta[:, :imax]
    phi = phi[:, :imax]
    val = val[:, :imax]

    # remove additional per-detector non-significant peaks
    # and remove potential NaN in theta, phi
    for idet, imax_ in enumerate(imaxs):
        val[idet, imax_:] = 0
        theta[idet, imax_:] = np.pi / 2  # XXX 0 fails in polarization.f90.src (en2ephi and en2etheta_ephi)
        phi[idet, imax_:] = 0
    solid_angle = synthbeam.peak150.solid_angle * (150e9 / nu) ** 2
    val *= solid_angle / scene.solid_angle * len(horn)

    return theta, phi, val, index
```

```{python}
# Take the direction of the central peak of the central detector
dTD['synthbeam_kmax'] = 8
qTD = qubic.QubicInstrument(dTD)

PIXNum = 123#93#242#150# #1-256. Numbering of the Healpix Files
PIXCentral = 96
PIXq, TESNum, ASIC = q_pix(PIXNum)
PIXcentral, TESNum_c, ASIC_c = q_pix(PIXCentral)

def thph_qsoft(qinst, scene, soft_pix, new = False,
               PiRot = True, detector_ref = False, index_ref = None):
    '''
    Returns th,ph for each peaks for a given TES and instrument. 
    There is a pi rotation in z-axis to match with demodulated data
    '''
    if new:
        if detector_ref:
            sim_th, sim_ph, _, index_ref = _peak_angles_ref(scene, qinst.filter.nu, qinst.detector[soft_pix].center, 
                                                         qinst.synthbeam, getattr(qinst,'horn', None), 
                                                         getattr(qinst,'primary_beam', None), 
                                                         detector_ref = detector_ref )
        elif not detector_ref:
            sim_th, sim_ph, _, index_ref = _peak_angles_ref(scene, qinst.filter.nu, qinst.detector[soft_pix].center, 
                                                         qinst.synthbeam, getattr(qinst,'horn', None), 
                                                         getattr(qinst,'primary_beam', None), 
                                                         detector_ref = detector_ref, index_ref = index_ref )
    else:
        sim_th, sim_ph, _ = qinst._peak_angles(scene, qinst.filter.nu, 
                                               qinst.detector[soft_pix].center, qinst.synthbeam, 
                                               getattr(qinst, 'horn', None), 
                                               getattr(qinst, 'primary_beam', None))
    
        
    index = index_ref
        
    # PI rotation
    if PiRot:
        newthph = np.zeros((sim_th.shape[1],2))
        th_tes_all = np.zeros((1,sim_th.shape[1]) ) 
        ph_tes_all = np.zeros((1, sim_th.shape[1]) )

        for i in range(sim_th.shape[1]):
            newuv = np.dot(sbfit.rotmatZ(np.pi), sbfit.thph2uv(sim_th[0, i], sim_ph[0, i]) )
            newthph = sbfit.uv2thph(newuv)
            th_tes_all[0, i] = newthph[0]
            ph_tes_all[0, i] = newthph[1]
    
    return th_tes_all, ph_tes_all, index
```

Look at the maps...


from astropy.io import fits
hdus = fits.open(qubic.QubicCalibration(dTD).detarray)
#qTD.calibration.get('hornarray')
hdus[0].header


from qubic.selfcal_lib import get_TEScoordinates_ONAFP

xONAFP,yONAFP, _ = get_TEScoordinates_ONAFP(qTD)

```{python}
th_tes_all, ph_tes_all = thph_qsoft(qTD, sTD, PIXq)
th_cent_all, ph_cent_all = thph_qsoft(qTD, sTD, PIXcentral)
#Take central peak
th_cent, ph_cent = th_cent_all[0,0], ph_cent_all[0,0]
th_tes, ph_tes = th_tes_all[0,0], ph_tes_all[0,0]


hj = 0
figure(figsize = (8,8))
xlabel(r'n$_{x}$ = $\sin{\theta} \cos{\phi}$', fontsize = 15)
ylabel(r'n$_{y}$ = $\sin{\theta} \sin{\phi}$', fontsize = 15)
scatter(np.sin(th_tes_all)*np.cos(ph_tes_all), 
        np.sin(th_tes_all)*np.sin(ph_tes_all), 
        label = 'perif TES', color = 'b')
scatter(np.sin(th_cent_all)*np.cos(ph_cent_all), 
        np.sin(th_cent_all)*np.sin(ph_cent_all), c = 'g', label = 'central TES')
scatter(np.sin(th_tes)*np.cos(ph_tes), 
        np.sin(th_tes)*np.sin(ph_tes), c = 'r')
legend()

vec_cent = np.array([np.sin(th_cent) * np.cos(ph_cent),
           np.sin(th_cent) * np.sin(ph_cent),
           np.cos(th_cent)])
vec_tes = np.array([np.sin(th_tes) * np.cos(ph_tes),
           np.sin(th_tes) * np.sin(ph_tes),
           np.cos(th_tes)])

#savefig('Reference_frame_plots/TES{}ASIC{}_peaks'.format(TESNum,ASIC))
```

```{python}
#from mpl_toolkits.mplot3d import Axes3D
#rc['font':'size', 14]
fig = figure(figsize=(15,7))
ax = fig.add_subplot(1, 2, 1, projection='3d', facecolor = 'w')
ax.set_xlabel(r'X$_{GRF}$')
ax.set_ylabel(r'Y$_{GRF}$')
ax.set_zlabel(r'Z$_{GRF}$')
ax.set_xlim(-0.3, 0.3)
ax.set_ylim(-0.3, 0.3)
zmax = 13
ax.set_zlim(0,zmax)

# optycal axis
ax.plot([0,0], [0,0], [0,zmax], color = 'k')

# detectors in GRF frame
ax.plot(qTD.detector.center[...,0],
        qTD.detector.center[...,1], zdir ='z', zs = 0, marker = 's', ls = '', markersize = 3,
       color = 'b', alpha = 0.4)
ax.plot([qTD.detector.center[PIXcentral,0],],
        [qTD.detector.center[PIXcentral,1],], zdir ='z', zs = 0, marker = 's', ls = '', markersize = 3,
       color = 'c', alpha = 0.4)
ax.plot([qTD.detector.center[PIXq,0],],
        [qTD.detector.center[PIXq,1],], zdir ='z', zs = 0, marker = 's', ls = '', markersize = 3,
       color = 'm', alpha = 0.4)
# detectors in ONAFP frame
#ax.plot(xONAFP,yONAFP, zdir = 'z', zs = 0, marker = 's', ms = 3, color = 'r')

# horns in GRF frame
theta = np.linspace(0, 2 * np.pi, 201)
r = 0.005
xcir = r*np.cos(theta)
ycir = r*np.sin(theta)
for icenter in zip(qTD.horn.center[...,0], qTD.horn.center[...,1]):
    ax.plot(xcir + icenter[0], ycir +icenter[1], zdir = 'z', zs = 8, marker = '', ls = '-', lw = 2,
       color = 'g', alpha = 0.4)

# projected synthesized beam 
ax.plot(np.sin(th_cent_all[0])*np.cos(ph_cent_all[0]), 
        np.sin(th_cent_all[0])*np.sin(ph_cent_all[0]), zdir = 'z', zs = zmax, marker = 'o', 
        ls ='',  c = 'c', )
ax.plot(np.sin(th_tes_all[0])*np.cos(ph_tes_all[0]), 
        np.sin(th_tes_all[0])*np.sin(ph_tes_all[0]), zdir = 'z', zs = zmax, marker = 'o', 
        ls = '', c = 'm', )

ax2 = fig.add_subplot(1, 2, 2, projection='3d')
ax2.plot(qTD.detector.center[...,0],
        qTD.detector.center[...,1], zdir ='z', zs = 0, marker = 's', ls = '', markersize = 6,
       color = 'b', alpha = 0.4)
ax2.plot([qTD.detector.center[PIXq,0],],
        [qTD.detector.center[PIXq,1],], zdir ='z', zs = 0, marker = 's', ls = '', markersize = 6,
       color = 'm')
ax2.plot([qTD.detector.center[PIXcentral,0],],
        [qTD.detector.center[PIXcentral,1],], zdir ='z', zs = 0, marker = 's', ls = '', markersize = 6,
       color = 'c')

#a = plt.axes([0.2, 0.6, .2, .2], facecolor='y')
#plt.plot(t[:len(r)], r)
#plt.title('Impulse response')
#plt.xlim(0, 0.2)
#plt.xticks([])
#plt.yticks([])
```

Test for one TES... it works fine!


print(np.rad2deg(th_cent), np.rad2deg(th_tes))
print(np.rad2deg(ph_cent)+360, np.rad2deg(ph_tes)+180)
print(np.tan(ph_cent), np.tan(ph_cent+np.pi) )


np.rad2deg(hp.vec2ang(vec_cent)), np.rad2deg(hp.vec2ang(vec_tes))


hp.vec2ang(np.dot(sbfit.rotmatY(np.pi/2), vec_tes))

```{python}
def mask_unseen(hpmap, az, el, doconvert = False, nest = False):

    '''
    Mask unseen directions in the scan. Use as input the house keeping coordinates.
    Parameters: 
        hpmap. Healpix map (npix)
        az and el. Azimuth and Elevation coordinates read from azimuth.fits and elevation.fits
        doconvert. Consider the data as real azimuth and elevation 
                    (not implemented in that way in demodulation yet).
    Return: 
        hpmap[masked]
    '''
    if doconvert:
        hkcoords = np.meshgrid(az, el)
        radec = qubic.hor2equ(hkcoords[0].ravel(), hkcoords[1].ravel(), 0)
        phi = radec[0]
        theta = radec[1]
        #Rotation from Az,El housekiping to Az, El = 0,0
        newcoords = np.dot(sbfit.rotmatY(qubic.hor2equ(0,+50,0)[1]),  
                           hp.ang2vec(np.pi/2-np.deg2rad(theta), np.deg2rad(phi)).T).T
    else:
        hkcoords = np.meshgrid(az, el-50)
        phi = hkcoords[0].ravel()
        theta = hkcoords[1].ravel()
        newcoords = hp.ang2vec(np.pi/2-np.deg2rad(theta), np.deg2rad(phi))

    coordspix = hp.vec2pix(nside, newcoords[...,0], newcoords[...,1], newcoords[...,2], nest = nest)
    mask = np.zeros((12 * nside **2 ), dtype = bool)
    mask[coordspix] = 1
    hpmap[~mask] = hp.UNSEEN    
    #hp.mollview(hpmap, nest = True)
    show()
    
    return hpmap

hpnest_cp = hpnest.copy()

fakemap = mask_unseen(hpnest_cp, az, el, nest = True)
figure(figsize = (14,11))
subplot(221)
xlabel(r'azimuth (hk)')
ylabel(r'elevation (hk)')
azel = np.meshgrid(az, el)
scatter(azel[0], azel[1], marker = 'o', s = 0.1)
subplot(222)
xlabel(r'$\alpha$[deg]')
ylabel(r'$\delta$[deg]')
radec = qubic.hor2equ(azel[0].ravel(), azel[1].ravel(), 0)
#scatter_contour(radec[0],radec[1], filled_contour = False)
scatter(radec[0],radec[1], marker = 'o', s = 0.1)
subplot(223)
hp.gnomview(fakemap,
            xsize = 270, ysize = 200, reso = 12, 
            hold = True, cbar = False, nest = True,
           title = 'Heapy map nside = 256 (original)')
subplot(224)
hp.gnomview(hp.ud_grade(fakemap, 128, order_in = 'NESTED'),
            xsize = 270, ysize = 200, reso = 12, 
            hold = True, cbar = False, nest = True,
           title = 'Heapy map nside = 128 (udgraded)')
```

```{python}
# Get the data
dirfiles = os.environ['QUBIC_TODDIR']+'150GHz-2019-04-06/'
print('dirfiles :', dirfiles)

c50 = np.cos(np.radians(50))
azmin = -15./c50
azmax = 15./c50

flatmap, az, el = sbfit.get_flatmap(PIXNum, dirfiles, azmin = azmin, azmax=azmax)
npix = len(np.ravel(flatmap))

alldata_renorm = np.zeros((256, npix))
for i in range(256):
    flatmap, az, el = sbfit.get_flatmap(i+1, dirfiles, azmin=azmin, azmax=azmax)
    alldata_renorm[i, :] = np.ravel((flatmap - np.mean(flatmap)) / np.std(flatmap))  
t00 = time.time()
tesvec = np.array([93])#,64,59,91,28,124,9,105,11,107,1,97])
asicvec = np.array([1])#,2,1,2,1,2,1,2,1,2,1,2])
for j, tesic in enumerate(zip(tesvec,asicvec)):
    
    PIXq = tes2pix(tesic[0], tesic[1]) -1 
    if tesic[1] ==1:
        PIXNum = tesic[0] 
    else:
        PIXNum = tesic[0] + 128
    #Configuration fo the pixel number and peak and vector
    th_cent_all, ph_cent_all = thph_qsoft(qTD, sTD, PIXcentral)
    th_cent, ph_cent = th_cent_all[0,0], ph_cent_all[0,0]

    th_tes_all, ph_tes_all = thph_qsoft(qTD, sTD, PIXq)
    th_tes, ph_tes = th_tes_all[0,0], ph_tes_all[0,0]

    # theta, phi to vector of central peak for TES (p0 for fitting function)
    vec_tes = np.array([np.sin(th_tes) * np.cos(ph_tes),
           np.sin(th_tes) * np.sin(ph_tes),
           np.cos(th_tes)])
    
    ##### Estimating the median of all SB images - to be removed - Origin still unexplained...
    med = np.reshape(np.median(alldata_renorm,axis=0),np.shape(flatmap))
    mm = np.mean(med)
    ss = np.std(med)

    az_center = 90
    el_center = 0

    nside = 256
    nest = True
    fullvec = hp.pix2vec(nside, range(0, 12*nside**2), nest=nest)

    t0 = time.time()
    # Carry synth beam from polar cap to the equatorial one
    newcenter = [hp.vec2ang(np.dot(sbfit.rotmatY(np.pi/2), vec_tes))[0][0],
                hp.vec2ang(np.dot(sbfit.rotmatY(np.pi/2), vec_tes))[1][0]]

    #Fit for HEALPix maps
    hpnest, thphpeaksnew, absmaxpx = fit_hpmap(PIXNum, dirfiles, newcenter, plot = False, nest = nest,
                                       filterbeam = 2, threshold = 2, threshold0 = 2, plotcenter = False)
    hpnest = mask_unseen(hpnest, az, el, nest = nest)
    #End fit
    fig, ax1 = subplots(nrows = 1, ncols = 3, figsize = (14,4))
    axes(ax1[0])
    hp.gnomview(hpnest, reso = 10, nest = nest, 
                xsize = 200, ysize = 200,
                title = 'Healpy projection (TES#{} ASIC {})'.format(tesic[0], tesic[1]),
                hold = True, cbar = False)
    hp.graticule(dpar = 5, dmer = 5, color = 'w', verbose = False)
    hp.projscatter(th_cent , ph_cent , rot = (0,0), marker = 'o', color = 'w')
    hp.projscatter(th_tes , ph_tes , rot = (0,0), marker = 'o', color = 'g')

    for ip in range(9):
        hp.projscatter(thphpeaksnew[ip], marker = '+', color = 'r')
        hp.projtext(thphpeaksnew[ip,0],thphpeaksnew[ip,1], s = '{}'.format(ip),color = 'w')
    print('Done Healpy in {:.2f} minutes'.format((time.time() - t0)/60))

    #Flat fit
    t1 = time.time()
    flatmap, az, el = sbfit.get_flatmap(PIXNum, dirfiles, remove = med, azmin = azmin, azmax = azmax)

    #### Instantiate a model
    sbfitmodel3 = sbfit.SbModelIndepPeaks(nrings = 2, common_fwhm = True, 
                                          no_xy_shift = False, distortion = False)

    fit, xypeaks = sbfit.fit_sb(flatmap, az, el, sbfitmodel3, verbose = False, resample = False, 
                            doplot = False, extra_title = 'TES #{} ASIC {}'.format(tesic[0], tesic[1]))

    axes(ax1[1])
    title('Flat projection (TES#{} ASIC {})'.format(tesic[0], tesic[1]))
    imshow(flatmap, extent = [np.min(az)*np.cos(np.radians(50)), 
                               np.max(az)*np.cos(np.radians(50)), 
                               np.min(el), np.max(el)])
    scatter(xypeaks[0,:], xypeaks[1,:], marker = '+', color = 'r')
    for ir in range(9):
        text(xypeaks[0,ir],xypeaks[1,ir], s = '{}'.format(ir)  , color = 'w')
    grid(color = 'w', ls = '--', fillstyle = 'full')
    
    xlabel('Az[deg]*cos(50)')
    ylabel('El[deg]')
    print('Done Flat in {:.2f} minutes'.format((time.time()-t1)/60))

    axes(ax1[2])
    plot(qTD.detector[PIXq].center[0,0],qTD.detector[PIXq].center[0,1], 'gs', ms = 8)
    plot(qTD.detector[PIXcentral].center[0,0],qTD.detector[PIXcentral].center[0,1], 'ws', ms = 8)
    qTD.detector.plot(fill = True, facecolor = 'k', edgecolor = 'k', alpha = 0.1)
    ax1[2].set_aspect(np.diff(ax1[2].get_xlim()), 
                     anchor = (0.5,0.52), adjustable = 'box')
#savefig('Reference_frame_plots/TES{}ASIC{}_hpVSflat'.format(TESNum,ASIC))
print('All done in {} minutes'.format((time.time()-t00)/60) )
```

```{python}
cmap = get_cmap('brg', 12)
figure(figsize=(14,8))
tesvec = np.array([9,64,59,91,28,124,9,105,11,107,1,97])
asicvec = np.array([1,2,1,2,1,2,1,2,1,2,1,2])

th_ref, phi_ref, index_ref = thph_qsoft(qTD, sTD, PIXcentral, detector_ref = True )

for j, tesic in enumerate(zip(tesvec,asicvec)):
    
    parcolor = (len(tesvec)-j)/len(tesvec)
    PIXq = tes2pix(tesic[0], tesic[1]) -1 
    if tesic[1] ==1:
        PIXNum = tesic[0] 
    else:
        PIXNum = tesic[0] + 128

    th_tes_all, phi_tes_all, _ = thph_qsoft(qTD, sTD, PIXq, new = False,
                                            detector_ref = True, index_ref = index_ref )
    
    #th_tes_all, ph_tes_all = thph_qsoft(qTD, sTD, PIXq)
    th_tes, ph_tes = th_tes_all[0,0:9], ph_tes_all[0,0:9]
    subplot(121)
    scatter(np.sin(th_tes) * np.cos(ph_tes) , 
            np.sin(th_tes) * np.sin(ph_tes) , marker = 'o', color = cmap(parcolor))
    # theta, phi to vector of central peak for TES (p0 for fitting function)
    vec_tes = np.array([np.sin(th_tes) * np.cos(ph_tes),
           np.sin(th_tes) * np.sin(ph_tes),
           np.cos(th_tes)])
    newcenter = [hp.vec2ang(np.dot(sbfit.rotmatY(np.pi/2), vec_tes))[0][0],
                hp.vec2ang(np.dot(sbfit.rotmatY(np.pi/2), vec_tes))[1][0]]
    subplot(122)    
    plot(qTD.detector[PIXq].center[0,0],qTD.detector[PIXq].center[0,1], 's', 
         c = cmap(parcolor), ms = 9)
    plot(qTD.detector[PIXcentral].center[0,0],qTD.detector[PIXcentral].center[0,1],'ws',ms=9)
qTD.detector.plot(fill=True, facecolor = 'k', edgecolor = 'k', alpha = 0.1)
    
```

```{python}

```

```{python}

```

```{python}
#ubic.QubicInstrument._peak_angles_kmax(qTD.synthbeam.kmax, getattr(qTD, 'horn', None).spacing,
#                                      getattr(qTD, 'horn', None).angle, 
#                                       qTD.filter.nu, qTD.detector[231].center)
lmbda = 3e9 /qTD.filter.nu
angle = 45
kmax = qTD.synthbeam.kmax
horn_spacing = getattr(qTD, 'horn', None).spacing
_kx, _ky = np.mgrid[-kmax:kmax + 1, -kmax:kmax + 1]
kx = _kx * np.cos(angle * np.pi / 180) - _ky * np.sin(angle * np.pi / 180)
ky = _kx * np.sin(angle * np.pi / 180) + _ky * np.cos(angle * np.pi / 180)

position = -qTD.detector.center / np.sqrt(np.sum(qTD.detector.center ** 2, axis=-1))[..., None]

nx = position[:, 0, None] - lmbda * kx.ravel() / horn_spacing
ny = position[:, 1, None] - lmbda * ky.ravel() / horn_spacing
```

```{python}
figure(figsize = (10,6))
import numexpr as ne
local_dict = {'nx': nx, 'ny': ny}
the_x = ne.evaluate('arcsin(sqrt(nx**2 + ny**2))',
                            local_dict=local_dict)
phi_y = ne.evaluate('arctan2(ny, nx)', local_dict=local_dict)
print(len(phi_y), np.shape(nx))
#scatter(nx, ny)
scatter(the_x, phi_y)
#scatter(np.sin(the_x) * np.cos(phi_y),
#        np.sin(the_x) * np.sin(phi_y), alpha = 0.3)
```

# dirsave = dirfiles+'/fit_HPpeaks/'
try:
    os.mkdir(dirsave)
    print('Fit saved in {}'.format(dirsave))    
except:
    print('Fit saved in {}'.format(dirsave))    
    print(' ')
TESMax = 3
for TESNum in range(1,TESMax+1):
    _, thphpeaks, _ = fit_hpmap(ites, dirfiles, az_center, el_center,
                                           filterbeam=2,threshold=2,threshold0=2,)
    print(thphpeaks)


Make pdf file with all TES... not working

.

.

.

.

.


## The idea is to get the FOV given a detector and the center of the FOV (determined from optical axis). Because of the synthesized bemas, not all the detectors will observe the same region.


```{python}
sbFI = qFI.get_synthbeam(sFI, detector_integrate = None)
sbTD = qTD.get_synthbeam(sTD, detector_integrate = None)
```

```{python}
idet = qFI.detector[231]
idetTD_center = qTD.detector[231]
idetTD_tes = qTD.detector[PIXNum]
#subplot(121)
#plot(idet.center[0,0], idet.center[0,1], 'ob')
#qFI.detector.plot()
#subplot(122)
plot(idetTD_center.center[0,0], idetTD_center.center[0,1], 'ob')
plot(idetTD_tes.center[0,0], idetTD_tes.center[0,1], 'og')
qTD.detector.plot()

```

```{python}
figure(figsize = (12,12))
hp.gnomview(np.sum(sbFI, axis=0), rot = (0, 90), title = 'FI', reso = 12, sub = 221)
hp.gnomview(np.sum(sbTD, axis=0), rot = (0, 90), title = 'TD', reso = 12, sub = 222, 
            min = 0, max = 5e7)
#addingmap = 0
#for i in range(248):
#    addingmap += sbfit.get_hpmap(i+1, dirfiles)
hp.gnomview(addingmap, title = 'Data', reso = 12, sub = 223, 
            min = 0, max = 1e6)
#hp.gnomview(sb[120], rot = (0, 90), reso = 12, sub = 223)
#hp.gnomview(sb[200], rot = (0, 90), reso = 12, sub = 224)
```

```{python}

```
