---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

## Fit the fringe measurements

```{python}
from __future__ import division, print_function

# %matplotlib inline
import matplotlib
matplotlib.use('nbagg')

import glob
import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize as sop
import pandas as pd
from matplotlib.backends.backend_pdf import PdfPages
import scipy.optimize as sop

import qubic
from qubic import selfcal_lib as sc
from qubicpack.utilities import Qubic_DataDir

from qubicpack import qubicpack as qp
from qubicpack.qubicfp import qubicfp
import qubic.fibtools as ft
```

```{python}
# Load fringes
data_dir =  '/home/louisemousset/QUBIC/Qubic_work/Calibration/datas/2020-01-13/'

fringe = np.load(data_dir + 'fringe52-28.npy')
plt.imshow(fringe, vmin=-3, vmax=3, interpolation='none')
```

## Fit with an analytical function

```{python}
def sim_fringe_new(Amp, phase, det_dist=3e-3, focal=0.3,
                   baseline=14.e-3*4., nu=150.e9, alpha=-45.,
                   w=40.87e-3, yc=0., xc=0.):

    lam = 3.e8/nu
    alpha_rad = np.deg2rad(alpha)
    
    ndet = 17
    fringe = np.zeros((ndet, ndet))
    i, j = np.mgrid[0:ndet, 0:ndet]
    
    #w=np.sqrt(2*(12.9*np.pi/180*f/2.355)**2)
    
    gaussian = np.exp(-((16-i+xc)**2 + (j-yc)**2) * det_dist**2 / (w**2))
    xprime = (i * np.cos(alpha_rad) + j * np.sin(alpha_rad)) * det_dist
    interfrange = lam * focal / baseline
    fringe = Amp * np.cos((2. * np.pi / interfrange * xprime) + phase)# * gaussian
    
    return fringe

# Using the parameters that Michel found with the fit
fringes = sim_fringe_new(1., 0.277, focal=0.35, alpha=-44.4)
s = 0.051
extent = (-s, 0, -s, 0)
plt.figure()
plt.imshow(fringes, origin='lower', extent=extent)
```

```{python}
# Analytical function
def sim_fringe(param):
    Amp = param[0]
    focal = param[1]
    phase = param[2]
    alpha = param[3]
        
    yc = 0.
    xc = 0. 
    
    nu = 150.e9
    lam = 3.e8/nu
    alpha_rad = np.deg2rad(alpha)
    
    det_dist = 3e-3
    baseline = 14.e-3*4.
    
    ndet = 17
    fringe = np.zeros((ndet, ndet))
    i, j = np.mgrid[0:ndet, 0:ndet]
    
    w = 40.87e-3 # From Creidhe
    #w=np.sqrt(2*(12.9*np.pi/180*f/2.355)**2)
    
    gaussian = np.exp(-((16-i+xc)**2 + (j-yc)**2) * det_dist**2 / (w**2))
    xprime = (i * np.cos(alpha_rad) + j * np.sin(alpha_rad)) * det_dist
    interfrange = lam * focal / baseline
    fringe = Amp * np.cos((2. * np.pi / interfrange * xprime) + phase)# * gaussian
    
    return fringe

def sim_fringe_flat(param):
    fff = sim_fringe(param)
    return fff.ravel()

def sim_fringe_flat2(param):
    fff = sim_fringe(param)
    res = np.zeros(256)
    for xx in range(17):
        for yy in range(17):
            TESNum=int(tes_grid[xx,yy])
            AsicNum = int(10.*(tes_grid[xx,yy]-TESNum))+1
            TESindex = (TESNum-1) + 128 *(AsicNum -1)
            res[TESindex] = fff[xx,yy]
    return res

def compute_residuals(param, observation):
    """
    Return array: observation - model
    """
    model = sim_fringe_flat(param)
    err = 2000
    residual = (observation - model) / err
    print("residual: ", np.nansum(residual**2))
    
    return residual.astype(np.float64)
```

```{python}
param = [13e3, 300e-3, 0., -45.]#,40.87e-3]#,0.]
lim = 1e4
plt.imshow(sim_fringe(param), vmin=-lim, vmax=lim)

# Fit the measurement with the analytical model
param_guess = [13e3, 300e-3, 0, -50.]

tofit = (fringe).ravel()
tofit[np.isnan(tofit)] = 0.

param_est, cov_x, infodict, mesg_result, ret_value = sop.leastsq(compute_residuals, 
                                                                 param_guess, 
                                                                 args=(tofit.astype(np.float64)),
                                                                 full_output=True, 
                                                                 maxfev=10000, 
                                                                 epsfcn=np.finfo(np.float32).eps)

sigma_param_est = np.sqrt(np.diagonal(cov_x))

print("Return value:", ret_value)
print("Return message:", mesg_result)

if ret_value not in (1, 2, 3, 4):
    raise RuntimeError(mesg_result)

print("guess    :", param_guess)
print("solution :", param_est)
print("Error :", sigma_param_est)
print("Precision (%):",sigma_param_est/param_est*100)

```

```{python}
rcParams["image.cmap"]='viridis'

lim = 3
plt.figure()
plt.subplots_adjust(wspace=0.5)
plt.subplot(131)
plt.imshow(sim_fringe(param_est), vmin=-lim, vmax=lim)

plt.subplot(132)
imshow(fringe, vmin=-lim, vmax=lim)
# plt.colorbar()

maskresp = np.abs(fringe / sim_fringe(param_est))

plt.subplot(133)
imshow(maskresp)#, vmin=0, vmax=1)#,interpolation='bicubic')
plt.colorbar()
```

# Fit with the simulation

```{python}
def compute_diff(param, q, baseline, files, labels, observation):
    """
    Return array: observation - model
    """
    model = sc.get_simulation(param, q, baseline, files, labels, doplot=False, verbose=False)
    err = 200
    residual = (observation - np.ravel(model)) / err
    residual[np.isnan(residual)] = 0.
    print('param :', param)
    print("residual sum: ", np.nansum(residual**2))
    
    return residual.astype(np.float64)
```

```{python}
# Prepare the simulation
# Get a dictionary
basedir = Qubic_DataDir(datafile='instrument.py', ) 
print('basedir : ', basedir)
dictfilename = basedir + '/dicts/global_source_oneDet.dict'

d = qubic.qubicdict.qubicDict()
d.read_from_file(dictfilename)

# Path to the simulated files 
rep = Qubic_DataDir(datafile='detcentres.txt')
print('rep:', rep)

# Get simulation files
files = sorted(glob.glob(rep + '/*.dat'))

# Get the sample number from the first file
data0 = pd.read_csv(files[0], sep='\t', skiprows=0)
nn = data0['X_Index'].iloc[-1] + 1
print('Sampling number = {}'.format(nn))

# Make an instrument
baseline = [52, 28]
q = qubic.QubicInstrument(d)
q.horn.open = False
q.horn.open[np.asarray(baseline) - 1] = True

# Make labels
readv, labels = sc.make_labels(rep)
print(files)

```

```{python}
# Make a simulation
param = [0., 150.]
img = sc.get_simulation(param, q, baseline, files, labels, doplot=True)

residual = compute_diff(param, q, baseline, files, labels, np.ravel(fringe))

plt.figure()
plt.hist(residual)
```

```{python}
# Fit
param_guess = [0., 150.]

tofit = np.ravel(fringe)
tofit[np.isnan(tofit)] = 0.
tofit = tofit.astype(np.float64)

# Method 1
# param_est, cov_x, infodict, mesg, flag  = sop.leastsq(compute_diff, 
#                      param_guess,
#                      args=(q, baseline, files, labels, tofit),
#                      factor=1.,
#                      full_output=True,
#                      epsfcn=np.finfo(np.float32).eps)
# sigma_param_est = np.sqrt(np.diagonal(cov_x))

# print('====================== FIT DONE ==========================')
# print("Return value:", param_est)
# print('Flag', flag)
# print("Return message:", mesg)
# print("Error :", sigma_param_est)
# print("Precision (%):", sigma_param_est / param_est * 100)

# Method 2
myfit = sop.least_squares(compute_diff,
                         param_guess,
                         args=(q, baseline, files, labels, tofit),
#                          method='lm',
                         bounds=([-30., 30.], [130., 170.]),
                         ftol=1e-9)

print('====================== FIT DONE ==========================')
print('Estimation:', myfit.x)
print('Cost:', myfit.cost)
# print('Residuals:', myfit.fun)
print('Cost fct gradient:', myfit.grad)
print('Message:', myfit.message)
print('Success:', myfit.success)
```

```{python}
thefit = sc.get_simulation(myfit.x, q, baseline, files, labels, doplot=True)
```

```{python}

```
