---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Simulations for self-calibration (fringes)

#### Edited by Louise
I have implemented a class in selfcal_lib.py which allowed to do several simulations concerning the calibration. This notebook gives some examples of what you can do with.


One remark : I tried to put documentation for each function. On a jupyter notebook, if you want to have acces just press shift+tab when your cursor is on the name of the function. 

```{python pycharm={'is_executing': False}}
from __future__ import division, print_function

# %matplotlib inline
# %matplotlib notebook

import numpy as np
import matplotlib.pyplot as plt

from qubicpack.utilities import Qubic_DataDir

import qubic

from qubic import selfcal_lib as sc

plt.rcParams['figure.figsize'] = (7, 7)


import matplotlib.animation as animation
from IPython.display import HTML
```

```{python}
plt.plot(np.linspace(1, 10))
```

## Make a dictionary 
useful for the qubicsoft

```{python pycharm={'is_executing': False}}
# Use a tool from qubicpack to get a path
basedir = Qubic_DataDir(datafile='instrument.py', ) 
print('basedir : ', basedir)
dictfilename = basedir + '/dicts/global_source_oneDet.dict'

d = qubic.qubicdict.qubicDict()
d.read_from_file(dictfilename)
print(d)
```

## Create an object 

```{python}
baseline = [25, 57]
ca = sc.SelfCalibration(baseline, [], d)

# Look at methods that are in this class :
print(dir(ca))

```

## Get all combinations for one baseline
This is a simulation that doesn't take into account optical aberrations.

```{python}
# You need a qubic instrument for that function
q = qubic.QubicInstrument(d)
q.optics.focal_length = 0.30
S, Cminus_i, Cminus_j, Sminus_ij, Ci, Cj, Sij = ca.get_power_combinations(q, theta=list(np.deg2rad(np.arange(0, 12, 2))), 
                                                                          phi=list(np.zeros(6)), nu=150e9, reso=102,
                                                                          xmin=-0.051, xmax=0.051)

# They are 3D arrays : (reso, reso, #pointings)
print('shape of each combination :', Cminus_i.shape)
```

### Fringes by combining the different horn configurations

```{python}
# Make the combination (S_tot - Cminus_i - Cminus_j + Sminus_ij) / Ci
q = qubic.QubicInstrument(d)
q.optics.focal_length = 0.30
fringes = ca.compute_fringes(q, theta=list(np.deg2rad(np.arange(0, 4, 0.25))), 
                                phi=list(np.zeros(16)), reso=34, nu=120e9,
                             xmin=-0.051, xmax=0.051)
print(fringes.shape)
```

```{python}
nfringes = fringes.shape[2]  
all_fringes = []
fig = plt.figure()
for i in range(nfringes):
    im = plt.imshow(fringes[:, :, i], animated=True)
    all_fringes.append([im])

ani = animation.ArtistAnimation(fig, all_fringes, interval=1000, repeat=False)

HTML(ani.to_html5_video())
# ani.save('fringes_passing.mp4')
```

## Get the focal plane image for the real instrument

```{python}
real_fringes = sc.get_real_fp(fringes[:,:,0])
plt.subplot(321)
plt.imshow(real_fringes)

# Get only one quadrant:
real_fringes, real_fringes_quad = sc.get_real_fp(fringes[:,:,0], quadrant=3)
plt.subplot(322)
plt.imshow(real_fringes_quad)

# Remove dead detectors
# Build masks
full_mask, quart_mask = ca.get_dead_detectors_mask()
plt.subplot(323)
plt.imshow(full_mask)
plt.subplot(324)
plt.imshow(quart_mask)

# Apply the mask on the focal plane
plt.subplot(325)
plt.imshow(real_fringes*full_mask)
plt.subplot(326)
plt.imshow(real_fringes_quad*quart_mask)


```

```{python}
# Make the rotation to compare with what Michel obtained
Final_image = np.rot90(real_fringes_quad, k=2)
plt.imshow(Final_image)#, vmin=0., vmax=0.0001)
# ax = plt.gca();
# ax.set_xticks(np.arange(-0.5, 34, 1));
# ax.set_yticks(np.arange(0.5, 34, 1));
# ax.grid(color='w', linestyle='-', linewidth=1)
plt.savefig('/home/louisemousset/QUBIC/Qubic_images/plots/fringes_no_aber_25_57_focal30_120GHz.png')
```

```{python}
3*np.sqrt(2)*8.5

```

```{python}
150e9*14e-3*3*(np.sqrt(2)*8.5e-3)/299792458
```

# Power on the focal plane with optical aberrations
Using Creidhe simulations,
need to download the files at : https://drive.google.com/open?id=19dPHw_CeuFZ068b-VRT7N-LWzOL1fmfG

```{python}
# Path to the simulated files 
rep = Qubic_DataDir(datafile='detcentres.txt')

# Finges with aberations 
fringes_aber = ca.get_power_fp_aberration(rep)

# Divide by the power for only one horn open (gaussian on the FP)
# Problem : invalid value encountered in true_divide => some pixels are lost
# i = baseline[0]
# Ci_aber = ca.get_power_fp_aberration(rep, indep_config=[i])
# fringes_aber /= Ci_aber
```

```{python}
from matplotlib.patches import Circle
fig, ax = plt.subplots(1)
ax.imshow(fringes_aber)
circ = Circle((120, 120), 102, alpha=0.5, color='g')
ax.add_patch(circ)

# circle = plt.Circle((120,120),2)
rep
```

```{python}
# real FP with dead detectors
fringes_aber_real, fringes_aber_quad  = sc.get_real_fp(fringes_aber, quadrant=3)

# Apply the mask on the image with aberrations
plt.subplot(121)
plt.imshow(fringes_aber_real * full_mask)
plt.subplot(122)
plt.imshow(fringes_aber_quad * quart_mask)

```

```{python}
# Make the rotation to compare with what Michel obtained
Final_image_aber = np.rot90(fringes_aber_quad * quart_mask, k=2)
plt.imshow(Final_image_aber)
```

```{python}
# Other way to get fringes with aberrations :
# Make the combination (S_tot - Cminus_i - Cminus_j + Sminus_ij) / Ci
# Problem : Here again, because I divide by Ci, I loose some pixels...
fringes_aber_comb = ca.get_fringes_aberration_combination(rep)
print('fringes_aber_comb.shape shape :', fringes_aber_comb.shape)

```

```{python}
plt.imshow(fringes_aber_comb)
```

```{python}
# real FP with dead detectors
fringes_aber_comb_real, fringes_aber_comb_quad  = sc.get_real_fp(fringes_aber_comb, quadrant=3)

# Apply the mask on the image with aberations
plt.subplot(121)
plt.imshow(fringes_aber_comb_real * full_mask)
plt.subplot(122)
plt.imshow(fringes_aber_comb_quad * quart_mask)
plt.colorbar()
```

```{python}
# Make the rotation to compare with what Michel obtained
Final_image_aber_comb = np.rot90(fringes_aber_comb_quad * quart_mask, k=2)
plt.imshow(Final_image_aber_comb)
# plt.savefig('/home/louisemousset/QUBIC/Qubic_images/plots/fringes_aber_33_57')
```

# Change the instrument horn config

```{python}
q.horn.open=False # All close
q.horn.open[3]=True # Close one
q.horn
```

```{python}
# Power on the focal plane
power = sc.get_power_on_array(q, reso=200)
print('power shape :', power.shape)
plt.imshow(power[:,:,0])
```

# Get an array with TES signal

```{python}
signal = sc.image_fp2tes_signal(real_fringes)
print('shape : (#TES, #ASICS)', signal.shape)
```

```{python}
# Do the inverse
image_fp = sc.tes_signal2image_fp(signal)
plt.imshow(image_fp)
```

# Synthetic Beam on the sky

```{python}
# For the function, you need a instrument and a scene
q = qubic.QubicInstrument(d)
s = qubic.QubicScene(d)

sb = ca.get_synthetic_beam_sky(q, s, tes=93, default_open=True)

# The synthetic beam optained has a value for each pixel on the sky. 
# You should use Healpy if you want to plot it.
print('sb shape :', sb.shape)
```

# Michel simulation

```{python}
# The function that Michel used
def sim_fringe(param):
   Amp = param[0]
   f = param[1]
   phase = param[2]
   yc = 0. #param[3]
   xc = 0. #param[4]
   alpha = param[3]
   #w = param[4]
   allres = np.ones(256)
   mask = ft.image_asics(all1=allres)
   mask[0,12:]=np.nan
   mask[1:5,16]=np.nan
   mask[np.isnan(mask)]=0
   nu=150e9
   lam=3e8/nu
   bl=14e-3*4.#baseline
   #f=300e-3 # focal length
   fringe=np.zeros_like(mask)
   i, j = np.mgrid[0:17, 0:17]
   freq=bl/lam
   #w=np.sqrt(2*(12.9*np.pi/180*f/2.355)**2)
   w=40.87e-3 # From Creidhe
   #alpha = 90.
   fringe=Amp*np.cos(2.*np.pi*freq*(i*np.cos(alpha*np.pi/180)+j*np.sin(alpha*np.pi/180))*3e-3/f+phase)*mask*np.exp(-((16-i+xc)**2+(j-yc)**2)*3e-3**2/(w**2))
   return fringe.astype(np.float64)
```

```{python}
# Same function as Michel rewritten to understand how it works
def sim_fringe_new(Amp, phase, det_dist=3e-3, focal=0.3,
                   baseline=14.e-3*4., nu=150.e9, alpha=-45.,
                   w=40.87e-3, yc=0., xc=0.):

    lam = 3.e8/nu
    alpha_rad = np.deg2rad(alpha)
    
    ndet = 17
    fringe = np.zeros((ndet, ndet))
    i, j = np.mgrid[0:ndet, 0:ndet]
    
    #w=np.sqrt(2*(12.9*np.pi/180*f/2.355)**2)
    
    gaussian = np.exp(-((16-i+xc)**2 + (j-yc)**2) * det_dist**2 / (w**2))
    xprime = (i * np.cos(alpha_rad) + j * np.sin(alpha_rad)) * det_dist
    interfrange = lam * focal / baseline
    fringe = Amp * np.cos((2. * np.pi / interfrange * xprime) + phase)# * gaussian
    
    return fringe

# Using the parameters that Michel found with the fit
fringes = sim_fringe_new(1., 0.277, focal=0.35, alpha=-44.4)
plt.imshow(fringes)
```

```{python}

```
