---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.11.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
import pysm3
import pysm3.units as u
import numpy as np
import healpy as hp

from qubic import camb_interface as qc
import fgbuster as fgb
from comp_tools import format_alms

import warnings
warnings.filterwarnings("ignore")
```

## Define parameters for separation

```{python}
freqs = np.array([130, 145, 160, 175])
n = np.shape(freqs)[0]
instrument = fgb.get_instrument('Qubic')
instrument.frequency = freqs
```

```{python}
synthbeam_peak150_fwhm = 0.39268176  # in degrees
fwhm = synthbeam_peak150_fwhm * 150. / freqs  # Qubic beams
instrument.fwhm = fwhm
```

```{python}
nside = 256
lmax = 512
```

## Some useful functions

```{python}
def get_alm_maps(pixel_maps, apply_correction=False):
    """
    Compute alm coefficients and format them for FgBuster.
    """
    # check if beam corrections should be applied
    if apply_correction:
        beam_sigmas_rad = np.deg2rad(instrument.fwhm) / 2.355
        ell = np.arange(start=0, stop=lmax + 1)
        
    # compute maps
    alm_maps = None
    for f in range(n):
        alms = hp.map2alm(pixel_maps[f], lmax=lmax, pol=True)
        if f == 0:
            sh = np.shape(alms)
            alm_maps = np.empty((n, sh[0], 2 * sh[1]))
        if apply_correction:
            inverse_gauss_fl = np.exp(0.5 * np.square(beam_sigmas_rad[f] * ell))
        for i, t in enumerate(alms):
            if apply_correction:
                t_corr = hp.almxfl(t, inverse_gauss_fl)
            else:
                t_corr = t.copy()
            alm_maps[f, i] = format_alms(t_corr)
    return alm_maps
```

```{python}
def separate(comp, instr, maps_to_separate, tol=1e-12):
    solver_options = {}
    solver_options['disp'] = True
    fg_args = comp, instr, maps_to_separate
    fg_kwargs = {'method': 'BFGS', 'tol': 1e-12, 'options': solver_options}
    try:
        res = fgb.basic_comp_sep(*fg_args, **fg_kwargs)
    except KeyError:
        fg_kwargs['options']['disp'] = False
        res = fgb.basic_comp_sep(*fg_args, **fg_kwargs)
    return res
```

## 1) Separation with Dust only

```{python}
# generate sky map with PySM
sky1 = pysm3.Sky(nside=nside, preset_strings=['d0'], output_unit=u.uK_CMB)
maps1 = [sky1.get_emission(f * u.GHz) for f in freqs]
print(np.shape(maps1[0]))
print(maps1[0][0, :3])
```

```{python}
components1 = [fgb.Dust(150., temp=20.)]
r1 = separate(components1, instrument, get_alm_maps(maps1))
print()
print("message:", r1.message)
print("success:", r1.success)
print("result:", r1.x)
```

## 2) Separation of CMB and Dust

```{python}
# generate sky map with PySM
sky2 = pysm3.Sky(nside=nside, preset_strings=['d0', 'c1'], output_unit=u.uK_CMB)
maps2 = [sky2.get_emission(f * u.GHz) for f in freqs]
```

```{python}
components2 = [fgb.Dust(150., temp=20.), fgb.CMB()]
r2 = separate(components2, instrument, get_alm_maps(maps2))
print()
print("message:", r2.message)
print("success:", r2.success)
print("result:", r2.x)
```

## 3) Artificially smooth original maps to imitate QSS

```{python}
maps1_smooth = [hp.smoothing(m.copy(), fwhm=np.deg2rad(whm), pol=True) for m, whm in zip(maps1, fwhm)]
```

### with the correction...

```{python}
r1_smooth = separate(components1, instrument, get_alm_maps(maps1_smooth, apply_correction=True))
print()
print("message:", r1_smooth.message)
print("success:", r1_smooth.success)
print("result:", r1_smooth.x)
```

### ... and without

```{python}
r1_bis = separate(components1, instrument, get_alm_maps(maps1_smooth, apply_correction=False))
print()
print("message:", r1_bis.message)
print("success:", r1_bis.success)
print("result:", r1_bis.x)
```

### let's see what happens if we add CMB in the sky

```{python}
maps2_smooth = [hp.smoothing(m.copy(), fwhm=np.deg2rad(whm),
                             verbose=False, pol=True) for m, whm in zip(maps2, fwhm)]
```

```{python}
r_not_corrected = separate(components2, instrument, get_alm_maps(maps2_smooth, apply_correction=False))
r_corrected = separate(components2, instrument, get_alm_maps(maps2_smooth, apply_correction=True))
```

```{python}
print("  no correction ->", r_not_corrected.x)
print("with correction ->", r_corrected.x)
```
