---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.11.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
import pysm3
import pysm3.units as u
import numpy as np
import numpy.ma as ma
import healpy as hp
import pickle
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter
import pickle
from astropy.io import fits

from qubic import camb_interface as qc
import fgbuster as fgb
from comp_tools import format_alms, same_resolution

import warnings
warnings.filterwarnings("ignore")
```

## Example PySM map at 220 GHz with CMB+Dust

```{python}
nside = 256
npix = hp.nside2npix(nside)
f = 220

# generate I,Q,U sky maps with PySM
unit = u.uK_CMB
sky = pysm3.Sky(nside=nside, preset_strings=['d0', 'c1'], output_unit=unit)
sky_emission = sky.get_emission(220 * u.GHz)
value = sky_emission.value
carte = value[1]
```

```{python}
hp.mollview(carte, norm='hist', unit=unit, title='Q map of CMB+Dust at 220 GHz')
```

### Get Qubic coverage (dtheta=40)

```{python}
t = pickle.load(open('data/coverage_dtheta_40_pointing_6000.pkl', 'rb'))
coverage = hp.ud_grade(t['coverage'], nside_out=nside)
```

```{python}
def get_mask(thr=0.5):
    mask = np.empty(npix, dtype=bool)
    mask[...] = (coverage < (thr * np.max(coverage)))  # True = bad pixel
    return mask
```

```{python}
carte_qubic = ma.array(carte, mask=get_mask(), fill_value=hp.UNSEEN)
hp.mollview(carte_qubic, norm='hist', unit=unit, title="map with Qubic coverage > 0.5")
```

### Test effect of use_pixel_weights in anafast / map2alm

```{python}
lmax = 512
```

```{python}
weights_hdu = fits.PrimaryHDU(coverage)
weights_hdu.writeto("data/full_weights/healpix_full_weights_nside_{:04d}.fits".format(nside), overwrite=True)
with fits.open("data/full_weights/healpix_full_weights_nside_0256.fits") as hdu:
    hp.mollview(hdu[0].data)
```

```{python}
f_sky = np.sum(~get_mask()) / npix
print("sky fraction for mask at 0.5 threshold = {:.3f}".format(f_sky))
```

```{python}
alm_fullsky = hp.map2alm(carte, lmax=lmax, use_pixel_weights=False)
cl_fullsky = hp.alm2cl(alm_fullsky)
alm_qubic = hp.map2alm(carte_qubic, lmax=lmax, use_pixel_weights=False)
alm_weighted = hp.map2alm(carte, lmax=lmax, use_pixel_weights=True, datapath="data/")
```

```{python}
plt.semilogy(cl_fullsky / hp.alm2cl(alm_weighted), label="fullsky / weighted")
plt.legend()
print("pixel weights don't have any sizeable effect")
```

```{python}
plt.semilogy(cl_fullsky / hp.alm2cl(alm_qubic / f_sky), label="fullsky / qubic sky")
plt.legend()
print("but the sharp cut of the mask produces a big distortion in the power spectrum")
```

### How to reduce this effect ? let's try different thresholds

```{python}
fig, axe = plt.subplots(figsize=(12,6))
fig.suptitle("Comparison of power spectrum from full sky versus from partial sky (with different thresholds)",
             fontsize=16)
thrs = [0.5, 0.1, 0.01, 0.001, 0.0001, 0.00001]
for thr in thrs:
    mask = get_mask(thr=thr)
    f_sky = np.sum(~mask) / npix
    carte_patch = ma.array(carte, mask=mask, fill_value=hp.UNSEEN)
    alm_frac = hp.map2alm(carte_patch, lmax=lmax)
    axe.semilogy(cl_fullsky / hp.alm2cl(alm_frac / f_sky), label="thr={} ; fsky={:.3f}".format(thr, f_sky))
axe.legend()
axe.set_xlabel(r"multipole $l$", fontsize=14)
axe.set_ylabel(r"$C_l^{full} / C_l^{patch}$", fontsize=14)
plt.tight_layout()
plt.show()
```

## Testing FgBuster separation

```{python}
freqs = np.array([200, 220, 240])
sky_emissions = [sky.get_emission(f * u.GHz) for f in freqs]
maps = np.array([emission.value for emission in sky_emissions])
print(np.shape(maps))
```

```{python}
n = np.shape(freqs)[0]
instrument = fgb.get_instrument('Qubic')
instrument.frequency = freqs
synthbeam_peak150_fwhm = 0.39268176  # in degrees
fwhm = synthbeam_peak150_fwhm * 150. / freqs  # Qubic beams
instrument.fwhm = fwhm
components = [fgb.Dust(150., temp=20.), fgb.CMB()]
```

```{python}
def get_alm_maps(pixel_maps, resol_correction=False, ref_arcmin=None):
    """
    Compute alm maps from pixel maps and format them for FgBuster.
    """
    
    ell = np.arange(start=0, stop=lmax+1)

    if ref_arcmin is None:
        # if not specified take the lowest
        ref_arcmin = 60 * fwhm[0]  # in degrees
    ref_sigma_rad = np.deg2rad(ref_arcmin / 60.) / 2.355
    ref_fl = np.exp(- 0.5 * np.square(ref_sigma_rad * ell))

    beam_sigmas_rad = np.deg2rad(fwhm) / 2.355

    # pixwin = hp.pixwin(nside, lmax=lmax) if pixwin_correction else np.ones(lmax + 1)

    # compute maps
    alm_maps = None
    for f in range(n):
        alms = hp.map2alm(pixel_maps[f], lmax=lmax, pol=True)
        correction = None
        if f == 0:
            sh = np.shape(alms)
            alm_maps = np.empty((n, sh[0], 2 * sh[1]))
        if resol_correction:
            gauss_fl = np.exp(- 0.5 * np.square(beam_sigmas_rad[f] * ell))
            correction = 1 / gauss_fl# / pixwin
        for i, t in enumerate(alms):
            alm_maps[f, i] = format_alms(hp.almxfl(t, correction) if resol_correction else t)
    return alm_maps
```

```{python}
def separate(comp, instr, maps_to_separate, tol=1e-12, print_option=True):
    solver_options = {}
    solver_options['disp'] = True
    fg_args = comp, instr, maps_to_separate
    fg_kwargs = {'method': 'BFGS', 'tol': 1e-12, 'options': solver_options}
    try:
        res = fgb.basic_comp_sep(*fg_args, **fg_kwargs)
    except KeyError:
        fg_kwargs['options']['disp'] = False
        res = fgb.basic_comp_sep(*fg_args, **fg_kwargs)
    if print_option:
        print()
        print("message:", res.message)
        print("success:", res.success)
        print("result:", res.x)
    return res
```

### 1) fullsky, same resolution

```{python}
r = separate(components, instrument, get_alm_maps(maps))
```

### 2) qubic sky, same resolution, different thresholds for comparison

```{python}
for thr in thrs:
    t_mask = np.empty_like(maps)
    mask = get_mask(thr=thr)
    t_mask[...] = mask
    partial_maps = ma.array(maps, mask=t_mask, fill_value=hp.UNSEEN)
    r = separate(components, instrument, get_alm_maps(partial_maps), print_option=False)
    print("threshold = {} ; f_sky = {:.3f} ; beta = {}".format(thr, np.sum(~mask)/npix, r.x[0]))
```

### 3) full sky, with maps at Qubic resolutions

```{python}
maps_qubic = np.array([hp.smoothing(m.copy(), fwhm=np.deg2rad(whm), pol=True) for m, whm in zip(maps, fwhm)])
```

```{python}
print("without correction...")
r = separate(components, instrument, get_alm_maps(maps_qubic, resol_correction=False))
print("\nwith correction... reference resolution is taken as resolution at lowest frequency")
r = separate(components, instrument, get_alm_maps(maps_qubic, resol_correction=True))
```

### 4) qubic sky and qubic resolutions

```{python}
# we can compare different thresholds again
with_corrections = []
without_corrections = []
for thr in thrs:
    t_mask = np.empty_like(maps)
    mask = get_mask(thr=thr)
    t_mask[...] = mask
    partial_maps = ma.array(maps_qubic, mask=t_mask, fill_value=hp.UNSEEN)
    r1 = separate(components, instrument, get_alm_maps(partial_maps, resol_correction=False),
                 print_option=False)
    r2 = separate(components, instrument, get_alm_maps(partial_maps, resol_correction=True),
                 print_option=False)
    without_corrections.append(r1.x[0])
    with_corrections.append(r2.x[0])
```

```{python}
fig, axe = plt.subplots()
fig.suptitle("dust index estimation for qubic sky and qubic resolutions")

axe.semilogx(thrs, without_corrections, label='without corrections')
axe.semilogx(thrs, with_corrections, label='with corrections')
axe.set_xlabel("threshold on coverage map")
axe.set_ylabel("beta estimate")
axe.axhline(1.54, color='black', ls='--', label='true value')
axe.legend()

plt.show()
```
