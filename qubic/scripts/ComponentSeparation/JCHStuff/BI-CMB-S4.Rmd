---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
import s4bi
from importlib import reload
from scipy import constants
from astropy.cosmology import Planck15
import qubic
from qubic import mcmc
import healpy as hp
rc('figure',figsize=(16,4))
rc('font',size=12)



```

# CMB-S4 Description

```{python}
subplot(1,2,1)
errorbar(s4bi.s4_config['frequency'], s4bi.s4_config['depth_p'], xerr=s4bi.s4_config['bandwidth']/2, fmt='ro')
xlabel('Frequency [GHz]')
ylabel(r'Depth_p [$\mu$K.arcmin]')
title('CMB-S4 Configuration')
subplot(1,2,2)
errorbar(s4bi.s4_config['frequency'], s4bi.s4_config['fwhm'], xerr=s4bi.s4_config['bandwidth']/2, fmt='ro')
xlabel('Frequency [GHz]')
ylabel('FWHM [arcmin]')
title('CMB-S4 Configuration')
```

# QUBIC+ Description

```{python}
reload(s4bi)
# QUBIC+
qp_nsub = np.array([5, 5, 5, 5, 5, 5, 5, 5, 5, 5])
qp_effective_fraction = np.array([1., 1., 1., 1., 1., 1., 1., 1., 1.])

qp_config = s4bi.qubicify(s4bi.s4_config, qp_nsub, qp_effective_fraction)
print(qp_config['frequency'])
print(qp_config['depth_p'])
print(qp_config['bandwidth'])
    
subplot(1,2,1)
errorbar(s4bi.s4_config['frequency'], s4bi.s4_config['depth_p'], xerr=s4bi.s4_config['bandwidth']/2, fmt='ro', label='CMB-S4')
errorbar(qp_config['frequency'], qp_config['depth_p'], xerr=qp_config['bandwidth']/2, fmt='bo', label='BI')
xlabel('Frequency [GHz]')
ylabel(r'Depth_p [$\mu$K.arcmin]')
title('CMB-S4 Configuration')
legend()
subplot(1,2,2)
errorbar(s4bi.s4_config['frequency'], s4bi.s4_config['fwhm'], xerr=s4bi.s4_config['bandwidth']/2, fmt='ro', label='CMB-S4')
errorbar(qp_config['frequency'], qp_config['fwhm'], xerr=qp_config['bandwidth']/2, fmt='bo', label='BI')
xlabel('Frequency [GHz]')
ylabel('FWHM [arcmin]')
title('CMB-S4 Configuration')
legend()
```

# Component maps

```{python}
reload(s4bi)
components = ['c1', 'd0', 's0']
ref_freqs = [150., 353., 70.]
fsky = 0.03
nside = 256
radec_center = [0, -57]
center = qubic.equ2gal(radec_center[0], radec_center[1])

map_CMB, map_dust_353GHz, map_sync_70GHz = s4bi.get_component_maps(components, ref_freqs, nside, fsky)

```

```{python}
stokes = ['I', 'Q', 'U', 'P']
okpix = map_CMB[0,:] != hp.UNSEEN

m_sync_70GHz = np.mean(map_sync_70GHz[:,okpix], axis=1)
s_sync_70GHz = np.std(map_sync_70GHz[:,okpix], axis=1)

m_dust_353GHz = np.mean(map_dust_353GHz[:,okpix], axis=1)
s_dust_353GHz = np.std(map_dust_353GHz[:,okpix], axis=1)

m_CMB = np.mean(map_CMB[:,okpix], axis=1)
s_CMB = np.std(map_CMB[:,okpix], axis=1)


for c in components:
    figure()
    for istk in range(4):
        hp.gnomview(map_sync_70GHz[istk,:], rot=center, reso=15, 
                    title='Synchrotron '+stokes[istk]+' at 70 GHz ($\mu$K$_{CMB}$)'+'\n {0:5.2g}+/-{1:5.2g}'.format(m_sync_70GHz[istk], s_sync_70GHz[istk]), sub=(1,4,istk+1))

figure()    
for istk in range(4):
    hp.gnomview(map_dust_353GHz[istk,:], rot=center, reso=15, 
                title='Dust '+stokes[istk]+' at 353 GHz ($\mu$K$_{CMB}$)'+'\n {0:5.2g}+/-{1:5.2g}'.format(m_dust_353GHz[istk], s_dust_353GHz[istk]), sub=(1,4,istk+1))

figure()    
for istk in range(4):
    hp.gnomview(map_CMB[istk,:], rot=center, reso=15, 
                title='CMB '+stokes[istk]+' ($\mu$K$_{CMB}$)'+'\n {0:5.2g}+/-{1:5.2g}'.format(m_CMB[istk], s_CMB[istk]), sub=(1,4,istk+1))


```

# Component Models

FGBuster gives components scaled to 1 at their respective reference frequencies. We have added a double-beta component model.

```{python}
rc('figure',figsize=(16,8))
rc('font',size=12)

import fgbuster
from fgbuster import CMB, Dust, Synchrotron, AnalyticComponent, ModifiedBlackBody

dust_ref_freq = 353.
sync_ref_freq = 70.
dust = Dust(dust_ref_freq, beta_d=1.54, temp=20)
cmb = CMB() 
sync = Synchrotron(sync_ref_freq, beta_pl=-3)

### The double beta component model
analytic_expr = s4bi.double_beta_dust_FGB_Model()
dbdust = AnalyticComponent(analytic_expr, nu0=353, temp=20., h_over_k=constants.h * 1e9 / constants.k)
print(dbdust.params)   # parameters are beta0, beta1 and nubreak
# let's fix the params for now
beta0 = 1.3
beta1 = 1.54
nubreak = 200.

numin = 20
numax = 400
nnu = 1000
nus = np.linspace(numin, numax, nnu)

plot(nus, dust.eval(nus), label='Dust')
plot(nus, sync.eval(nus), label='Synchrotron')
plot(nus, cmb.eval(nus), label='CMB')
plot(nus, dbdust.eval(nus, beta0, beta1, nubreak), 
     label='Double Beta Dust with beta_0={}, beta_1={}, nubreak={}'.format(beta0, beta1, nubreak))
xlabel('Frequency [GHz]')
ylabel('SED')
yscale('log')
xscale('log')
legend()
title('All normalized to 1 at a ref frequency')
```

Now we use the normalization (RMS) found from PYSM in our region ito scale them:

```{python}
mystk = [0,3]
beta0 = 1.3
beta1 = 1.54
nubreak = 200.

ii=0
for istk in mystk:
    subplot(1,2,ii+1)
    ii+=1
    plot(nus, dust.eval(nus) * s_dust_353GHz[istk], label='Dust')
    plot(nus, sync.eval(nus) * s_sync_70GHz[istk], label='Synchrotron')
    plot(nus, cmb.eval(nus) * s_CMB[istk], label='CMB')
    plot(nus, dbdust.eval(nus, beta0, beta1, nubreak) * s_dust_353GHz[istk], label='Double Beta Dust with beta_0={}, beta_1={}, nubreak={}'.format(beta0, beta1, nubreak))
    xlabel('Frequency [GHz]')
    ylabel(r'SED [$\mu K_{CMB}$]')
    yscale('log')
    xscale('log')
    title('Stokes '+stokes[istk]+' in clean QUBIC region {}%'.format(fsky*100))
    legend()
tight_layout()
```

# First test: fitting the single beta with a true single beta

```{python}
reload(s4bi)
reload(mcmc)

dust_ref_freq = 353.
sync_ref_freq = 70.
dust_model = Dust(dust_ref_freq, temp=20)
sync_model = Synchrotron(sync_ref_freq)

def model_1beta(x, pars, extra_args=None):
    sync_amp = pars[0]
    sync_pl = pars[1]
    cmb = pars[2]
    dust_amp = pars[3]
    beta_dust = pars[4]
    dust = dust_amp * dust_model.eval(x, beta_dust) 
    sync = sync_amp * sync_model.eval(x, sync_pl)
    return cmb + dust + sync

pars_true = np.array([s_sync_70GHz[3], -3, s_CMB[3], s_dust_353GHz[3], 1.54])
vals = model_1beta(nus, pars_true)

arcmins_squared = 60**2

#### S4 Data
nus_s4 = s4bi.s4_config['frequency']
sed_s4 = model_1beta(nus_s4, pars_true)
err_sed_s4 = s4bi.s4_config['depth_p'] / np.sqrt(arcmins_squared)

#### S4BI Data
qp_nsub = np.array([1, 1, 1, 5, 5, 5, 5, 5, 5, 5])
qp_effective_fraction = np.array([1., 1., 1., 1., 1., 1., 1., 1., 1.])
qp_suboptimality = np.array([False, False, False, True, True, True, True, True, True])
qp_config = s4bi.qubicify(s4bi.s4_config, qp_nsub, qp_effective_fraction, suboptimality=qp_suboptimality)
nus_qp = qp_config['frequency']
sed_qp = model_1beta(nus_qp, pars_true)
err_sed_qp = qp_config['depth_p'] / np.sqrt(arcmins_squared)



plot(nus, vals)
errorbar(nus_qp, sed_qp, yerr=err_sed_qp, fmt='ro', capsize=4)
errorbar(nus_s4, sed_s4, yerr=err_sed_s4, fmt='bo', capsize=4)
yscale('log')
xscale('log')
```

```{python}
from qubic import mcmc
reload(mcmc)
p0 = pars_true.copy()

fixedpars = np.array([1, 1, 0, 0, 0])

ll = mcmc.LogLikelihood(xvals=nus_s4, yvals=sed_s4, errors=err_sed_s4,
        p0=p0, model=model_1beta, fixedpars=fixedpars)
nbmc = 3000
samp = ll.run(nbmc)
flat_samples_s4 = samp.get_chain(discard=nbmc//2, thin=32, flat=True)


ll_qp = mcmc.LogLikelihood(xvals=nus_qp, yvals=sed_qp, errors=err_sed_qp,
        p0=p0, model=model_1beta, fixedpars=fixedpars)
nbmc = 3000
samp_qp = ll_qp.run(nbmc)
flat_samples_qp = samp_qp.get_chain(discard=nbmc//2, thin=32, flat=True)


```

```{python}
from getdist import plots, MCSamples

allnames = np.array(['SyncAmp', 'SyncBeta', 'CMB', 'DustAmp', 'DustBeta'])
alllabels = np.array(['A_{sync}', r'\beta_{sync}', 'A_{CMB}', 'A_{dust}', r'\beta_{dust}'])

names = allnames[fixedpars==0]
labels = alllabels[fixedpars==0]
mytrue = pars_true[fixedpars==0]

mkrs = {}
for i in range(len(names)):
    mkrs[names[i]]=mytrue[i]

samps = MCSamples(samples=flat_samples_s4, names=names, labels=labels)
samps_qp = MCSamples(samples=flat_samples_qp, names=names, labels=labels)

figure()
g = plots.getSubplotPlotter()
g.settings.scaling=False
g.settings.axes_fontsize=12
g.triangle_plot([samps_qp, samps], filled=True,title_limit=2, legend_labels=['QUBIC+', 'CMB-S4'], markers=mkrs)
```

# Second test: fitting the double beta with a single beta

```{python}
reload(s4bi)
reload(mcmc)

dust_ref_freq = 353.
sync_ref_freq = 70.
dust_model = Dust(dust_ref_freq, temp=20)
print(dust_model.params)
sync_model = Synchrotron(sync_ref_freq)
double_dust_model = AnalyticComponent(analytic_expr, nu0=353, temp=20., h_over_k=constants.h * 1e9 / constants.k)
print(double_dust_model.params)   # parameters are beta0, beta1 and nubreak




def model_2beta(x, pars, extra_args=None):
    sync_amp = pars[0]
    sync_pl = pars[1]
    cmb = pars[2]
    dust_amp = pars[3]
    beta0_dust = pars[4]
    beta1_dust = pars[5]
    nubreak_dust = pars[6]
    dust = dust_amp * double_dust_model.eval(x, beta0_dust, beta1_dust, nubreak_dust) 
    sync = sync_amp * sync_model.eval(x, sync_pl)
    return cmb + dust + sync

pars_true = np.array([s_sync_70GHz[3], -3, s_CMB[3]/30e10, s_dust_353GHz[3], 1.2, 1.7, 240])
vals = model_2beta(nus, pars_true)

arcmins_squared = 1240*60**2   #1240 = 3% of the sky

#### S4 Data
nus_s4 = s4bi.s4_config['frequency']
sed_s4 = model_2beta(nus_s4, pars_true)
err_sed_s4 = s4bi.s4_config['depth_p'] / np.sqrt(arcmins_squared)

#### S4BI Data
qp_nsub = np.array([1, 1, 1, 5, 5, 5, 5, 5, 5, 5])
qp_effective_fraction = np.array([1., 1., 1., 1., 1., 1., 1., 1., 1.])
qp_suboptimality = np.array([False, False, False, True, True, True, True, True, True])
qp_config = s4bi.qubicify(s4bi.s4_config, qp_nsub, qp_effective_fraction, suboptimality=qp_suboptimality)
nus_qp = qp_config['frequency']
sed_qp = model_2beta(nus_qp, pars_true)
err_sed_qp = qp_config['depth_p'] / np.sqrt(arcmins_squared)



plot(nus, vals)
errorbar(nus_qp, sed_qp, yerr=err_sed_qp, fmt='ro', capsize=4)
errorbar(nus_s4, sed_s4, yerr=err_sed_s4, fmt='bo', capsize=4)
axvline(x=pars_true[6],ls=':', color='k')
yscale('log')
xscale('log')
```

```{python}
from qubic import mcmc
reload(mcmc)
p0 = pars_true.copy()

fixedpars = np.array([1, 1, 0, 0, 0, 0, 0])

ll = mcmc.LogLikelihood(xvals=nus_s4, yvals=sed_s4, errors=err_sed_s4,
        p0=p0, model=model_2beta, fixedpars=fixedpars)
nbmc = 5000
samp = ll.run(nbmc)
flat_samples_s4 = samp.get_chain(discard=nbmc//2, thin=32, flat=True)


ll_qp = mcmc.LogLikelihood(xvals=nus_qp, yvals=sed_qp, errors=err_sed_qp,
        p0=p0, model=model_2beta, fixedpars=fixedpars)
nbmc = 5000
samp_qp = ll_qp.run(nbmc)
flat_samples_qp = samp_qp.get_chain(discard=nbmc//2, thin=32, flat=True)


```

```{python}
allnames = np.array(['SyncAmp', 'SyncBeta', 'CMB', 'DustAmp', 'DustBeta0', 'DustBeta1', 'DustNuBreak'])
alllabels = np.array(['A_{sync}', r'\beta_{sync}', 'A_{CMB}', 'A_{dust}', r'\beta^0_{dust}', r'\beta^1_{dust}', r'\nu^{break}_{dust}'])

names = allnames[fixedpars==0]
labels = alllabels[fixedpars==0]
mytrue = pars_true[fixedpars==0]

mkrs = {}
for i in range(len(names)):
    mkrs[names[i]]=mytrue[i]

samps = MCSamples(samples=flat_samples_s4, names=names, labels=labels)
samps_qp = MCSamples(samples=flat_samples_qp, names=names, labels=labels)

figure()
g = plots.getSubplotPlotter()
g.settings.scaling=False
g.settings.axes_fontsize=12
g.triangle_plot([samps, samps_qp], filled=True,title_limit=2, legend_labels=['CMB-S4', 'QUBIC+'], markers=mkrs)
```

```{python}

```

```{python}

```

```{python}

```
