---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
import pickle
import glob
```

```{python}
directory = '/Users/hamilton/Downloads/bandpass_resultslist/'
files = glob.glob(directory+'*ASIC*.pickle')
```

```{python}
nums = np.zeros(256)
data = np.zeros((256, 320))
errdata = np.zeros((256, 320))
for f in files:
    bla = int(f.split('_')[-2][3:])
    truc = pickle.load(open(f, 'rb'))
    asic = truc[0]['asic']
    nums[(bla-1)+128*(asic-1)] = (bla-1)+128*(asic-1)
    for i in range(320):
        data[(bla-1)+128*(asic-1),i] = truc[i]['demodulated signal']
        errdata[(bla-1)+128*(asic-1),i] = truc[i]['demodulated signal error']

freqs = np.linspace(110, 190, 320)
```

```{python}
ok = nums !=0
mynums = nums[ok]
mydata = data[ok,:]
mydataerr = errdata[ok,:]
imshow(mydata)
np.shape(mydata)
```

```{python}
mydatanorm = np.zeros_like(mydata)
mydataerrnorm = np.zeros_like(mydata)
for i in range(len(mynums)):
    #mydatanorm[i,:] = mydata[i,:]/np.nanmax(mydata[i,:])    
    mydatanorm[i,:] = mydata[i,:]/np.nanmedian(mydata[i,100:250])
    mydataerrnorm[i,:] = mydataerr[i,:]/np.nanmedian(mydata[i,100:250])
```

```{python}
imshow(np.log(mydatanorm))
```

```{python}
med = np.nanmedian(mydatanorm, axis=0)
plot(freqs, med)
for i in range(len(mynums)):
    plot(freqs, mydatanorm[i,:], 'k', alpha=0.01)
ylim(0,2)

```

```{python}
chi2 = np.zeros(len(mynums))
for i in range(len(mynums)):
    chi2[i] = np.sum( ((mydatanorm[i,:] - med)/mydataerrnorm[i,:])**2)
    #chi2[i] = np.sum( ((mydatanorm[i,:] - med))**2)
a=hist(np.log10(chi2), range=[-0.1, 8], bins=100)
```

```{python}
rc('figure', figsize=(16, 7))
rc('font', size=15)
ok = chi2 < 1000
newmed = np.nanmedian(mydatanorm[ok,:], axis=0)
wav, varav = np.average(mydatanorm[ok,:], axis=0, weights=1./mydataerrnorm[ok,:]**2, returned=True)
staterrors = np.std(mydatanorm[ok,:], axis=0)/np.sqrt(np.sum(ok))

subplot(1,2,1)
plot(freqs, med, label='Median All')
plot(freqs, newmed, label='New Median ({})'.format(np.sum(ok)))
errorbar(freqs, wav, yerr=np.sqrt(1./varav), fmt='r.', label='Weighted Average ({}) + Analytical errors'.format(np.sum(ok)))
legend()
yscale('log')

subplot(1,2,2)
staterrors = np.std(mydatanorm[ok,:], axis=0)/np.sqrt(np.sum(ok))
plot(freqs, med, label='Median All')
plot(freqs, newmed, label='New Median ({})'.format(np.sum(ok)))
errorbar(freqs, wav, yerr=staterrors, fmt='r.', label='Weighted Average ({}) + Empirical $\sigma$'.format(np.sum(ok)))
legend()
yscale('log')
```

```{python}
pickle.dump([freqs, med, newmed, wav, np.sqrt(1./varav), staterrors], open(directory+'toto.pkl.txt', 'wb'))
```

```{python}
mynums[ok]+1
```

```{python}
import numpy as np
from pylab import *
from scipy import interpolate

class MySplineFitting:
    def __init__(self,xin,yin,covarin,nbspl,logspace=False):
        # input parameters
        self.x=xin
        self.y=yin
        self.nbspl=nbspl
        covar=covarin
        if np.size(np.shape(covarin)) == 1:
            err=covarin
            covar=np.zeros((np.size(err),np.size(err)))
            covar[np.arange(np.size(err)),np.arange(np.size(err))]=err**2
        
        self.covar=covar
        self.invcovar=np.linalg.inv(covar)
        
        # Prepare splines
        xspl=np.linspace(np.min(self.x),np.max(self.x),nbspl)
        if logspace==True: xspl=np.logspace(np.log10(np.min(self.x)),np.log10(np.max(self.x)),nbspl)
        self.xspl=xspl
        F=np.zeros((np.size(xin),nbspl))
        self.F=F
        for i in np.arange(nbspl):
            self.F[:,i]=self.get_spline_tofit(xspl,i,xin)
        
        # solution of the chi square
        ft_cinv_y=np.dot(np.transpose(F),np.dot(self.invcovar,self.y))
        covout=np.linalg.inv(np.dot(np.transpose(F),np.dot(self.invcovar,F)))
        alpha=np.dot(covout,ft_cinv_y)
        fitted=np.dot(F,alpha)
        
        # output
        self.residuals=self.y-fitted
        self.chi2=np.dot(np.transpose(self.residuals), np.dot(self.invcovar, self.residuals))
        self.ndf=np.size(xin)-np.size(alpha)
        self.alpha=alpha
        self.covout=covout
        self.dalpha=np.sqrt(np.diagonal(covout))
    
    def __call__(self,x):
        theF=np.zeros((np.size(x),self.nbspl))
        for i in np.arange(self.nbspl): theF[:,i]=self.get_spline_tofit(self.xspl,i,x)
        return(dot(theF,self.alpha))

    def with_alpha(self,x,alpha):
        theF=np.zeros((np.size(x),self.nbspl))
        for i in np.arange(self.nbspl): theF[:,i]=self.get_spline_tofit(self.xspl,i,x)
        return(dot(theF,alpha))
            
    def get_spline_tofit(self,xspline,index,xx):
        yspline=zeros(np.size(xspline))
        yspline[index]=1.
        tck=interpolate.splrep(xspline,yspline)
        yy=interpolate.splev(xx,tck,der=0)
        return(yy)

```

```{python}
nbspl = 30
valid = wav > 0
myspl = MySplineFitting(freqs[valid], np.log10(wav[valid]), np.sqrt(1./varav[valid]), nbspl)

xxx = np.linspace(110,190, 1000)

errorbar(freqs, wav, yerr=np.sqrt(1./varav), fmt='r.', label='Weighted Average ({}) + Analytical errors'.format(np.sum(ok)))
yscale('log')
plot(xxx, 10**myspl(xxx), label='Spline Fitting')
legend()

chi2 = np.sum(  ((wav-10**myspl(freqs))/np.sqrt(1./varav))**2)
ndf = len(wav)- nbspl
print(chi2, ndf, chi2/ndf)

```

# with an MC

```{python}
xxx = np.linspace(110,190, 1000)

errors = np.sqrt(1./varav)
nbspl = 30

nbmc = 1000
allspl = np.zeros((nbmc, len(xxx)))
for i in range(nbmc):
    thisy = wav + np.random.randn(len(errors))*errors
    valid = thisy > 0
    myspl = MySplineFitting(freqs[valid], np.log10(thisy[valid]), errors[valid], nbspl)
    allspl[i,:] = 10**myspl(xxx)
```

```{python}
errorbar(freqs, wav, yerr=np.sqrt(1./varav), fmt='r.', label='Weighted Average ({}) + Analytical errors'.format(np.sum(ok)))
yscale('log')
for i in range(nbmc):
    plot(xxx, allspl[i,:], alpha=0.01)
legend()
ylim(1e-3, 2)
```

```{python}
errorbar(freqs, wav, yerr=np.sqrt(1./varav), fmt='r.', label='Weighted Average ({}) + Analytical errors'.format(np.sum(ok)))
mspl = np.mean(allspl, axis=0)
sspl = np.std(allspl, axis=0)
plot(xxx, mspl)
fill_between(xxx, mspl+2*sspl, y2=mspl-2*sspl, alpha=0.5)
yscale('log')
```

```{python}
sig_corrected = wav.copy()
errors = np.sqrt(1./varav)

smooth_size = 8
sig_corrected_smoothed = np.convolve(sig_corrected, np.ones(smooth_size)/smooth_size, mode='same')


nbmc = 1000
ally = np.zeros((nbmc, len(sig_corrected)))
for i in range(nbmc):
    thisy = sig_corrected + np.random.randn(len(errors))*errors
    ally[i,:] = np.convolve(thisy, np.ones(smooth_size)/smooth_size, mode='same')
    
errorbar(freqs, sig_corrected_smoothed, yerr=np.std(ally, axis=0), fmt='r.')
yscale('log')
ylim(1e-2, 2)
```

```{python}
vals = linspace(1,1.99,10)
nn = len(vals)
thecol = (arange(nn)*256/(nn-1)).astype(int)

xxx = linspace(0,4,100)
for i in range(len(vals)):
    plot(xxx, xxx**vals[i], color=get_cmap(rcParams['image.cmap'])(thecol[i]))
xlim(0,1)
ylim(0,1)
scatter(-vals*0-10, -vals*0-10,c=vals)
aa=colorbar()
aa.ax.set_ylabel('toto')
```

```{python}

```
