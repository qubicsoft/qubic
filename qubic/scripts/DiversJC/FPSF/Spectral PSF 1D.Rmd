---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.5.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# 1D study of the spectral PSF
This follows an old idea from Ted Bunn: measuring the spectral PSF analytically from the shape of the synthesized beam. This relies on a technique detailed in Bolton and Schlegel 2009 https://arxiv.org/pdf/0911.2689.pdf

We do here a first trial with 1D synthesized beam, the generalization to 2D should be trivial.

<!-- #region -->
## Method
Let's Assume we have a TOD $\vec{d}$ and a multichroic synthesized beam operator $A$ (which actually is a sum of monochromatic synthesized beams). The spectrum of the sky is $\vec{f}$. The data model is:
$$\vec{d} = A\cdot \vec{f}+\vec{n}$$
where $N$ is the TOD noise covariance matrix, which we will assume equal to identity in the following (white noise of RMS 1).

It is important to remark here that $A$ contains the full synthesized beam in this case, not only Dirac peaks at the location of the peaks in the real SB (the usual peak approximation we use for the usual map-making). 

The maximum likelihood solution for the spectrum writes:
$$\vec{f} = (A^t\cdot  N^{-1}\cdot  A)^{-1}\cdot  A^t\cdot  N^{-1}\cdot \vec{d}$$
and the covariance matrix for the reconstructed spectrum is:
$$C=(A^t\cdot  N^{-1}\cdot  A)^{-1}$$

Because of the remark above, the reconstructed spectra is deconvolved from the spectral resolution. The covariance matrix is a dense one meaning that our reconstructed spectra elements are not statistically independent.

Here we want to calculate the spectral resolution that we would have in our spectrum if it had not been deconvolved, although reconstructed. This is the spectral resolution we have when we perform map-making in the peak approximmation.

The statistical correlation between our spectrum sample come from this deconvolution, so we want to find the basis in which the covariance matrix is diagonal. The rotation operators from the deconvolved basis to that one will precisely be the convolution operator in spectral domain we are seeking.


By construction, the inverse of the covariance writes:
$$C^{-1}=A^t\cdot  N^{-1}\cdot  A$$
and because $N$ is equal to identity (scaling with a non-unity RMS is trivial):
$$C^{-1}=A^t\cdot  A$$
As said before, this matrix is dense, and being the inverse of a covariance matrix it is necessarily symmetric and band diagonal, and all its entries are non-negative. We can therefore take its unique square-root $Q$ such as:
$$C^{-1}=Q\cdot Q$$
Now we define a normalization vector $s$ through:
$$s_i = \sum_j Q_{ij}$$
and a matrix $R$ through:
$$R_{ij} = s_i^{-1} Q_{ij}~~~~\mathrm{(no~sum)}$$
and then a diagonal matrix $\tilde{C}^{-1}$ with entries given by:
$$\tilde{C}^{-1}_{ii} = s^2_i$$
By construction, we have: $$C^{-1}=R^t\cdot \tilde{C}^{-1}\cdot R$$ 
and consequently:
$$\tilde{C} = R \cdot C \cdot R^t$$

The matrix $R$ defines a transformation from the deconvolved spectrum to a reconvolved one for which:
- the pixels are statistically independent
- the blurring is statistically equivalent to the physical one
We can therefore get the 1D spectrum as:
$$\tilde{\vec{f}} = R \cdot \vec{f}$$
And more conveniently in our case, if we set all elements of $\vec{f}$ (the deconvolved "true" spectrum) to zero excpet a single one to 1, we get the Frequency PSF (FPSF) of our instrument at the frequency of the non-zero element.
<!-- #endregion -->

## Synthesized beam as a function of frequency:

```{python}
rc('figure',figsize=(16,6))
rc('font',size=12)

sqnh = 20

### Theta range
nth = 1000
thmax = 25.
th = np.linspace(-thmax, thmax, nth)

def get_primbeam(th, lam, fwhmprimbeam_150=14.):
    fwhmprim = 14. * lam / (3e8/150e9)
    primbeam = np.exp(-0.5 * th**2 / (fwhmprim/2.35)**2)
    return primbeam

def give_sbcut(th, nu, dx=13.*1e-3, sqnh=20, Df=1., detpos=0., fwhmprimbeam_150=14.):
    #filter_range = np.array([131.25, 168.75])
    filter_range = np.array([0, 1e8])
    if (nu<filter_range[0]) or (nu>filter_range[1]):
        return th*0
    else:
        lam = 3e8/(nu*1e9)
        primbeam =  get_primbeam(th, lam, fwhmprimbeam_150=fwhmprimbeam_150)
        theth = th - np.degrees(detpos/Df)
        sb = np.sin(sqnh * np.pi * dx / lam * np.radians(theth))**2 / np.sin(np.pi * dx / lam * np.radians(theth))**2
        return sb/np.max(sb)*primbeam

plot(th,give_sbcut(th, 135, sqnh=sqnh), label='135 GHz')
plot(th,give_sbcut(th, 150, sqnh=sqnh), label='150 GHz')
plot(th,give_sbcut(th, 165, sqnh=sqnh), label='165 GHz')
legend()
```

## Let's now calculate the inverse covariance matrix $B=C^{-1}$

```{python}
dnu_nu = 0.9
nu0 = 150.
numin = nu0*(1-dnu_nu/2)
numax = nu0*(1+dnu_nu/2)
print(numin,numax)
nnu = 301
nus = np.linspace(numin, numax, nnu)

bmat = np.zeros((nnu, nnu))
for i in range(nnu):
    if (i%10)==0: print(i)
    for j in range(i, nnu):
        bmat[i,j] = np.sum(give_sbcut(th, nus[i], sqnh=sqnh) * give_sbcut(th, nus[j], sqnh=sqnh))
        bmat[j,i] = bmat[i,j]
```

```{python}
imshow(bmat, origin='upper', extent=[numin, numax, numax, numin])
xlabel('Frequency (GHz)')
ylabel('Frequency (GHz)')
colorbar()
title('$C^{-1} = A^t\cdot A$')
```

This matrix is the inverse of the ($\nu$,$\nu$) covariance matrix. Following [Bolton and Schlegel, 2009], we can take the square-root of this matrix:
$$B=C^{-1}=Q\cdot Q$$

```{python}
rc('figure',figsize=(16,4))
rc('font',size=12)

import scipy.linalg
Q = scipy.linalg.sqrtm(bmat, disp=True).real
subplot(1,4,1)
imshow(bmat, origin='upper', extent=[numin, numax, numax, numin])
title('B')
colorbar()

subplot(1,4,2)
imshow(Q, origin='upper', extent=[numin, numax, numax, numin])
title('Q such as B=Q.Q')
colorbar()

subplot(1,4,3)
imshow(np.dot(Q,Q), origin='upper', extent=[numin, numax, numax, numin])
title('Q.Q')
colorbar()

subplot(1,4,4)
imshow(bmat-np.dot(Q,Q), origin='upper', extent=[numin, numax, numax, numin])
title('B-Q.Q')
colorbar()


```

And we now calculate the $R$ matrix that does the transformation from the deconvolved spectrum to the reconvolved one (meaning that this is the spectral convolution operator). 

We also apply it to a "deconvolved" spectrum with all zeros but a single 1 at 150 GHz and we get the spectral response of the isntrment at 150 GHz: our FPSF.

```{python}
rc('figure',figsize=(8,4))
rc('font',size=12)
si = np.sum(Q, axis=1)
R = np.zeros_like(Q)
for i in range(nnu):
    R[i,:] = Q[i,:] / si[i]
Ctilde_inv = np.diag(1./si**2)

ftest = np.zeros(nnu)
ftest[nnu//2] = 1
plot(nus, np.dot(R, ftest))
xlabel('Frequency [GHz]')
ylabel('FPSF')
```

Let's remove the offset and compare to the "Rayleigh" spectral resolution.

```{python}
rc('figure',figsize=(8,4))
rc('font',size=12)

truc = np.dot(R, ftest)
ok = isfinite(truc)

FPSF = np.zeros_like(nus)
FPSF[ok] = truc[ok] - np.median(truc[ok])
FPSF /= np.max(FPSF)
bla = FPSF >= 0.5
fwhm = max(nus[bla])-min(nus[bla])


thwidth = nu0/(sqnh-1)/2.35
print(thwidth)

plot(nus, FPSF, label='Analytical FPSF (1D) - $\sigma_{eff}$='+'{:3.1f} GHz'.format(fwhm/2.35))
plot(nus, np.exp(-(nus-nu0)**2/(2*thwidth**2)), 
     label='Rayleigh sqnh={}'.format(sqnh)+' - $\sigma_{rayleigh}$'+'={:3.1f} GHz'.format(thwidth))
legend(loc='upper right', fontsize=10)
xlim(130, 170)
xlabel('Frequency [GHz]')
ylabel('FPSF')
title('SQNH={}'.format(sqnh))
```

To do:
- restrict the frequency domain to our band by setting to zero beyond ?
- where does the offset come from, what meaning ?


# Next step: 2D with healpix maps

```{python}

```
