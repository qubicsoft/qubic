---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
# %matplotlib inline
from pylab import *
import os
import sys
from importlib import reload
import glob
import pickle

# Specific science modules
import healpy as hp
import numpy as np

# Specific qubic modules
from qubicpack.utilities import Qubic_DataDir
from pysimulators import FitsArray
import pysm
import qubic
from qubic import SpectroImLib as si
from qubic import QubicSkySim as qss
from qubic import NamasterLib as nam
from qubic import camb_interface as qc
from qubic import fibtools as ft


rc('figure', figsize=(13, 10))
rc('font', size=12)
```

```{python}
#### This function reads the maps
def read_files_mc(dirmaps,reconfile, verbose=False):
    ##kk = reconfile.split('/')[-1].split('_')[0]
    bla = reconfile.split('/')[-1].split('_')
    kk = bla[0]+'_'+bla[1]+'_'+bla[2]
    print(kk)
    ss = reconfile.split('/')[-1].split('_')[-2]
    rr = reconfile.split('/')[-1].split('_')[-1].split('.')[0]
    m = np.array(FitsArray(dirmaps+kk+'_maps_recon_seed_'+ss+'_'+rr+'.fits'))
    c = np.array(FitsArray(dirmaps+kk+'_maps_convolved_seed_'+ss+'_'+rr+'.fits'))
    cov = np.array(FitsArray(dirmaps+kk+'_maps_coverage_'+rr+'.fits'))
    with open(dirmaps+kk+'_dictionary_'+rr+'.pickle', 'rb') as handle: d = pickle.load(handle)
    with open(dirmaps+kk+'_input_cell_'+rr+'.pickle', 'rb') as handle: icl = pickle.load(handle)
    if verbose: print('read k={} s={} r={}'.format(kk, ss, rr))
    return m, c, cov, d, icl
    

```

```{python}
dirbase = '/Users/hamilton/Qubic/QubicGeneralPaper2020/Sims/SimsPureCMB/'
dirmaps = dirbase+'Maps/'
listinit = glob.glob(dirmaps+'*maps_recon*.fits')
allstr = []
allkeyword = []
allseed = []
for l in listinit:
    bla= l.split('.')[0].split('_')
    kk = bla[0].split('/')[-1]+'_'+bla[1]+'_'+bla[2]
    allkeyword.append(kk)
    allstr.append(bla[-1])
    allseed.append(bla[-2])

allstr = unique(np.array(allstr))

mykeywords = np.unique(allkeyword)
myseeds = np.unique(allseed)

print('Keywords Available:')
for k in range(len(mykeywords)):
    print('{}: '.format(k)+mykeywords[k])
print('')
print('Seeds Available:')
for s in range(len(myseeds)):
    print('{}: '.format(s)+myseeds[s])

print('')
print('Choose a keword and a seed index below')
```

```{python}
kindex = 3
sindex = 0

### Get corresponding files:
kk = mykeywords[kindex]
ss = myseeds[sindex]
listfiles = glob.glob(dirmaps+kk+'*maps_recon_seed_'+ss+'*.fits')
### Order files by date and time
listfiles.sort(key=os.path.getmtime)
#for f in listfiles: print(f)



print('For Keyword {} and seed {}:'.format(kk, ss))
print('There are {} realizations available'.format(len(listfiles)))
print('Choose below which realization you want to look')
```

```{python}
numsim = 0

m, c, cov, d, icl = read_files_mc(dirmaps, listfiles[numsim], verbose=True)

### Center of the QUBIC Field
center = qubic.equ2gal(d['RA_center'], d['DEC_center'])

### Input Th Spectra
input_cell = icl.copy()
ellth= np.arange(icl.shape[0])

### Check the coverages
figure()
hp.gnomview(cov, rot=center, reso=15, title='Coverage 0', sub=(1,3,1))

### Check convolved maps
figure()
stn = ['I', 'Q', 'U']
for s in range(3):
    hp.gnomview(c[0,:,s], rot=center, reso=15, title='Convolved '+stn[s], sub=(3,3,1+s))    
    
### Check Reconstructed maps
figure()
stn = ['I', 'Q', 'U']
for s in range(3):
    hp.gnomview(m[0,:,s], rot=center, reso=15, title='Reconstructed '+stn[s], sub=(3,3,1+s))    

```

```{python}
seenpix = cov > (0.1*np.max(cov))

covnorm = cov / np.max(cov)

nbins = 30
xx, yyI, dx, dyI, _ = ft.profile(np.sqrt(1./covnorm[seenpix]), m[0,seenpix,0]-c[0,seenpix,0], nbins=nbins, plot=False)
xx, yyQ, dx, dyQ, _ = ft.profile(np.sqrt(1./covnorm[seenpix]), m[0,seenpix,1]-c[0,seenpix,1], nbins=nbins, plot=False)
xx, yyU, dx, dyU, _ = ft.profile(np.sqrt(1./covnorm[seenpix]), m[0,seenpix,2]-c[0,seenpix,2], nbins=nbins, plot=False)
plot(xx,dyI, label='QUBIC MC I')
plot(xx,dyQ/np.sqrt(2), label='QUBIC MC Q/sqrt(2)')
plot(xx,dyU/np.sqrt(2), label='QUBIC MC U/sqrt(2)')
xlabel('1./sqrt(cov normed)')
ylabel('RMS Noise per pixel')

sigma_sec = 70
seed = None
sky_config = {'cmb': seed}
Qubic_sky = qss.Qubic_sky(sky_config, d)
fakemaps = Qubic_sky.create_noise_maps(sigma_sec, cov)

xx, yyIF, dx, dyIF, _ = ft.profile(np.sqrt(1./covnorm[seenpix]), fakemaps[seenpix,0], nbins=nbins, plot=False)
xx, yyQF, dx, dyQF, _ = ft.profile(np.sqrt(1./covnorm[seenpix]), fakemaps[seenpix,1], nbins=nbins, plot=False)
xx, yyUF, dx, dyUF, _ = ft.profile(np.sqrt(1./covnorm[seenpix]), fakemaps[seenpix,2], nbins=nbins, plot=False)
plot(xx,dyIF, ':', label='I: Expected from coverage')
plot(xx,dyQF/np.sqrt(2), ':', label='Q/sqrt(2): Expected from coverage')
plot(xx,dyUF/np.sqrt(2), ':', label='U/sqrt(2): Expected from coverage')
title(kk)
ylim(0,10)
legend()


```

```{python}

```
