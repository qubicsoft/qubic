---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Covariances at Cls level

First we compute the covariances matrices. Then we recombined the subbands the same way as we do at the map level

```{python}
# %matplotlib inline

import glob
import pickle
import numpy as np
import matplotlib.pyplot as plt
from itertools import combinations, combinations_with_replacement

# Specific qubic modules
import qubic
from qubic.polyacquisition import compute_freq
import AnalysisMC as amc
from qubic import NamasterLib as nam

rc('figure', figsize=(13, 10))
rc('font', size=15)

```

```{python}
import matplotlib.colors as mcolors

colorlist = list(mcolors.TABLEAU_COLORS.keys())
```

## Get the cross spectra

We can choose: 
- cross spectra from full pipeline simu (small number of realisations ~30)
- cross spectra from Fast Simulators (lots of realisation ~1500)

In both cases, they are cross spectra on residuals so they should be 0.


```{python}
rep_fullpipe = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/cls_spectrum_fullpipelinesimu/'
rep_spectrumCC = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/cls_spectrum_fromCC/'
```

```{python}
# Convert all files to one .npy

# for nfrecon in [1, 2, 3, 4, 5, 8]:
#     list_files = glob.glob(rep_spectrumCC + 'spectrum*mix*nfrecon{}*.npy'.format(nfrecon))
#     nfiles = len(list_files)
#     print('# Files:', nfiles)
#     for i in range(nfiles):
#         cross = np.load(list_files[i])
# #         with open(list_files[i], 'rb') as f:
# #             cross = pickle.load(f)

#         if i == 0:
#             allcross = cross
#         else:
#             allcross = np.concatenate((allcross, cross), axis=0)
#     print('All cross shape:', allcross.shape)
#     np.save(rep_spectrumCC + 'spectrum_mixreal_nfrecon{}.npy'.format(nfrecon), allcross)
```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']
nfrecon = 3
# cls_cross = np.load(rep_spectrumCC + 'cross_nfrecon{}.npy'.format(nfrecon))
# cls_cross = np.load(rep_fullpipe + 'cross_residuals_nfrecon{}.npy'.format(nfrecon))
cls_cross = np.load(rep_spectrumCC + f'spectrum_mixreal_nfrecon{nfrecon}.npy')
print(cls_cross.shape)

nreals = cls_cross.shape[0]
nbins = cls_cross.shape[2]

print('# realisations:', nreals)
print('# bins:', nbins)
```

```{python}
combi1 = [(i, i) for i in range(nfrecon)]
combi2 = list(combinations(np.arange(nfrecon), 2))
combi = combi1 + combi2

print(combi)
ncombi = len(combi)
```

```{python}
# Plot one spectrum and the mean (just to see)
# Create a Namaster object
nside = 256
lmin = 40
lmax = 2 * nside - 1
delta_ell = 30
print('lmin', lmin)
print('lmax', lmax)
print('delta ell', delta_ell)

mask = np.zeros(12 * nside**2)

Namaster = nam.Namaster(mask, lmin=lmin, lmax=lmax, delta_ell=delta_ell)

# Binning
ell_binned, b = Namaster.get_binning(nside)
nbins = len(ell_binned)
print('nbins:', nbins)
print('ell binned:', ell_binned)

cross_mean_residuals = np.mean(cls_cross, axis=0)
cross_std_residuals = np.std(cls_cross, axis=0)


clnames = ['TT', 'EE', 'BB', 'TE']
rc('figure', figsize=(12, 8))

# fig, axs = plt.subplots(2, 2)
# axs = axs.ravel()

# for i in range(4):
#     ax = axs[i]
#     for cross in range(ncombi):
#         c = colorlist[cross]
#         ax.plot(ell_binned[:], 
#                 cls_cross[0, cross, :, i],
#                 color=colorlist[cross], 
#                 label='band {}'.format(combi[cross]))

#     ax.set_xlabel('$\\ell$')
#     ax.set_ylabel('$D_\\ell$')
# #     ax.set_yscale('log')
#     ax.set_title(clnames[i])
#     ax.legend(fontsize=8, loc='upper left')

# plt.tight_layout()

fig, axs = plt.subplots(2, 2)
axs = axs.ravel()

for i in range(4):
    ax = axs[i]
    for cross in range(ncombi):
        c = colorlist[cross]
        ax.errorbar(ell_binned[:], 
                cross_mean_residuals[cross, :, i],
                yerr=cross_std_residuals[cross, :, i] * np.sqrt(2),
                marker='o', color=colorlist[cross], linestyle='none', 
                label='band {}'.format(combi[cross]))

    ax.set_xlabel('$\\ell$')
    ax.set_ylabel('$D_\\ell$')
#     ax.set_yscale('log')
    ax.set_title(clnames[i])
    ax.legend(fontsize=8, loc='upper left')

plt.tight_layout()


```

```{python}
cls_cross.shape
```

```{python}
b = 7
s = 0
plt.scatter(cls_cross[:, 3, b, s], cls_cross[:, 4, b, s])
pval = np.polyfit(cls_cross[:, 3, b, s], cls_cross[:, 4, b, s], deg=1)
print(pval)
x = np.linspace(np.min(cls_cross[:, 3, b, s]), np.max(cls_cross[:, 3, b, s]), 10)
plt.plot(x, np.polyval(pval, x))
plt.title(f'{clnames[s]} - bin {b}')
plt.xlabel('Freq 0')
plt.ylabel('Freq 1')
```

## Get Cp

For each bin, each spectrum (TT, EE, BB, TE) we compute the covariance and correlation matrices between bands f0, f1, f2...

```{python}
Cp = amc.get_Cp(cls_cross, verbose=False)
print('Cp shape:', Cp.shape)

Cpcorr = np.zeros_like(Cp)
for b in range(nbins):
    for s in range(4):
        Cpcorr[:, :, s, b] = amc.cov2corr(Cp[:, :, s, b])
```

```{python}
labs = []
for i in range(ncombi):
    labs.append(f'{combi[i][0]}{combi[i][1]}')
print(labs)

plt.figure(figsize=(20, 100))
for b in range(nbins):
    for s in range(4):
        plt.subplot(nbins, 4, 4*b + s + 1)
        vmax = np.max(np.abs(Cp[:, :, s, b]))
        plt.imshow(Cp[:, :, s, b], vmin=-vmax, vmax=vmax, cmap='bwr')
        plt.title('Cov - ' + clnames[s] + ' - bin {}'.format(b))
        plt.colorbar(orientation='horizontal', fraction=0.2)
        plt.xticks(np.arange(len(labs)), labs)
        plt.yticks(np.arange(len(labs)), labs)

        
```

```{python}
plt.figure(figsize=(20, 100))
for b in range(nbins):
    for s in range(4):
        plt.subplot(nbins, 4, 4*b + s + 1)
        plt.imshow(Cpcorr[:, :, s, b], vmin=-1, vmax=1, cmap='bwr')
        plt.title('Corr - ' + clnames[s] + ' - bin {}'.format(b))
        plt.colorbar(orientation='horizontal', fraction=0.2)
        plt.xticks(np.arange(len(labs)), labs)
        plt.yticks(np.arange(len(labs)), labs)
        
  
```

```{python}
Cpcorr_avg = np.mean(Cpcorr, axis=3)
plt.figure(figsize=(15, 5))

for s in range(4):
    plt.subplot(1, 4, s + 1)
    plt.imshow(Cpcorr_avg[:, :, s], vmin=-1, vmax=1, cmap='bwr')
    plt.title(' Corr avg - ' + clnames[s])
    plt.colorbar(orientation='horizontal', fraction=0.2)
    plt.xticks(np.arange(len(labs)), labs)
    plt.yticks(np.arange(len(labs)), labs)

```

### Go to Cp_prime

Not sure it is useful because if we have many realisations (easy with Fast Simulator), we can use directly Cp to average the subbands. 

```{python}
# Cp_prime over bins (normalisation by the first term)
N00, Cp_prime00 = amc.Cp2Cp_prime(Cp, verbose=True)

# bin:
b = 10

plt.figure(figsize=(15, 10))
for s in range(4):
    plt.subplot(1, 4, s+1)
    vmax = np.max(np.abs(Cp_prime00[:, :, s, b]))
    plt.imshow(Cp_prime00[:, :, s, b], vmin=-vmax, vmax=vmax, cmap='bwr')
    plt.title(clnames[s] + ' - bin {}'.format(b))
    plt.colorbar(orientation='horizontal', fraction=0.1)
    plt.xticks(np.arange(len(labs)), labs)
    plt.yticks(np.arange(len(labs)), labs)

 
```

```{python}
# Cp_prime over bins (normalisation by the diagonal)
N, Cp_prime = amc.Cp2Cp_prime_viaCorr(Cp, verbose=True)

b = 10

plt.figure(figsize=(15, 10))
for s in range(4):
    plt.subplot(1, 4, s+1)
    vmax = np.max(np.abs(Cp_prime[:, :, s, b]))
    plt.imshow(Cp_prime[:, :, s, b], vmin=-vmax, vmax=vmax, cmap='bwr')
    plt.title(clnames[s] + f' - bin {b}')
    plt.colorbar(orientation='horizontal', fraction=0.1)
    plt.xticks(np.arange(len(labs)), labs)
    plt.yticks(np.arange(len(labs)), labs)
 
```

### Big covariance matrix mixing TT, EE, BB, TE 

Instead of looking at correlations in TT, EE, BB, TE separetely, we also compute correlations between the 4 spectra. 

But we see that they are very small.

```{python}
bigcov, bigcorr = amc.get_covcorr_patch(cls_cross, stokesjoint=True, doplot=False)
print(bigcov.shape)
```

```{python}
labs = []
for s in range(4):
    for i in range(ncombi):
        labs.append(clnames[s] + f'{combi[i][0]}{combi[i][1]}')
        
print(labs)
```

```{python}
plt.figure(figsize=(20, 200))
for b in range(nbins):
    
    plt.subplot(nbins, 2, b*2 +1)
    vmax = np.max(np.abs(bigcov[:, :, b]))
    plt.imshow(bigcov[:, :, b], vmin=-vmax, vmax=vmax, cmap='bwr')
    plt.xticks(np.arange(len(labs)), labs, fontsize=7)
    plt.yticks(np.arange(len(labs)), labs, fontsize=7)
    for s in range(nfrecon):
        plt.axhline(y=(s+1)*ncombi-0.5, lw=3, color='k')
        plt.axvline(x=(s+1)*ncombi-0.5, lw=3, color='k')
    plt.title('Covariance - bin {}'.format(b))
    plt.colorbar(orientation='horizontal')
    
    plt.subplot(nbins, 2, b*2 +2)
    plt.imshow(bigcorr[:, :, b], vmin=-1, vmax=1, cmap='bwr')
    plt.xticks(np.arange(len(labs)), labs, fontsize=9)
    plt.yticks(np.arange(len(labs)), labs, fontsize=9)
    for s in range(nfrecon):
        plt.axhline(y=(s+1)*ncombi-0.5, lw=3, color='k')
        plt.axvline(x=(s+1)*ncombi-0.5, lw=3, color='k')
    plt.title('Correlation - bin {}'.format(b))
    plt.colorbar(orientation='horizontal')
```

```{python}
plt.figure(figsize=(15, 15))
plt.imshow(np.mean(bigcorr, axis=2), vmin=-1, vmax=1, cmap='bwr')
plt.title('Correlation matrice averaged over bins')
plt.colorbar(orientation='horizontal')

plt.xticks(np.arange(len(labs)), labs, fontsize=8)
plt.yticks(np.arange(len(labs)), labs, fontsize=8)

for s in range(nfrecon):
    plt.axhline(y=(s+1)*ncombi-0.5, lw=3, color='k')
    plt.axvline(x=(s+1)*ncombi-0.5, lw=3, color='k')

```

## Covariance matrix between bins

Now for each spectrum TT, EE, BB and TE, we compute the covariance matric between bins and subbands. 

This matrix has a shape of (nbins x nfrecon) x (nbins x nfrecon)

```{python}
# We have to reshape cls_cross as (nreals, nbins, 4, nfrecon)
print('Old shape:', cls_cross.shape)
cls_cross_reshape = np.moveaxis(cls_cross, [1, 2, 3], [3, 1, 2])
print('New shape:', cls_cross_reshape.shape)
```

```{python}
covbinband, corrbinband = amc.get_covcorr_patch(cls_cross_reshape, stokesjoint=True, doplot=False)

print(nbins)
print(covbinband.shape)
```

```{python}
rep_spectrumCC
```

```{python}
# Get matrices and save them for all nfrecon
# allnfrecon = [1, 2, 3, 4, 5, 8]
# for nf in allnfrecon:
#     cls_cross = np.load(rep_spectrumCC + 'spectrum_mixreal_nfrecon{}.npy'.format(nf))
#     print(cls_cross.shape)
#     cls_cross_reshape = np.moveaxis(cls_cross, [1, 2, 3], [3, 1, 2])
#     covbinband, corrbinband = amc.get_covcorr_patch(cls_cross_reshape, stokesjoint=True, doplot=False)
#     print(covbinband[:, :, 2].shape)
#     np.save(rep_spectrumCC + 'BBcovariance_bincross_nfrecon{}_mixreal.npy'.format(nf), covbinband[:, :, 2])
#     np.save(rep_spectrumCC + 'BBcorrelation_bincross_nfrecon{}_mixreal.npy'.format(nf), corrbinband[:, :, 2])
```

```{python}
# Load matrice already saved
# nfrecon = 3
# covbinband = np.load(rep_spectrumCC + 'covariance_binfrec_nfrecon{}.npy'.format(nfrecon))
# corrbinband = np.load(rep_spectrumCC + 'correlation_binfrec_nfrecon{}.npy'.format(nfrecon))
```

```{python}
labsx,labsy = [], []
for i in range(ncombi):
    labsx.append(f'{combi[i][0]}{combi[i][1]}b0')
    for s in range(nbins):
        labsy.append(f'{combi[i][0]}{combi[i][1]}b{s}')
        
print(labsy)

labs = []
for i in range(ncombi):
    labs.append(f'Cross {combi[i][0]}{combi[i][1]}')
```

```{python}
ispectre = 2

plt.figure(figsize=(20, 20))
plt.yticks(np.arange(8, nbins*ncombi, nbins), labs, fontsize=20)
plt.xticks(np.arange(8, nbins*ncombi, nbins), labs, fontsize=20)

for s in range(ncombi-1):
    plt.axhline(y=(s+1)*nbins-0.5, lw=3, color='k')
    plt.axvline(x=(s+1)*nbins-0.5, lw=3, color='k')
vmax = np.max(np.abs(covbinband[:, :, ispectre]))
plt.imshow(covbinband[:, :, ispectre], vmin=-vmax, vmax=vmax, cmap='bwr')
plt.title('Covariance matrix (nfreq*nbins)x(nfreq*nbins) for {} spectrum'.format(clnames[ispectre]), 
         fontsize=20)
plt.colorbar()
```

```{python}
plt.figure(figsize=(20, 20))
plt.yticks(np.arange(8, nbins*ncombi, nbins), labs, fontsize=20)
plt.xticks(np.arange(8, nbins*ncombi, nbins), labs, fontsize=20)


for s in range(ncombi-1):
    plt.axhline(y=(s+1)*nbins-0.5, lw=3, color='k')
    plt.axvline(x=(s+1)*nbins-0.5, lw=3, color='k')

plt.imshow(corrbinband[:, :, ispectre], vmin=-1, vmax=1, cmap='bwr')
plt.title('Correlation matrix (nfreq*nbins)x(nfreq*nbins) for {} spectrum'.format(clnames[ispectre]),
         fontsize=20)
plt.colorbar()
```

```{python}
# Plot the max of the covariance matrix vs nfrecon
# Not sure it makes sens
covmax = np.zeros((len(allrecon), 4))
for i, nfrecon in enumerate(allrecon):
    print(i, nfrecon)
    covbinband = np.load(rep_spectrumCC + 'covariance_binfrec_nfrecon{}.npy'.format(nfrecon))
    print(covbinband.shape)
    print(np.max(covbinband))
    covmax[i, :] = np.max(covbinband, axis=(0, 1))
#     covmax[i, :] = covbinband[0, 0, :]

plt.figure(figsize=(12, 12))    
for s in range(4):
    plt.plot(allrecon[:], covmax[:, s]/covmax[0, s], 'o', label='{}'.format(clnames[s]))
plt.legend()
plt.axhline(y=1, color='k', ls='--')
```

## Weighted average of the subbands

The 3 methods (directly with Cp, with Cp_prime00 or with Cp_prime) give the same.

However, I don't get why the average band has this behaviour with bin...

```{python}
cls_cross.shape
```

```{python}
# Using Cp directly
avg, sig2 = amc.make_weighted_av(cls_cross, Cp, verbose=False)
sig2MC = np.var(avg, axis=0)

# Using Cp_prime 00
avg00, sig200 = amc.make_weighted_av(cls_cross, Cp_prime00, verbose=False)
sig2MC00 = np.var(avg00, axis=0)

# Using Cp_prime
avg_prime, sig2_prime = amc.make_weighted_av(cls_cross, Cp_prime, verbose=False)
sig2MC_prime = np.var(avg_prime, axis=0)
```

```{python}
avg.shape
sig2.shape
```

```{python}
plt.figure(figsize=(10, 10))
s = 0
# for s in range(4):
plt.plot(sig2[:, s], color=colorlist[s], label='$\sigma^2$ {}'.format(clnames[s]))
plt.plot(sig200[:, s], color=colorlist[s+1], label='$\sigma^2$ 00 {}'.format(clnames[s]))
plt.plot(sig2_prime[:, s], color=colorlist[s+2], label='$\sigma^2$ prime {}'.format(clnames[s]))

plt.plot(sig2MC[:, s], 'o',color=colorlist[s], label='$\sigma^2$ MC {}'.format(clnames[s]))
plt.plot(sig2MC00[:, s], 'o', color=colorlist[s+1], label='$\sigma^2$ MC 00 {}'.format(clnames[s]))
plt.plot(sig2MC_prime[:, s], 'o', color=colorlist[s+2], label='$\sigma^2$ MC prime {}'.format(clnames[s]))
plt.legend()
plt.title('{} bands map recombined in 1 band for {}'.format(nfrecon, clnames[s]))
plt.xlabel('bin')
plt.ylabel('$\sigma^2$')
```

```{python}
plt.figure(figsize=(10, 10))
s = 2
# for s in range(4):
plt.plot(ell_binned, np.sqrt(sig2[:, s]), color=colorlist[s], label='$\sigma$ {}'.format(clnames[s]))
plt.plot(ell_binned, np.sqrt(sig200[:, s]), color=colorlist[s+1], label='$\sigma$ 00 {}'.format(clnames[s]))
plt.plot(ell_binned, np.sqrt(sig2_prime[:, s]), color=colorlist[s+2], label='$\sigma$ prime {}'.format(clnames[s]))

plt.plot(ell_binned, np.sqrt(sig2MC[:, s]), 'o',color=colorlist[s], label='$\sigma$ MC {}'.format(clnames[s]))
plt.plot(ell_binned, np.sqrt(sig2MC00[:, s]), 'o', color=colorlist[s+1], label='$\sigma$ MC 00 {}'.format(clnames[s]))
plt.plot(ell_binned, np.sqrt(sig2MC_prime[:, s]), 'o', color=colorlist[s+2], label='$\sigma$ MC prime {}'.format(clnames[s]))
plt.legend()
plt.title('{} bands map recombined in 1 band for {}'.format(nfrecon, clnames[s]))
plt.xlabel('$l$')
plt.ylabel('$\sigma$')
```

### Loop over nfrecon to get the recombined spectrum in each case

We will only do with Cp.

```{python}
allrecon = [1, 2, 3, 4, 5, 8]
allsig2 = np.zeros((len(allrecon), nbins, 4))
allsig2MC = np.zeros_like(allsig2)
for i, nfrecon in enumerate(allrecon):
    print('\n nfrecon:', nfrecon)
    cls_cross = np.load(rep_spectrumCC + 'cross_nfrecon{}.npy'.format(nfrecon))
    print(cls_cross.shape)

    nreals = cls_cross.shape[0]
    nbins = cls_cross.shape[2]

    print('# realisations:', nreals)
    print('# bins:', nbins)
    
    Cp = amc.get_Cp(cls_cross, verbose=False)
    Cp_check = np.zeros_like(Cp)
    for s in range(4):
        for b in range(nbins):
            Cp_check[:, :, s, b] = Cp[:, :, s, b]
    
    avg, allsig2[i, :, :] = amc.make_weighted_av(cls_cross, Cp_check, verbose=False)
    allsig2MC[i, :, :] = np.var(avg, axis=0)
  
    
```

```{python}
# Normalize by the case of 1 band
sig2norm = allsig2 / allsig2[0, :, :]
sig2norm.shape

```

```{python}
s = 2
plt.figure(figsize=(10, 10))
for i in range(6):
    plt.plot(ell_binned, np.sqrt(sig2norm[i, :, s]) , label='nfrecon = {}'.format(allrecon[i]))

plt.xlabel('$l$')
plt.ylabel('$\sigma / \sigma_{1 band}$')
plt.title(clnames[s])
plt.legend()
```

```{python}
s = 2
plt.figure(figsize=(10, 10))
for b in range(0, nbins):
    plt.plot(allrecon, np.sqrt(sig2norm[:, b, s] / allrecon), label='bin = {}'.format(b))

plt.xlabel('# bands')
plt.ylabel('$\sigma / \sqrt{N}$')
plt.legend()
```

```{python}
# Average over the bins
sig2normmean = np.mean(sig2norm, axis=1)
print(sig2normmean.shape)

plt.figure(figsize=(10, 10))
for s in range(4):
    plt.plot(allrecon, np.sqrt(sig2normmean[:, s]), label=clnames[s])
plt.plot(allrecon, np.sqrt(allrecon), 'k', label='$\sqrt{N_{bands}}$')

plt.xlabel('# bands')
plt.ylabel('$\sigma / \sigma_{1band}$')
plt.legend()
plt.title('Avg over bins')
```

```{python}
mean = [0, 0]
mycov = [[1, -0.5], [-0.5, 1]]
plt.imshow(mycov)
x = np.random.multivariate_normal(mean, mycov, size=100000)
print(x.shape)

# Check we have the covariance we want
newcov = np.cov(x.T)
print(newcov)

# Look at the covariance of x²
x2 = x**2
newcov2 = np.cov(x2.T)
print(newcov2)
```

```{python}

```
