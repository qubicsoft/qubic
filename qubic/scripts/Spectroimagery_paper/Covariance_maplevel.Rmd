---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Covariances at map level

#### Louise Mousset, 2020/06/05

This notebook is structured in 2 parts:
- get all possible covariance matrices
- recombine the sub-bands in only one

We try to do it using simulations from FastSim and from the full pipeline simulations to compare.  

```{python}
# %matplotlib inline
from pylab import *
import os
import sys
import glob

# Specific science modules
import healpy as hp
import numpy as np
from astropy.io import fits

# Specific qubic modules
from qubicpack.utilities import Qubic_DataDir
from pysimulators import FitsArray
import pysm
import pysm.units as u

import qubic
from qubic import SpectroImLib as si
from qubic import QubicSkySim as qss
from qubic import NamasterLib as nam
import qubic.fibtools as ft
from qubic.polyacquisition import compute_freq

import ReadMC as rmc
import AnalysisMC as amc

rc('figure', figsize=(13, 10))
rc('font', size=15)
```

```{python}
import matplotlib.colors as mcolors
mcolors.TABLEAU_COLORS.keys()

colorlist = list(mcolors.TABLEAU_COLORS.keys())
```

# Get the files

```{python}
rep_mapCC = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/maps_FastSim/'

# rep = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/galaxy_center_d1/test_residuals/31613089/'
# rep = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/29712494/'

# nfrecon = 3
# rep = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/galaxy_center_d1/nfrecon{}/'.format(nfrecon)

```

```{python}
# # For full pipeline simulations
# dictionary = glob.glob(rep + '/*.dict')[0]
# print(dictionary)

# # Dictionary saved during the simulation
# d = qubic.qubicdict.qubicDict()
# d.read_from_file(dictionary)

# # Coordinates of the zone observed in the sky
# center = qubic.equ2gal(d['RA_center'], d['DEC_center'])

# # Number of subbands used during the simulation

# nfsub = d['nf_sub']
# print('nf_sub = {}, nf_recon = {}'.format(nfsub, nfrecon))

# # Get fits files names in a list
# fits_noise = np.sort(glob.glob(rep + '*_nfsub{}_nfrecon{}_noiselessFalse*.fits'.format(nfsub, nfrecon), 
#                               recursive=True))
# fits_noiseless = np.sort(glob.glob(rep + '*_nfsub{}_nfrecon{}_noiselessTrue*.fits'.format(nfsub, nfrecon), 
#                               recursive=True))

# # print(fits_noiseless)

# # Number of noise realisations
# nreals = len(fits_noise)
# print('nreals = ', nreals)

# # Get seen map (observed pixels)
# seenmap = rmc.get_seenmap(fits_noiseless[0])
# print(seenmap.shape)

# # Number of pixels and nside
# npix = len(seenmap)
# ns = d['nside']

# residuals = amc.get_residuals(rep, 'noiseless', nf_sub_rec)
```

```{python}
stokes = ['I', 'Q', 'U']
allrecon = [1, 2, 3, 4, 5, 8]
nfrecon = 3
```

```{python}
files = glob.glob(rep_mapCC + 'patch_clth_nfrecon{}*.npy'.format(nfrecon))
nfiles = len(files)
print('# files:', nfiles)

for i, file in enumerate(files):
    pa = np.load(file)
    if i == 0:
        patch = pa
    else:
        patch = np.concatenate((patch, pa), axis=0)

# Save the full array 
np.save(rep_mapCC + 'patch_clth_nfrecon{}.npy'.format(nfrecon), patch)
```

```{python}
patch.shape
```

```{python}
# Load a file saved with all realisations
nfrecon = 3
patch = np.load(rep_mapCC + 'patch_clth_nfrecon{}.npy'.format(nfrecon))
print('patch shape:', patch.shape)

nreals, _, npix, _ = patch.shape
print('npix:', npix)
print('# realisations:', nreals)
```

```{python}
# Frequencies of the reconstructed subbands
for nf in [1, 2, 3, 4, 5, 8]:
    Nfreq_edges, nus_edge, nus, deltas, Delta, Nbbands = compute_freq(150, nf)
    print(nus_edge)
```

## Coverage and seenmap

```{python}
import pickle
with open(rep_mapCC + 'coverage_norm.pkl', 'rb') as f:
    coverage = pickle.load(f)
coverage_normlist = coverage[1:]

index = allrecon.index(nfrecon)
coverage_norm = coverage_normlist[index]
```

```{python}
with open(rep_mapCC + 'seenmap.pkl', 'rb') as f:
    smap = pickle.load(f)
seenmaplist = smap[1:]

index = allrecon.index(nfrecon)
seenmap = seenmaplist[index]
```

```{python}
coverage_norm>0.6
```

```{python}
# fitsfile = fits.open(fits_noise[0])
# coverage = fitsfile['COVERAGE'].data
# hp.mollview(coverage)

# coverage_patch = coverage[seenmap]
# coverage_patch.shape
```

```{python}
# ang = rmc.pix2ang(d['nside'], center, seenmap)
# coverage_norm = coverage_patch / np.max(coverage_patch)
# inverse_coverage = 1. / (np.sqrt(coverage_norm))

# plt.plot(ang, coverage_norm, '.', label='coverage')
# plt.plot(ang, np.sqrt(coverage_norm), '.', label='$\sqrt{coverage}$')
# plt.xlabel('Angle [deg]')
# # plt.ylabel('Coverage normalized')
# plt.title('Coverage normalized to the maximum as function of the angle in the patch.')
# plt.legend()
```

# Covariances matrices


### Cp matrices

```{python}
patch.shape
```

```{python}
p = 10
s = 0
plt.scatter(patch[:, 0, p, s], patch[:, 1, p, s])
pval = np.polyfit(patch[:, 0, p, s], patch[:, 1, p, s], deg=1)
print(pval)
x = np.linspace(-40, 40, 10)
plt.plot(x, np.polyval(pval, x))
plt.title(f'{stokes[s]} - pixel {p}')
plt.xlabel('Freq 0')
plt.ylabel('Freq 1')
```

```{python}
Cp = amc.get_Cp(patch, verbose=False)
print('Cp shape:', Cp.shape)

Cpcorr = np.zeros_like(Cp)
for p in range(npix):
    for s in range(3):
        Cpcorr[:, :, s, p] = amc.cov2corr(Cp[:, :, s, p])
```

```{python}
labs = []
for i in range(nfrecon):
    labs.append('f{}'.format(i))

plt.figure(figsize=(20, 100))
for p in range(1, 10):
    for s in range(3):
        plt.subplot(10, 3, 3*p + s + 1)
        vmax = np.max(np.abs(Cp[:, :, s, p]))
        plt.imshow(Cp[:, :, s, p], vmin=-vmax, vmax=vmax, cmap='bwr')
        plt.title('Cov - ' + stokes[s] + ' - pixel {}'.format(p))
        plt.colorbar(orientation='horizontal', fraction=0.2)
        plt.xticks(np.arange(len(labs)), labs)
        plt.yticks(np.arange(len(labs)), labs)

   
```

```{python}
plt.figure(figsize=(20, 100))
for p in range(1, 10):
    for s in range(3):
        plt.subplot(10, 3, 3*p + s + 1)
        plt.imshow(Cpcorr[:, :, s, p], vmin=-1, vmax=1, cmap='bwr')
        plt.title('Corr - ' + stokes[s] + ' - pixel {}'.format(p))
        plt.colorbar(orientation='horizontal', fraction=0.2)
        plt.xticks(np.arange(len(labs)), labs)
        plt.yticks(np.arange(len(labs)), labs)
```

```{python}
plt.figure(figsize=(20, 100))

for s in range(3):
    plt.subplot(10, 3, 3*p + s + 1)
    plt.imshow(np.mean(Cpcorr[:, :, s, :], axis=2), vmin=-1, vmax=1, cmap='bwr')
    plt.title(stokes[s] + ' - Cp correlation avg over pixels')
    plt.colorbar(orientation='horizontal', fraction=0.2)
    plt.xticks(np.arange(len(labs)), labs)
    plt.yticks(np.arange(len(labs)), labs)
```

### Go to Cp_prime

```{python}
# Cp_prime over bins (normalisation by the first term)
N00, Cp_prime00 = amc.Cp2Cp_prime(Cp, verbose=True)

# pixel:
p = 10

plt.figure(figsize=(15, 10))
for s in range(3):
    plt.subplot(1, 3, s+1)
    vmax = np.max(np.abs(Cp_prime00[:, :, s, p]))
    plt.imshow(Cp_prime00[:, :, s, p], vmin=-vmax, vmax=vmax, cmap='bwr')
    plt.title(stokes[s] + ' - Cp_prime00 - pixel {}'.format(p))
    plt.colorbar(orientation='horizontal', fraction=0.1)
    plt.xticks(np.arange(len(labs)), labs)
    plt.yticks(np.arange(len(labs)), labs)
```

```{python}
# Cp_prime over bins (normalisation by the diagonal)
N, Cp_prime = amc.Cp2Cp_prime_viaCorr(Cp, verbose=True)

# pixel:
p = 10

plt.figure(figsize=(15, 10))
for s in range(3):
    plt.subplot(1, 3, s+1)
    vmax = np.max(np.abs(Cp_prime[:, :, s, p]))
    plt.imshow(Cp_prime[:, :, s, p], vmin=-vmax, vmax=vmax, cmap='bwr')
    plt.title(stokes[s] + ' - Cp_prime - pixel {}'.format(p))
    plt.colorbar(orientation='horizontal', fraction=0.1)
    plt.xticks(np.arange(len(labs)), labs)
    plt.yticks(np.arange(len(labs)), labs)
```

### Covariance matrices between subbands and I Q U

```{python}
bigcov, bigcorr = amc.get_covcorr_patch(patch, stokesjoint=True, doplot=True)
```

```{python}
labs = []
for s in range(3):
    for i in range(nfrecon):
        labs.append(stokes[s]+' f{}'.format(i))
        
print(labs)
```

```{python}
plt.figure(figsize=(15, 50))
for p in range(0, 10):
    
    plt.subplot(10, 2, p*2 +1)
    vmax = np.max(np.abs(bigcov[:, :, p]))
    plt.imshow(bigcov[:, :, p], vmin=-vmax, vmax=vmax, cmap='bwr')
    plt.xticks(np.arange(len(labs)), labs, fontsize=12)
    plt.yticks(np.arange(len(labs)), labs, fontsize=12)
    for s in range(nfrecon):
        plt.axhline(y=(s+1)*nfrecon-0.5, lw=3, color='k')
        plt.axvline(x=(s+1)*nfrecon-0.5, lw=3, color='k')
    plt.title('Covariance - pixel {}'.format(p))
    plt.colorbar(fraction=0.05)
    
    plt.subplot(10, 2, p*2 +2)
    plt.imshow(bigcorr[:, :, p], vmin=-1, vmax=1, cmap='bwr')
    plt.xticks(np.arange(len(labs)), labs, fontsize=12)
    plt.yticks(np.arange(len(labs)), labs, fontsize=12)
    for s in range(nfrecon):
        plt.axhline(y=(s+1)*nfrecon-0.5, lw=3, color='k')
        plt.axvline(x=(s+1)*nfrecon-0.5, lw=3, color='k')
    plt.title('Correlation - pixel {}'.format(p))
    plt.colorbar(fraction=0.05)
```

```{python}
plt.figure(figsize=(7, 7))
plt.imshow(np.mean(bigcorr, axis=2), vmin=-1, vmax=1, cmap='bwr')
plt.title('Correlation matrice averaged over pixels')
plt.colorbar(orientation='horizontal')

plt.xticks(np.arange(len(labs)), labs, fontsize=12)
plt.yticks(np.arange(len(labs)), labs, fontsize=12)

for s in range(nfrecon):
    plt.axhline(y=(s+1)*nfrecon-0.5, lw=3, color='k')
    plt.axvline(x=(s+1)*nfrecon-0.5, lw=3, color='k')
```

### Covariances between pixels

```{python}
# Too big we have to reduce it
coverage_min = 0.8
coverage_max = 0.9
condition = (coverage_min<coverage_norm) & (coverage_norm<coverage_max)
patch_reduce = patch[:100, :, condition, :]
print(patch_reduce.shape)
cov_pix, corr_pix = amc.get_covcorr_between_pix(patch_reduce, verbose=True)
print(cov_pix.shape)
```

```{python}
isub = 0
s = 0

plt.figure()
vmax = np.max(np.abs(cov_pix[isub, s, :, :]))
plt.imshow(cov_pix[isub, s, :, :], vmin=-vmax, vmax=vmax, cmap='bwr')
plt.title('Covariance pix/pix - ' + stokes[s] 
          + f' - Band {isub} for pixels with {coverage_min} < coverage < {coverage_max}')
plt.colorbar()
```

### Covariance with JC method

We normalize the maps by the coverage and the factor to get a covariance matrix (Nbands x Nbands) for each Stokes parameter. 

```{python}
covI, covQ, covU, all_fitcov, all_norm_noise = qss.get_cov_nunu(patch[0], coverage_norm)

covJC = np.asarray([covI, covQ, covU])
covJC.shape
```

```{python}
all_norm_noise
```

```{python}
labs = []
for i in range(nfrecon):
    labs.append('f{}'.format(i))

plt.figure(figsize=(15, 5))
for s in range(3):
    plt.subplot(1, 3, s+1)
    vmax = np.max(np.abs(covJC[s, :, :]))
    plt.imshow(covJC[s, :, :], vmin=-vmax, vmax=vmax, cmap='bwr')
    plt.title(stokes[s] + ' - Cov JC')
    plt.colorbar(orientation='horizontal')
    plt.xticks(np.arange(len(labs)), labs)
    plt.yticks(np.arange(len(labs)), labs)
```

The RMS on the maps is not proportional to sqrt(coverage) maybe because of border effect with the beam. The normalisation is more complex. Here we compute the normalisation factor, from a fit of the RMS per bin of the coverage.

```{python}
isub = 0
xx, yy, fitcov = qss.get_noise_invcov_profile(patch[0, isub, :, :], 
                                              coverage_norm, 
                                              nbins=20, 
                                              norm=False,
                                              label='sub-band: {}'.format(isub), 
                                              fit=True, 
                                              doplot=True,
                                              allstokes=True)
print(fitcov.shape)
```

```{python}
correction = np.interp(1. / coverage_norm, fitcov[0, :], fitcov[1, :])
print(correction.shape)

norm_factor = coverage_norm / correction
print(norm_factor.shape)

# Galactic center
RA_center = 266.41 #deg
DEC_center = -28.94 #deg

center = qubic.equ2gal(RA_center, DEC_center)
ang = rmc.pix2ang(256, center, seenmap)

plt.figure(figsize=(15, 5))
plt.subplot(121)
plt.plot(1 / coverage_norm, correction, '.')
plt.xlabel('1 / (Coverage / MAX(Coverage))')
plt.ylabel('Correction')

plt.subplot(122)
plt.plot(ang, norm_factor, '.')
plt.ylabel('Coverage / correction')
plt.xlabel('Angle [deg]')
plt.title('Normalisation factor')
```

### Save matrices

```{python}
#     with open(rep_save + 'seenmap_nfsub{}_nfrecon{}.pkl'.format(nfsub, nfrec), 'wb') as f:
#         pickle.dump(seenmap, f)
```

### Matrix Cp_prime in coverage bins

will see later if we need to do that

```{python}
step = 0.100001
for b in np.arange(0.1, 1, step):
    print(b, b + step)
    mybin = (coverage_norm > b) & (coverage_norm < b+step)
    npix_bin = np.sum(mybin)
    print('Npix in the bin:', npix_bin)

    Nbin, Cp_primebin = amc.Cp2Cp_prime_viaCorr(Cp[:, :, :, mybin])
    
    plt.figure()
    plt.imshow(np.mean(Cp_primebin[:, :, 0, :], axis=2))
    plt.colorbar()
    plt.title('Cp_prime I bin coverage {} to {}'.format(b, b+step))

    weighted_avbin, sig2 = amc.make_weighted_av(patch[:, :, mybin, :], Cp_primebin, verbose=False)
    print('sig2', sig2.shape)
    sig2MC = np.var(weighted_avbin, axis=0)
    if b == 0.1:
        sig2_bin = sig2
        sig2MC_bin = sig2MC
    else:
        sig2_bin = np.concatenate((sig2_bin, sig2))
        sig2MC_bin = np.concatenate((sig2MC_bin, sig2MC))

```

```{python}
x = 1 / np.sqrt(coverage_norm)
Stokes = ['I', 'Q', 'U']
istk = 0
xc_bin, yc_bin, dx_bin, dy_bin, _ = ft.profile(x, sig2_bin[:, istk], 
                               nbins=30, 
                               plot=False,
                               clip=True,
                                dispersion=False)


xcMC_bin, ycMC_bin, dxMC_bin, dyMC_bin, _ = ft.profile(x, sig2MC_bin[:, istk], 
                                       nbins=30, 
                                       plot=False,
                                       clip=True,
                                        dispersion=False)

plt.errorbar(xc_bin, yc_bin, xerr=dx_bin, yerr=dy_bin, fmt='bo', label='$\sigma^2$')
plt.errorbar(xcMC_bin, ycMC_bin, xerr=dxMC_bin, yerr=dyMC_bin, fmt='ro', label='$\sigma^2 MC$')
# plt.plot(x, sig2_bin[:, istk] , 'b,')
# plt.plot(x, sig2MC_bin[:, istk] , 'r,')
plt.ylim(0, 50)

plt.xlabel('$1 / \sqrt{coverage}$', fontsize=15)
plt.ylabel('$\sigma^2$', fontsize=15)
plt.legend()
plt.title('{} component'.format(Stokes[istk]))
```

```{python}
plt.plot(xc_bin, yc_bin / ycMC_bin)
plt.xlabel('$1 / \sqrt{coverage}$', fontsize=15)
plt.ylabel('$\sigma^2 / \sigma_{MC}^2$', fontsize=15)
plt.title('Ratio, Weighted average done in 9 coverage bins')
```

```{python}
np.mean(yc_bin / ycMC_bin)
```

## 1st term evolution as function of the number of sub-bands


#### Get Cp and covJC for each number of sub-bands

```{python}
mylist_Cp, mylist_covJC = [], []
for i in range(6):
    nfrecon = allrecon[i]
    print('\n nfrecon:', nfrecon)
    patch = np.load(rep_mapCC + 'patch_clth_nfrecon{}.npy'.format(nfrecon))
    print('patch shape:', patch.shape)

    nreals, _, npix, _ = patch.shape
    print('npix:', npix)
    print('# realisations:', nreals)
    
    Cp = amc.get_Cp(patch, verbose=False)
    print('Cp shape:', Cp.shape)
    mylist_Cp.append(Cp)
    
    coverage_norm = coverage_normlist[i]
    covI, covQ, covU, all_fitcov, all_norm_noise = qss.get_cov_nunu(patch[0], coverage_norm)
    covJC = np.asarray([covI, covQ, covU])
    mylist_covJC.append(covJC)

```

```{python}
len(mylist_Cp)
# allrecon[:-1]
mylist_Cp[0].shape
```

```{python}
pix = 0
plt.figure()
for istk in range(3):
    myterms = [mylist_Cp[i][0, 0, istk, pix] for i in range(5)]
    plt.plot(allrecon, myterms, 'o', color=colorlist[istk])

    a, b, c = np.polyfit(allrecon, myterms, deg=2, rcond=None, full=False, w=None, cov=False)
    x = np.arange(1, 9, 0.1)
    plt.plot(x, a*x**2 + b*x + c, color=colorlist[istk], 
             label='{}: ${:2.3}x^2 {:2.3}x + {:2.3}$'.format(stokes[istk], a, b, c))

plt.xlabel('# Bands')
plt.ylabel('$Cp_{00}$ - pixel')
plt.legend()
```

```{python}
len(mylist_covJC)
```

```{python}
plt.figure()
for istk in range(3):
    myterms = [mylist_covJC[i][istk, 0, 0] for i in range(5)]
    plt.plot(allrecon, myterms, 'o', color=colorlist[istk])

    a, b, c = np.polyfit(allrecon, myterms, deg=2, rcond=None, full=False, w=None, cov=False)
    x = np.arange(1, 9, 0.1)
    plt.plot(x, a*x**2 + b*x + c, color=colorlist[istk], 
             label='{}: ${:2.3}x^2 {:2.3}x + {:2.3}$'.format(stokes[istk], a, b, c))

plt.xlabel('# Bands')
plt.ylabel('$Cov JC$')
plt.legend()
```

# Recombined sub-bands at map level


#### Check we get the same using Cp, Cp_prime00 or Cp_prime

```{python}
# Using Cp directly
avg, sig2 = amc.make_weighted_av(patch, Cp, verbose=True)
sig2MC = np.var(avg, axis=0)
```

```{python}
# Using Cp_prime 00
avg00, sig200 = amc.make_weighted_av(patch, Cp_prime00, verbose=False)
sig2MC00 = np.var(avg00, axis=0)

```

```{python}
# Using Cp_prime
avg_prime, sig2_prime = amc.make_weighted_av(patch, Cp_prime, verbose=False)
sig2MC_prime = np.var(avg_prime, axis=0)
```

```{python}
sig2.shape
```

```{python}
x = 1 / coverage_norm

xc, yc, dx, dy, _ = ft.profile(x, sig2[:, 0], 
                               nbins=30, 
                               plot=False,
                               clip=True)


xcMC, ycMC, dxMC, dyMC, _ = ft.profile(x, sig2MC[:, 0], 
                                       nbins=30, 
                                       plot=False,
                                       clip=True)

xc00, yc00, dx00, dy00, _ = ft.profile(x, sig200[:, 0], 
                               nbins=30, 
                               plot=False,
                               clip=True)


xcMC00, ycMC00, dxMC00, dyMC00, _ = ft.profile(x, sig2MC00[:, 0], 
                                       nbins=30, 
                                       plot=False,
                                       clip=True)

xcprime, ycprime, dxprime, dyprime, _ = ft.profile(x, sig2_prime[:, 0], 
                               nbins=30, 
                               plot=False,
                               clip=True)


xcMCprime, ycMCprime, dxMCprime, dyMCprime, _ = ft.profile(x, sig2MC_prime[:, 0], 
                                       nbins=30, 
                                       plot=False,
                                       clip=True)


plt.errorbar(xc, yc, xerr=dx, yerr=dy, 
             color=colorlist[0], fmt='x', label='$\sigma^2$')
plt.errorbar(xcMC, ycMC, xerr=dxMC, yerr=dyMC, 
             color=colorlist[0], fmt='+', label='$\sigma^2 MC$')

plt.errorbar(xc00, yc00, xerr=dx00, yerr=dy00, 
             color=colorlist[1], fmt='x', label='$\sigma^2$ 00')
plt.errorbar(xcMC00, ycMC00, xerr=dxMC00, yerr=dyMC00, 
             color=colorlist[1], fmt='+', label='$\sigma^2 MC$ 00')

plt.errorbar(xcprime, ycprime, xerr=dxprime, yerr=dyprime, 
             color=colorlist[2], fmt='x', label='$\sigma^2$ prime')
plt.errorbar(xcMCprime, ycMCprime, xerr=dxMCprime, yerr=dyMCprime, 
             color=colorlist[2], fmt='+', label='$\sigma^2 MC$ prime')

plt.ylim(0, 10)

plt.xlabel('$1 / coverage$', fontsize=15)
plt.ylabel('$\sigma^2$', fontsize=15)
plt.legend()
```

#### Recombine the sub-bands using Cp

```{python}
mylist_sig2, mylist_sig2MC = [], []
mylist_Cp, mylist_Cp_prime = [], []
for i in range(6):
    nfrecon = allrecon[i]
    print('\n nfrecon:', nfrecon)
    
    coverage_norm = coverage_normlist[i]
    
    patch = np.load(rep_mapCC + 'patch_clth_nfrecon{}.npy'.format(nfrecon))
    patch = patch[:500, :, coverage_norm>0.9, :]
    print('patch shape:', patch.shape)

    nreals, _, npix, _ = patch.shape
    print('npix:', npix)
    print('# realisations:', nreals)
    
    Cp = amc.get_Cp(patch, verbose=False)
    print('Cp shape:', Cp.shape)
    mylist_Cp.append(Cp)
    
    N, Cp_prime = amc.Cp2Cp_prime_viaCorr(Cp)
    mylist_Cp_prime.append(Cp_prime)
    print('Cp_prime shape:', Cp_prime.shape)
    
    avg, sig2 = amc.make_weighted_av(patch, Cp_prime, verbose=True)
    sig2MC = np.var(avg, axis=0)
    mylist_sig2.append(sig2)
    mylist_sig2MC.append(sig2MC)    
```

```{python}
nbins = 15
x = np.zeros((6, nbins, 3))
y = np.zeros_like(x)
dx = np.zeros_like(x)
dy = np.zeros_like(x)
xMC = np.zeros_like(x)
yMC = np.zeros_like(x)
dxMC = np.zeros_like(x)
dyMC = np.zeros_like(x)

plt.figure()
for i in range(6):
    coverage_norm = coverage_normlist[i]
    print(coverage_norm.shape)
    plt.figure()
    xx, yy, fitcov = qss.get_noise_invcov_profile(mylist_sig2MC[i], 
                                                  coverage_norm[coverage_norm>0.9], 
                                                  QUsep=True,
                                                  nbins=20, 
                                                  norm=False,
                                                  label='', 
                                                  fit=True, 
                                                  doplot=True,
                                                  allstokes=True)
    
    plt.legend()
    plt.grid()
    
    correctionI = np.interp(1. / coverage_norm[coverage_norm>0.9], fitcov[0, :], fitcov[1, :])
    correctionQU = np.interp(1. / coverage_norm[coverage_norm>0.9], fitcov[0, :], fitcov[2, :])
    print(correctionI.shape)

    for istk in range(3):
        sig = np.sqrt(mylist_sig2[i][:, istk])  
        sigMC = np.sqrt(mylist_sig2MC[i][:, istk])
        print(sig.shape)
        if istk == 0:
            factor = np.sqrt(correctionI * coverage_norm[coverage_norm>0.9]) 
        else:
            factor = np.sqrt(correctionQU * coverage_norm[coverage_norm>0.9]) 
        npix = sig.shape[0]
        a = np.arange(npix)
        print(factor.shape)
        x[i, :, istk], y[i, :, istk], dx[i, :, istk], dy[i, :, istk], _ = ft.profile(a, 
                                                                                     sig * factor, 
                                                                                     nbins=nbins, 
                                                                                     dispersion=False,
                                                                                     plot=False,
                                                                                     clip=True)


        xMC[i, :, istk], yMC[i, :, istk], dxMC[i, :, istk], dyMC[i, :, istk], _ = ft.profile(a, 
                                                                                             sigMC * factor,
                                                                                             nbins=nbins, 
                                                                                             dispersion=False,
                                                                                             plot=False,
                                                                                             clip=True)

```

```{python}
istk = 2
for i in range(6):
    plt.errorbar(x[i, :, istk], y[i, :, istk], xerr=dx[i, :, istk], yerr=dy[i, :, istk], 
                 color=colorlist[i], label='theo - {} bands'.format(allrecon[i]))
    plt.errorbar(xMC[i, :, istk], yMC[i, :, istk], xerr=dxMC[i, :, istk], yerr=dyMC[i, :, istk], 
                 fmt='o', color=colorlist[i], label='MC - {} bands'.format(allrecon[i]))

plt.xlabel('x', fontsize=15)
plt.ylabel('$y $ ', fontsize=15)
plt.legend(loc='upper left')
plt.title('{} component'.format(stokes[istk]))
```

```{python}
ymean = np.zeros((6, 3))
yMCmean = np.zeros((6, 3))
for i in range(6):
    for istk in range(3):
        ymean[i, istk] = np.mean(y[i, :, istk] / y[0, :, istk])
        yMCmean[i, istk] = np.mean(yMC[i, :, istk] / yMC[0, :, istk])
```

```{python}
for s in range(3):
    plt.plot(allrecon, ymean[:, s], 'o', label=stokes[s])
plt.plot(allrecon, np.sqrt(allrecon), 'k', label='$\sqrt{N}$')
plt.xlabel('# bands')
plt.ylabel('$\sigma$ ')
plt.legend()
```

```{python}
istk = 0
for b in range(nbins):
    plt.plot(allrecon, y[:, b, istk]/y[0, b, istk], label='bin {}'.format(b))
plt.plot(allrecon, np.sqrt(allrecon), 'k', label='$\sqrt{N}$')
plt.legend()
plt.xlabel('# bands')
plt.ylabel('$\sigma$ ')

```

## Recombine with JC method

```{python}
cov_I, cov_Q, cov_U, new_sub_maps, all_fitcov, all_norm_noise = 
```

```{python}
# Try with one matrix
mylist_Cp_corrected_avg = []
for i in range(7):
    Cp = mylist_Cp[i]
    print('Cp shape:', Cp.shape)

    nbands = Cp.shape[0]
    print('nbands:', nbands)

    coverage_norm = mylist_coverage_norm[i]

    residu = mylist_residuals[i]
    print('Residuals:', residu.shape)

    Cp_corrected = np.zeros_like(Cp)

    for isub1 in range(nbands):
        plt.figure()
        _, _, fitcov1 = qss.get_noise_invcov_profile(residu[0, isub1, :, :], 
                                                      coverage_norm, 
                                                      nbins=20, 
                                                      norm=False,
                                                      label='Nband{}, sub-band: {}'.format(nbands, isub1), 
                                                      fit=True, 
                                                      doplot=True,
                                                      allstokes=True)
        plt.legend()
        correction1 = np.interp(1. / coverage_norm, fitcov1[0, :], fitcov1[1, :])
        print(np.mean(correction1))
        norm_factor1 = coverage_norm / correction1

        for isub2 in range(nbands):
            _, _, fitcov2 = qss.get_noise_invcov_profile(residu[0, isub2, :, :], 
                                                      coverage_norm, 
                                                      nbins=20, 
                                                      norm=False,
                                                      label='sub-band: {}'.format(isub), 
                                                      fit=True, 
                                                      doplot=False,
                                                      allstokes=True)
            correction2 = np.interp(1. / coverage_norm, fitcov2[0, :], fitcov2[1, :])
            norm_factor2 = coverage_norm / correction2
    #         print(correction2.shape)

            for istk in range(3):
                Cp_corrected[isub1, isub2, istk, :] = Cp[isub1, isub2, istk, :] * np.sqrt(norm_factor1 * norm_factor2)

    Cp_corrected_avg = np.mean(Cp_corrected, axis=3)
    mylist_Cp_corrected_avg.append(Cp_corrected_avg)
    print(Cp_corrected_avg.shape)
```

```{python}
# Correlation matrices Cp averaged over pixels after correction

Stokes = ['I', 'Q', 'U']
nbands = [1, 1, 2, 3, 4, 5, 8]
plt.figure(figsize=(20, 15))
plt.subplots_adjust(wspace=0.6)
for i in range(7):
    for istk in range(3):
        plt.subplot(3, 7, 7*istk+i+1)
        plt.imshow(mylist_Cp_corrected_avg[i][:, :, istk])
        plt.title(Stokes[istk])
        if istk == 0:
            print('\n Correlation Matrices Cp_prime - {} bands:'.format(nbands[i]))
            
        print('\n {}:\n'.format(Stokes[istk]), mylist_Cp_corrected_avg[i][:, :, istk])
        plt.colorbar(fraction=0.05, orientation='horizontal')
```

```{python}
i = 4
print('\nCp avg after correction \n')
for istk in range(3):
    print(mylist_Cp_corrected_avg[i][:, :, istk])
print('\nCovI\n', mylist_covI[i][0])
print('\nCovQ\n', mylist_covQ[i][0])
print('\nCovU\n', mylist_covU[i][0])
```

```{python}
# Make a loop over irec and fill dictionnaries
dict_sig2MC = {}
dict_sig2 = {}
ang_th = 15
ang = rmc.pix2ang(d['nside'], center, seenmap)

for irec in [5]:
    print('irec =', irec)   
#     _, recon_patch, _, _ = rmc.get_patch_many_files(rep_simu + date_name, '*nfrecon{}*False*'.format(irec))
    residuals = amc.get_residuals(rep, 'mean_recon', irec)
    
    if irec == 1:
        # Remove the single dimension  
        residuals = np.squeeze(residuals)
        print('Residuals shape:', residuals.shape)

        sig2MC_monofreq = np.var(residuals, axis=0) # Variance over realizations
        sig2MCmean_monofreq = amc.average_pix_sig2(sig2MC_monofreq, ang, ang_threshold=ang_th) # Mean over pixels
        dict_sig2MC.update({'{}'.format(irec): sig2MC_monofreq})
        dict_sig2MC.update({'{}mean'.format(irec): sig2MCmean_monofreq})
        
        print('\n')
       
    else:
        if irec == 2:
            doplot = True
        else :
            doplot = False
        Cp = amc.get_Cp(residuals, nfrecon=d['nf_recon'], verbose=False, doplot=doplot)
        N, Cp_prime = amc.Cp2Cp_prime_viaCorr(Cp, verbose=True) # Average Cp over pixels
#         N, Cp_prime = amc.Cp2Cp_prime(Cp, verbose=True)
        
        # Compute sig2 and sig2MC 
        # Using Cp or Cp_prime
        weighted_av, sig2 = amc.make_weighted_av(residuals, Cp_prime, verbose=False)
        
        sig2mean = amc.average_pix_sig2(sig2, ang, ang_threshold=ang_th)
        dict_sig2.update({'{}'.format(irec): sig2})
        dict_sig2.update({'{}mean'.format(irec): sig2mean})
        
        sig2MC = np.var(weighted_av, axis=0) # Variance over realisations
        sig2MCmean = amc.average_pix_sig2(sig2MC, ang, ang_threshold=ang_th) # Mean over pixels
        dict_sig2MC.update({'{}'.format(irec): sig2MC})
        dict_sig2MC.update({'{}mean'.format(irec): sig2MCmean})
        
        print('\n')
```

```{python}

```

```{python}
def Cp2Cp_prime_percoveragebin(Cp, coverage, nbins=10, method='viacorr'):
    cov_max = 1.
    cov_min = 0.1
    step = (cov_max - cov_min) / nbins + 0.0001
    print('Step in coverage:', step)
    
    nbands = Cp.shape[0]
    Cp_prime = np.zeros_like(Cp)
    Nbins = np.zeros((nbins, nbands, nbands, 3))
    for i, b in enumerate(np.arange(cov_min, cov_max, step)):
        mybin = (coverage > b) & (coverage < b+step)
        npix_bin = np.sum(mybin)
        print('Npix in the bin:', npix_bin)
        
        if method == 'viacorr':
            Nbins[i], Cp_prime[:, :, :, mybin] = amc.Cp2Cp_prime_viaCorr(Cp[:, :, :, mybin])
        else:
            Nbins[i], Cp_prime[:, :, :, mybin] = amc.Cp2Cp_prime(Cp[:, :, :, mybin])
    N = np.mean(Nbins, axis=0)
    return N, Cp_prime
```

```{python}
    
    if nfrec == 1:
        sig2MC = np.var(residuals[:, 0, :, :], axis=0) # Variance over realisations
        sig2 = sig2MC * 0.

#         # Recombined the band
#         # Using Cp_prime
#         weighted_av, sig2 = amc.make_weighted_av(residuals, Cp_prime, verbose=False)
#         sig2MC = np.var(weighted_av, axis=0)
#         mylist_weighted_av.append(weighted_av)
#         mylist_sig2.append(sig2)
#         mulist_sig2MC.append(sig2MC)

# #     Per coverage bins
#         else:
# #             N, Cp_prime = Cp2Cp_prime_percoveragebin(Cp, coverage_norm, nbins=9)
# #             weighted_av, sig2 = amc.make_weighted_av(residuals, Cp_prime, verbose=False)
# #             print('sig2', sig2.shape)
# #             sig2MC = np.var(weighted_av, axis=0)
# #             allN.append(N)
# #             allCp_prime.append(Cp_prime)
# #             allCp_primenorm.append(Cp_primenorm)
# #             all_weighted_av.append(weighted_av)

#             for b in np.arange(0.1, 1, step):
#                 print(b, b + step)
#                 mybin = (coverage_norm > b) & (coverage_norm < b+step)
#                 npix_bin = np.sum(mybin)
#                 print('Npix in the bin:', npix_bin)

#                 if nfrec == 1:
#                     sig2MCbin = np.var(residuals[:, 0, mybin, :], axis=0)
#                     sig2bin = sig2MCbin * 0.
#                 else:
#                     # Cp_prime and weighted average per coverage bin
#                     Nbin, Cp_primebin = amc.Cp2Cp_prime_viaCorr(Cp[:, :, :, mybin])

#                     plt.figure()
#                     plt.imshow(np.mean(Cp_primebin[:, :, 0, :], axis=2))
#                     plt.colorbar()
#                     plt.title('Cp_prime I bin coverage {} to {}'.format(b, b+step))

#                     weighted_avbin, sig2bin = amc.make_weighted_av(residuals[:, :, mybin, :], Cp_primebin, verbose=False)
#                     print('sig2', sig2bin.shape)
#                     sig2MCbin = np.var(weighted_avbin, axis=0)
#                 if b == 0.1:
#                     sig2 = sig2bin
#                     sig2MC = sig2MCbin
#                 else:
#                     sig2 = np.concatenate((sig2, sig2bin))
#                     print('gg', sig2.shape)
#                     sig2MC = np.concatenate((sig2MC, sig2MCbin))
```

```{python}


```

```{python}

```

```{python}
# all_sig2MC[0].shape
# yMC.shape
coverage_norm
```

```{python}
nbands = [1, 2, 3, 4, 5, 8]

# ss = np.zeros((7, 3))
# for i in range(7):
#     ss[i, :] = np.mean(all_sig2MC[i], axis=0)
mean_sig2MC = np.mean(yMC, axis=1) # Mean over the bins
std_sig2MC = np.sqrt(np.sum(dyMC**2, axis=1)) / nbins
# std_sig2MC = np.std(yMC, axis=1) / np.sqrt(nbins)


for i in range(3):
    mean_norm = mean_sig2MC[1:, i]/mean_sig2MC[1, i]
    plt.errorbar(nbands, mean_norm, yerr=std_sig2MC[1:, i], fmt='o', label=Stokes[i])
plt.plot(np.arange(1, 9), np.ones(8), 'k--', label='$y = 1$')
# plt.plot(np.arange(1, 9), np.sqrt(np.arange(1, 9)), 'r', label='$y=\sqrt{x}$')
plt.legend()
plt.xlabel('Number of bands')
plt.ylabel('$\sigma$ in the recombined redidual map')
```

```{python}
npix_patch = coverage_norm.shape[0]
color = ['b', 'r', 'g']
Stokes = ['I', 'Q', 'U']
step = 0.100001

std = np.zeros((7, 3))

nbands = [1, 3, 5, 1, 2, 4, 8]
for i in range(2):
    residuals = recon[i] - recon_nl[i]
    Cp = amc.get_Cp(residuals, nfrecon=nbands[i], verbose=True, doplot=True)

    for b in np.arange(0.1, 1, step):
        print(b, b + step)
        mybin = (coverage_norm > b) & (coverage_norm < b+step)
        npix_bin = np.sum(mybin)
        print('Npix in the bin:', npix_bin)

        Cp_primebin = amc.Cp2Cp_prime_viaCorr(Cp[:, :, :, mybin])

        plt.figure()
        plt.imshow(np.mean(Cp_primebin[:, :, 0, :], axis=2))
        plt.colorbar()
        plt.title('Cp_prime I bin coverage {} to {}'.format(b, b+step))

        weighted_avbin, sig2 = amc.make_weighted_av(residuals[:, :, mybin, :], Cp_primebin, verbose=False)
        print('weighted', weighted_avbin.shape)
        print('sig2', sig2.shape)
        sig2MC = np.var(weighted_avbin, axis=0)
        if b == 0.1:
            sig2_bin = sig2
            sig2MC_bin = sig2MC
        else:
            sig2_bin = np.concatenate((sig2_bin, sig2))
            sig2MC_bin = np.concatenate((sig2MC_bin, sig2MC))

        
#     std[i, :] = np.std(res[seenmap, :], axis=0)

# for istk in range(3):
#     plt.plot(nband, std[:, istk]/(std[0, istk]), 'o', color=color[istk], label=Stokes[istk])
# plt.legend()
# plt.xlabel('# reconstructed bands')
```

```{python}

mean = [0, 0]
mycov = [[1, -0.5], [-0.5, 1]]
x = np.random.multivariate_normal(mean, mycov, size=100000)

# Check we have the covariance we want
newcov = np.cov(x.T)
print(newcov)

# Look at the covariance of x²
x2 = x**2
newcov2 = np.cov(x2.T)
print(newcov2)
```

```{python}
x2.shape
```

```{python}
plt.scatter(x[:, 0], x[:, 1])
```

```{python}

```
