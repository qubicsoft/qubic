---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

<!-- #region slideshow={"slide_type": "skip"} -->
# FPSF 

Author: Louise
Date: 29/04/2021

In this notebook, I try to define the FPSF. I use the data from Martin's simulations.
<!-- #endregion -->

```{python slideshow={'slide_type': 'skip'}}
import numpy as np
import pandas as pd
from matplotlib.animation import FuncAnimation
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors

rc('font',size=14)

# %matplotlib notebook
```

```{python}
# If you want to save plots, set the directory here
save_dir = '/home/lmousset/QUBIC/These_manuscrit/Figures/Plots/'
```

<!-- #region slideshow={"slide_type": "slide"} -->
## About the FPSF...

By definition, the FPSF of an instrument is its response to an impulse at a given frequency. We can consider a monochromatic source with spectral energy density: $S_{in}(\nu) = I_0\delta(\nu - \nu_{in})$ with unit $[W/Hz]$

The response of the system will be:
$$ I_{out}(\nu) = [S_{in} \otimes \rm{FPSF}](\nu) = \int S_{in}(\nu') FPSF(\nu - \nu') d\nu' =  I_0 \rm{FPSF}(\nu - \nu_{in})$$

The FPSF do not have unit.
<!-- #endregion -->

```{python slideshow={'slide_type': 'subslide'}}
# this is a small example considering a impulse at nu_in=1 with a Gaussian response. 
xx = np.arange(0, 2, 0.01)
plt.figure(figsize=(4, 4))
plt.plot(xx, np.exp(-0.5*(xx-1)**2/0.2**2))
plt.axvline(1, color='k')
plt.text(1, -0.5, r'$\nu_{in}$')
plt.xlabel(r'$\nu$')
plt.ylabel(r'$I_{out}$')
```

<!-- #region slideshow={"slide_type": "slide"} -->
## Get the data from Martin's simulations

In these simulations, we consider a monochromatic source: $I_{in}(\nu) = I_s\delta(\nu - \nu_{in})$

And we reconstruct 4 bands centered at $\nu_{cj} = 135.51, 144.29, 153.65, 163.61$ GHz with bandwidths $\Delta_{\nu j}$, where $j$ is the index of the band.

We vary $\nu_{in}$ on 22 values inside the wide band from 130 to 170 GHz. So in this way, we test the QUBIC FPSF at different $\nu_{in}$.

<!-- #endregion -->

```{python slideshow={'slide_type': 'skip'}}
# Input freqencies
_nusin_ = [132.97971811, 134.37952271, 135.79406229, 137.22349195,
          141.60269708, 143.09327106, 
          144.59953548, 146.12165553, 146.8887135 , 147.6597981 , 
          148.43493047, 149.21413186, 149.99742362, 150.78482723, 
          151.57636428, 152.37205646, 153.97599357, 155.59681445, 
          157.23469683, 158.8898203 , 160.56236634, 162.25251836]
nsimu = len(_nusin_)

# The four reconstructed sub-bands
_nusrec_ = np.array([135.50540829, 144.29216391, 153.6486907 , 163.61193508])
_nusedge_ = np.array([131.25, 139.76081658, 148.82351125, 158.47387016, 168.75])
nu_bandwidth = np.diff(_nusedge_)

# Measurement (intensity in the four sub-bands for each nu_in)
datarec = np.array([[ 0.91601087, -0.16300357,  0.07148064, -0.02154493],
                    [ 0.97108358, -0.12843866,  0.02048783, -0.01400606],
                    [ 0.94662368, -0.06041048, -0.01865472, -0.00286433],
                    [ 0.85516324,  0.07495715, -0.05477733,  0.00930614],
                    [ 0.09077023,  0.82225625, -0.10677544,  0.03321614],
                    [-0.03513556,  0.96278344, -0.09896842,  0.01836723],
                    [-0.09086167,  0.99084585, -0.0621382 ,  0.00215334],
                    [-0.10657393,  0.95787016,  0.0252968 , -0.0217093 ],
                    [-0.09700264,  0.87454252,  0.09206298, -0.0290194 ],
                    [-0.08114005,  0.77071529,  0.18829684, -0.03471806],
                    [-0.05707247,  0.61135522,  0.33435032, -0.04617655],
                    [-0.0329217 ,  0.41514615,  0.52139209, -0.06210269],
                    [-0.02148455,  0.24494626,  0.68579009, -0.08144495],
                    [-0.0081945 ,  0.1304667 ,  0.79391375, -0.08693801],
                    [ 0.00326546,  0.04293615,  0.87552804, -0.08916238],
                    [ 9.29098752e-04, -1.83078044e-02,  9.46933287e-01, -8.97956690e-02],
                    [ 0.00475218, -0.09946185,  1.        , -0.06808089],
                    [ 0.00940636, -0.12568378,  0.96436097,  0.00273789],
                    [ 0.00452396, -0.13156937,  0.81214209,  0.17818687],
                    [ 0.00121509, -0.08540265,  0.42981105,  0.50409209],
                    [-0.01046448, -0.05775577,  0.14201797,  0.77813485],
                    [-0.00907187, -0.04032238, -0.01218665,  0.91569607]]).T 

# Make a dataframe unsing Pandas
data = {'nu_in': _nusin_,
        'band1': datarec[0],
        'band2': datarec[1],
        'band3': datarec[2],
        'band4': datarec[3]}

df = pd.DataFrame(data)
df

```

<!-- #region slideshow={"slide_type": "slide"} -->
## Reproduction of the plot in the paper

First, for each band, we can plot the result as a function of $\nu_{in}$.
As expected, the maximum corresponds to the center of the band $\nu_{cj}$.
<!-- #endregion -->

```{python slideshow={'slide_type': 'subslide'}}
mycolors = ['r', 'orange', 'g', 'b']
# One plot for each band
fig, axs = plt.subplots(2, 2, figsize=(8, 8))
axs = np.ravel(axs)

for i in range(4):
    axs[i].plot(df['nu_in'], df[f'band{i+1}'], 'o', color=mycolors[i])
    axs[i].axvline(_nusrec_[i], color='grey')
    axs[i].axvline(150, color='k')
    axs[i].text(_nusrec_[i]-2, -0.3, r'$\nu_{c}$' + f'{i+1}', color='grey')
    axs[i].set_title(f'Band {i+1}')
    axs[i].set_xlabel(r'$\nu_{in}$ [GHz]')
    axs[i].set_ylabel(r'$I_{out}$' + f'{i+1}')
    axs[i].set_xlim(130, 165)
    axs[i].set_ylim(-0.2, 1.1)
    axs[i].grid()

fig.tight_layout()
```

```{python}
from scipy.interpolate import interp1d
```

```{python}
df['nu_in']
```

```{python slideshow={'slide_type': 'slide'}}
# The four plots on the same axis
import scipy
xx = np.linspace(df['nu_in'][0], df['nu_in'][21], 100)

fig = plt.figure(figsize=(8, 6))
ax = fig.gca()
for i in range(4):
    interp = interp1d(df['nu_in'], df[f'band{i+1}'])
    ax.plot(xx, interp(xx), color=mycolors[i])
    ax.plot(df['nu_in'], df[f'band{i+1}'], 'o', color=mycolors[i], label=f'Sub-band {i+1}')
    #ax.axvline(150, color='k')
    #ax.axvline(_nusrec_[i], color='grey')
    #ax.text(_nusrec_[i]-0.5, -0.3, r'$\nu_{c}$' + f'{i+1}', color='grey')
    ax.axvspan(xmin = _nusedge_[i], xmax = _nusedge_[i+1], alpha=0.2, color = mycolors[i])
ax.set_xlim(130, 165)
ax.set_ylim(-0.2, 1.1)
ax.set_xlabel(r'$\nu_{in}$ [GHz]', fontsize=16)
ax.set_ylabel(r'$I_{out}$', fontsize=16)
ax.grid()
ax.legend()

fig.tight_layout()
#fig.savefig(save_dir + f'FPSF_band.pdf', bbox_inches='tight')
```

<!-- #region slideshow={"slide_type": "slide"} -->
#### How can we superpose the 4 curves ?
Let's recenter each curve on 0 by subtracting $\nu_{cj}$. We also normalize by $\Delta_{\nu j}$ because the frequencies are logarithmically spaced.

This is the plot in the paper (figure 8)
<!-- #endregion -->

```{python slideshow={'slide_type': 'subslide'}}
# Superposition
fig = plt.figure()
ax = fig.gca()
for i in range(4):
    ax.plot((df['nu_in'] - _nusrec_[i])/nu_bandwidth[i], df[f'band{i+1}'], 
            'o', color=mycolors[i], label=f'Band{i+1}')
ax.set_xlim(-2, 2)
ax.set_ylim(-0.2, 1.1)
ax.set_xlabel(r'$\frac{(\nu_{in} - \nu_c)}{\Delta_\nu}$')
ax.set_ylabel(r'$I_{out}$')
ax.grid()
ax.legend()
```

<!-- #region slideshow={"slide_type": "slide"} -->
## Another way of plotting the same data

For each $\nu_{in}$ let's look at the four points in the sub-bands.
<!-- #endregion -->

```{python}
# Just for one input frequency
i = 8
fig = plt.figure(figsize=(4, 4))
ax = fig.gca()
points, = ax.plot(_nusrec_, df.loc[i][1:], 'ko')
line = ax.axvline(_nusin_[i], color = 'k', ls = '--', alpha=0.4)#, label=r'$\nu_{in}=$'+f'{nu:3.2f} GHz')
text = ax.text(140, 1, r'$\nu_{in}=$'+f'{_nusin_[i]:3.2f} GHz', fontsize=14)

ax.axhline(i, color='k', ls = '-', alpha = 0.2)
for j in range(4):
    ax.axvspan(xmin = _nusedge_[j], xmax = _nusedge_[j+1], alpha = 0.2, color=mycolors[j])
ax.set_xlabel(r'$\nu$ [GHz]', fontsize=16)
ax.set_ylabel(r'$I_{out}$', fontsize=16)
ax.set_ylim(-0.2,1.1)

fig.tight_layout()
fig.savefig(save_dir + f'FPSF_nuin{_nusin_[i]:3.0f}.pdf', bbox_inches='tight')
```

```{python slideshow={'slide_type': 'subslide'}}
fig = plt.figure(figsize=(4, 4))
ax = fig.gca()
points, = ax.plot(_nusrec_, df.loc[0][1:], 'ko')
line = ax.axvline(_nusin_[0], color = 'k', ls = '--')#, label=r'$\nu_{in}=$'+f'{nu:3.2f} GHz')
text = ax.text(140, 1, r'$\nu_{in}=$'+f'{_nusin_[0]:3.2f} GHz', fontsize=14)

def init():
    ax.axhline(0, color = 'k', ls = '-', alpha = 0.2)
    for i in range(4):
        ax.axvspan(xmin = _nusedge_[i], xmax = _nusedge_[i+1], alpha = 0.2, color =mycolors[i])
    ax.set_xlabel(r'$\nu$ [GHz]')
    ax.set_ylabel(r'$I_{out}$')
    ax.set_ylim(-0.2,1.1)
    return points

def animate(i):
    points.set_data(_nusrec_, df.loc[i][1:])
    line.set_xdata(_nusin_[i])
    text.set_text(r'$\nu_{in}=$'+f'{_nusin_[i]:3.2f} GHz')
    return(points)


steps = np.arange(nsimu)
anim = FuncAnimation(fig, animate, steps, init_func=init, interval=1000, blit=False, repeat=False)

# Save a .gif
anim.save('./FPSF.gif', writer='imagemagick')
```

<!-- #region slideshow={"slide_type": "skip"} -->
### Open the .gif 
![SegmentLocal](FPSF.gif "segment")
<!-- #endregion -->

<!-- #region slideshow={"slide_type": "slide"} -->
In order to superimpose all the points, we subtract $\nu_{in}$ on the x axis. What we get is a similar plot, symetric to figure 8. This time, I did not normalized by $\Delta_\nu$.
<!-- #endregion -->

```{python slideshow={'slide_type': 'subslide'}}
# Make a nice color map for nu_in similar to the visible spectra
def truncate_colormap(cmap, minval=0.0, maxval=1.0, n=-1):
    if n == -1:
        n = cmap.N
    new_cmap = mcolors.LinearSegmentedColormap.from_list(
         'trunc({name},{a:.2f},{b:.2f})'.format(name=cmap.name, a=minval, b=maxval),
         cmap(np.linspace(minval, maxval, n)))
    return new_cmap


cmap = plt.get_cmap('hsv_r')
new_cmap = truncate_colormap(cmap, 0.2, 1)

fig, ax = plt.subplots(figsize=(6, 1))
fig.subplots_adjust(bottom=0.5)

# cmap = mpl.cm.cool
norm = mpl.colors.Normalize(vmin=None, vmax=None)

fig.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=new_cmap),
             cax=ax, orientation='horizontal', label='')

```

```{python}
from scipy.optimize import curve_fit

# Try to fit a sinus cardianl
def sinc(x,*p):
    A, mu, sigma = p
    term = np.pi*(x-mu)/sigma
    return A * np.sin(term) / term

c = 3e8
nu_diff = np.zeros((22, 4))
lambda_diff = np.zeros((22, 4))
yy = np.zeros((22, 4))
for i in range(22):
    nu_diff[i, :] = (_nusrec_ - df['nu_in'][i])
    lambda_diff[i, :] = (c/_nusrec_ - c/df['nu_in'][i])    
    yy[i, :] = df.loc[i][1:]

nu_diff = np.ravel(nu_diff)
idx = np.argsort(nu_diff)
nu_diff = nu_diff[idx]

yy = np.ravel(yy)[idx]
print(nu_diff.shape)

p0 = [1., 0., 5.]
p1, var_matrix = curve_fit(sinc, nu_diff, yy, p0)
print(p1)

A1, mu1, sigma1 = p1
```

```{python slideshow={'slide_type': 'slide'}}
plt.figure()
#for i in range(22):
#    color = new_cmap(1 - i/22)
#    plt.plot((_nusrec_ - df['nu_in'][i]), df.loc[i][1:], 'o', color=color)
plt.plot(nu_diff, yy, '.', color='k')

xxx = np.linspace(-30, 30, 1000)

plt.plot(xxx, sinc(xxx, A1, mu1, sigma1), color='r')
plt.xlabel(r'$\nu - \nu_{in}$ [GHz]')
plt.ylabel(r'$I_{out}$')
# plt.xlim(-2, 2)
```

<!-- #region slideshow={"slide_type": "notes"} -->
I think this is the good representation for the FPSF. I do not think we need to divide by $\Delta_\nu$.
<!-- #endregion -->

```{python}
c = 3e8
lambda_diff = np.zeros((22, 4))
yy = np.zeros((22, 4))
for i in range(22):
    lambda_diff[i, :] = (c/_nusrec_/1e6- c/df['nu_in'][i]/1e6) # mm  
    yy[i, :] = df.loc[i][1:]
    
lambda_diff = np.ravel(lambda_diff)
idx = np.argsort(lambda_diff)
lambda_diff = lambda_diff[idx]


yy = np.ravel(yy)[idx]
print(lambda_diff.shape)

p0 = [1., 0., 0.1]
p1, var_matrix = curve_fit(sinc, lambda_diff, yy, p0)
print(p1)

A1, mu1, sigma1 = p1

plt.figure()
#for i in range(22):
#    color = new_cmap(1 - i/22)
#    plt.plot((_nusrec_ - df['nu_in'][i]), df.loc[i][1:], 'o', color=color)
plt.plot(lambda_diff, yy, '.', color='k')

xxx = np.linspace(-0.4, 0.4, 1000)

plt.plot(xxx, sinc(xxx, A1, mu1, sigma1), color='r')
plt.xlabel(r'$\lambda - \lambda_{in}$ [mm]')
plt.ylabel(r'$I_{out}$')
```

#### Spline fitting (JC method)

```{python}
import numpy as np
from pylab import *
from scipy import interpolate

class MySplineFitting:
    def __init__(self,xin,yin,covarin,nbspl,logspace=False):
        # input parameters
        self.x=xin
        self.y=yin
        self.nbspl=nbspl
        covar=covarin
        if np.size(np.shape(covarin)) == 1:
            err=covarin
            covar=np.zeros((np.size(err),np.size(err)))
            covar[np.arange(np.size(err)),np.arange(np.size(err))]=err**2
        
        self.covar=covar
        self.invcovar=np.linalg.inv(covar)
        
        # Prepare splines
        xspl=np.linspace(np.min(self.x),np.max(self.x),nbspl)
        if logspace==True: xspl=np.logspace(np.log10(np.min(self.x)),np.log10(np.max(self.x)),nbspl)
        self.xspl=xspl
        F=np.zeros((np.size(xin),nbspl))
        self.F=F
        for i in np.arange(nbspl):
            self.F[:,i]=self.get_spline_tofit(xspl,i,xin)
        
        # solution of the chi square
        ft_cinv_y=np.dot(np.transpose(F),np.dot(self.invcovar,self.y))
        covout=np.linalg.inv(np.dot(np.transpose(F),np.dot(self.invcovar,F)))
        alpha=np.dot(covout,ft_cinv_y)
        fitted=np.dot(F,alpha)
        
        # output
        self.residuals=self.y-fitted
        self.chi2=np.dot(np.transpose(self.residuals), np.dot(self.invcovar, self.residuals))
        self.ndf=np.size(xin)-np.size(alpha)
        self.alpha=alpha
        self.covout=covout
        self.dalpha=np.sqrt(np.diagonal(covout))
    
    def __call__(self,x):
        theF=np.zeros((np.size(x),self.nbspl))
        for i in np.arange(self.nbspl): theF[:,i]=self.get_spline_tofit(self.xspl,i,x)
        return(dot(theF,self.alpha))

    def with_alpha(self,x,alpha):
        theF=np.zeros((np.size(x),self.nbspl))
        for i in np.arange(self.nbspl): theF[:,i]=self.get_spline_tofit(self.xspl,i,x)
        return(dot(theF,alpha))
            
    def get_spline_tofit(self,xspline,index,xx):
        yspline=zeros(np.size(xspline))
        yspline[index]=1.
        tck=interpolate.splrep(xspline,yspline)
        yy=interpolate.splev(xx,tck,der=0)
        return(yy)
```

```{python}
# Let's put all the point in 1D array:
xx = np.zeros((22, 4))
yy = np.zeros((22, 4))
for i in range(22):
    xx[i, :] = (_nusrec_ - df['nu_in'][i])
    yy[i, :] = df.loc[i][1:]
xx = np.ravel(xx)
yy = np.ravel(yy)

# Spline fitting
nbspl = 13
myspl = MySplineFitting(xx, yy, np.ones(len(xx)),nbspl)


plt.figure(figsize=(8, 6))
xvals = np.linspace(np.min(xx), np.max(xx), 1000)
plt.plot(xx, yy/np.max(myspl(xvals)), 'o', color='b', label='Data')
plt.plot(xvals, myspl(xvals)/np.max(myspl(xvals)), 'r', label='Spline fitting')

P = 20
nu0 = 150
sigma_expected = nu0/((P-1) * 2.355)
print(sigma_expected)
plt.plot(xvals, np.exp(-0.5*xvals**2/(sigma_expected**2)), label='Expected resolution')
halfwidth = np.diff(_nusedge_)/2
plt.axvspan(-halfwidth[3],halfwidth[3],color='k',alpha=0.2)
plt.grid()
plt.xlabel(r'$\nu - \nu_{in}$ [GHz]')
plt.ylabel(r'Synthetic FPSF with 4 sub-bands')
plt.legend()
plt.tight_layout()
# plt.savefig('/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_plot/FPSF.pdf')
```

<!-- #region slideshow={"slide_type": "slide"} -->
## Comparison to the measurement

This is completely wrong, the simulations were done for the FI and the measurements are for the TD... I think it works by chance, the normalization on the measurement is tricky because we only have 4 points. It is not easy to superimpose both.  

### 4 bands
In the lab, the monochromatic point source is tuned at $\nu_{in} = 150$ GHz and we have reconstructed 4 bands.
We measure the amplitude in the central pixel for each sub-band in order to get the spectrum.

We fit a gaussian model with 4 parameters: $$ G = p_0 + p_1 \times \exp{\frac{-0.5 (x-p_2)^2}{p_3^2}} $$
- $p_0$ => Offset
- $p_1$ => Amplitude
- $p_2$ => Mean
- $p_3$ => Sigma

The fit offset is negative

We normalize the data by the height of the Gaussian (Maximum - offset).

Here are the normalized data we obtained with 4 bands:
<!-- #endregion -->

```{python slideshow={'slide_type': 'fragment'}}
measure_4bands = array([-0.14056635,  0.2982812 ,  0.55715316, -0.15771509])
yerr_4bands = array([0.17112118, 0.12995618, 0.1863555 , 0.12754958])
xerr_4bands = array([4.25540829, 4.53134733, 4.82517946, 5.13806492])
```

<!-- #region slideshow={"slide_type": "slide"} -->
This is completely similar to the simulation done by Martin with $\nu_{in}=150$ GHz (index 12). Let's plot this simulation. This is done in the left plot.

To relate this plot to the previous ones (first plots as a function of $\nu_{in}$), here we have selected the 4 points at 150 GHz, marked with the black vertical line.

On the right plot, we center the complete FPSF on $\nu_{in}=150$ GHz.
<!-- #endregion -->

```{python slideshow={'slide_type': 'subslide'}}
fig, axs = plt.subplots(1, 2, figsize=(10, 5))
ax1, ax2 = np.ravel(axs)
ax1.errorbar(_nusrec_, measure_4bands, xerr=xerr_4bands, yerr=yerr_4bands, fmt='ro', 
             label=r'Measurement 4 bands $\nu_{in}=150$ GHz')
ax1.plot(_nusrec_, df.loc[12][1:], 'o', color=(0.0, 1.0, 0.570955250040116, 1.0), label=r'Simulation with $\nu_{in}=150$ GHz')
ax1.grid()
ax1.set_xlabel(r'$\nu$ [GHz]')
ax1.set_ylabel(r'$I_{out}$')
ax1.legend()

for i in range(nsimu):
    color = new_cmap(1 - i/nsimu)
    if i == 12:
        ax2.plot((_nusrec_ - df['nu_in'][i])+150, df.loc[i][1:], 'o', color=color)
    else:
        ax2.plot((_nusrec_ - df['nu_in'][i])+150, df.loc[i][1:], 'o', color=color)

ax2.errorbar(_nusrec_, measure_4bands, xerr=xerr_4bands, yerr=yerr_4bands, fmt='ro', label=r'Measurement with $\nu_{in}=150$ GHz')
ax2.set_xlabel(r'$(\nu - \nu_{in} + 150)$ [GHz]')
ax2.set_ylabel(r'$I_{out}$')
ax2.legend()
fig.tight_layout()
```




### 5 bands
With real data, we also reconstructed 5 bands. Let's try to superimpose.
It is a bit more difficult. I am not sure it makes sens to do that, the FPSF may depend on the number of sub-bands...

```{python}
nusrec_5bands = array([134.63280448, 141.57278853, 148.8705114 , 156.54441361, 164.61388627])
measure_5bands = [-0.21088738,  0.20660622,  0.5078612,   0.35812012, -0.18409084]
yerr_5bands = [0.2309525,  0.12816038, 0.19878606, 0.16506726, 0.17398308]
xerr_5bands = array([3.38280448, 3.55717958, 3.74054328, 3.93335893, 4.13611373])
```

```{python}
fig, axs = plt.subplots(1, 2, figsize=(9, 4))
ax1, ax2 = np.ravel(axs)
ax1.errorbar(nusrec_5bands, measure_5bands, xerr=xerr_5bands, yerr=yerr_5bands, fmt='go', 
             label=r'Measurement 5 bands $\nu_{in}=150$ GHz')
ax1.plot(_nusrec_, df.loc[12][1:], 'bo', label=r'Simulation with $\nu_{in}=150$ GHz')
ax1.grid()
ax1.set_xlabel(r'$\nu$ [GHz]')
ax1.set_ylabel(r'$I_{out}$')
ax1.legend()

for i in range(22):
    color = cmap(1 - i/30)
    
    ax2.plot((_nusrec_ - df['nu_in'][i])+150, df.loc[i][1:], 'o', color=color)
ax2.errorbar(nusrec_5bands, measure_5bands, xerr=xerr_5bands, yerr=yerr_5bands, fmt='go', 
         label=r'Measurement 5 bands $\nu_{in}=150$ GHz')
ax2.set_xlabel(r'$(\nu - \nu_{in} + 150)$ [GHz]')
ax2.set_ylabel(r'$I_{out}$')
ax2.legend()
fig.tight_layout()
```

```{python}

```
