---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Fast simulation spectroimaging MC

Make a MC with FastSim and get covariance matrices for the power spectrum.

```{python}
# %matplotlib inline

import glob
import healpy as hp
import numpy as np
import matplotlib.pyplot as plt
import pickle


# Specific qubic modules
from qubicpack.utilities import Qubic_DataDir
from pysimulators import FitsArray
import pysm
import qubic
from qubic import QubicSkySim as qss

from qubic import NamasterLib as nam
from qubic.polyacquisition import compute_freq
import AnalysisMC as amc


rc('figure', figsize=(16, 10))
rc('font', size=15)
```

```{python}
# Maps obtained with the full pipeline
dirmaps = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/corr_matrices/pourJC/'

global_dir = Qubic_DataDir(datafile='instrument.py', datadir=os.environ['QUBIC_DATADIR'])

dictionary = global_dir + 'dicts/spectroimaging_article.dict'

print(dictionary)
# Dictionary saved during the simulation
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictionary)

```

```{python}
def get_maps_from_louise(directory, nfsub, allreals=False):
    if allreals:
        mappatchfile = glob.glob(directory+'residualspatch_allreals*_nfrecon{}.pkl'.format(nfsub))[0]
    else:
        mappatchfile = glob.glob(directory+'residualspatch*_nfrecon{}.pkl'.format(nfsub))[0]
    
    covfile = glob.glob(directory+'coverage_*_nfrecon{}.pkl'.format(nfsub))[0]
    seenfile = glob.glob(directory+'seenmap_*_nfrecon{}.pkl'.format(nfsub))[0]
    
    residualspatch = pickle.load( open( mappatchfile, "rb" ) )
    seenpix = pickle.load( open( seenfile, "rb" ) )
    covpix = pickle.load( open( covfile, "rb" ) )
    
    nside = 256
    
    if allreals:
        nreals = residualspatch.shape[0]
        residuals_map = np.zeros((nreals, nfsub, 12*nside**2, 3))
        residuals_map[:, :, seenpix, :] = residualspatch
    
    else:
        residuals_map = np.zeros((nfsub, 12*nside**2, 3))
        residuals_map[:, seenpix, :] = residualspatch

    return residuals_map, covpix, seenpix
```

```{python}
# Input sky
seed = None
sky_config = {'cmb': seed}
Qubic_sky = qss.Qubic_sky(sky_config, d)

x0 = Qubic_sky.get_simple_sky_map()
x0.shape

```

```{python}
# With 1 realisation only
all_nfrecon = [1, 2, 3, 4, 5, 8]
allsignoise = [[88.],
                [88., 95.],
                [88., 81., 98.],
                [88., 66., 64., 95.],
                [88., 62., 61., 64., 99.],
                [88., 62., 59., 59., 61., 63., 65., 95.]]
               
nfrecon = 5

index = [i for i, x in enumerate(all_nfrecon) if x == nfrecon][0]

signoise = allsignoise[index]

maps, coverage, seenmap = get_maps_from_louise(dirmaps, nfrecon)

cI, cQ, cU, fitcov, noise_norm = qss.get_cov_nunu(maps, coverage)
corr_mats = [cI, cQ/2, cU/2]

# Create maps with the noise corelation we want
myfitcovs = []
for isub in range(nfrecon):
    xx, yyfs, fitcov = qss.get_noise_invcov_profile(maps[isub, :, :], coverage, 
                                                 label='Input Map {}'.format(index+1), fit=True, norm=False,
                                                 allstokes=True, doplot=False)
    myfitcovs.append(fitcov)

# Good Cls
clth = pickle.load(open( global_dir + '/doc/FastSimulator/Data/cl_corr_noise_nersc200k.pk', "rb" ) )
alpha = 4.5 # See notebook called "2pt-Correlation Function" for an empirical explanation of alpha
clth = (clth -1 ) * alpha + 1
    
new_sub_maps = Qubic_sky.create_noise_maps(signoise, coverage, nsub=nfrecon,
                                            effective_variance_invcov=myfitcovs,
                                            clnoise=clth, sub_bands_cov=[cI, cQ, cU], verbose=False)
print(np.shape(new_sub_maps))

# Reshape in case just 1 band
if nfrecon == 1:
    new_sub_maps = np.reshape(new_sub_maps, (1, 12*d['nside']**2, 3))
print(np.shape(new_sub_maps))

# Check we have the good correlations
for isub in range(nfrecon):
    figure()
    xx, yyfs, fitcov = qss.get_noise_invcov_profile(new_sub_maps[isub, :, :], 
                                                    coverage, 
                                                     label='FastSim sub={}/{}'.format(isub+1, nfrecon), 
                                                    fit=False, norm=False,
                                                 allstokes=False, doplot=True)
    plt.plot(myfitcovs[isub][0,:], 
         np.sqrt(myfitcovs[isub][1,:]), 
         label='End-To-End Fit sub={}/{}'.format(isub+1, nfrecon))
    plt.legend(fontsize=9)

cInew, cQnew, cUnew, fitcov, noise_norm = qss.get_cov_nunu(new_sub_maps, coverage)
new_corr_mats = [cInew, cQnew/2, cUnew/2]

figure()
stn = ['I','Q/2', 'U/2']
mini = np.min(np.array(corr_mats))
maxi = np.max(np.array(corr_mats))
for s in range(3):
    subplot(2,3,1+s)
    imshow(corr_mats[s], vmin=mini, vmax=maxi)
    colorbar(orientation='horizontal')
    title('End-To-End Cov {} nsub={}'.format(stn[s], nfrecon))
    
    subplot(2,3,4+s)
    imshow(new_corr_mats[s], vmin=mini, vmax=maxi)
    colorbar(orientation='horizontal')
    title('FastSim Cov {} nsub={}'.format(stn[s],nfrecon))


```

```{python}
# With all realisations
all_nfrecon = [1, 2, 3, 4, 5, 8]
allsignoise = [[88.],
                [88., 95.],
                [88., 81., 98.],
                [88., 66., 64., 95.],
                [88., 62., 61., 64., 99.],
                [88., 62., 59., 59., 61., 63., 65., 95.]]
               
nfrecon = 5

index = [i for i, x in enumerate(all_nfrecon) if x == nfrecon][0]

signoise = allsignoise[index]


maps, coverage, seenmap = get_maps_from_louise(dirmaps, nfrecon, allreals=True)
print(maps.shape)
nreals = maps.shape[0]

# Compute the covariance matrices from maps
allcI = np.zeros((nreals, nfrecon, nfrecon))
allcU = np.zeros_like(allcI)
allcQ = np.zeros_like(allcI)

for r in range(nreals):
    allcI[r], allcQ[r], allcU[r], _, _ = qss.get_cov_nunu(maps[r], coverage)

cI = np.mean(allcI, axis=0)
cQ = np.mean(allcQ, axis=0)
cU = np.mean(allcU, axis=0)

# Get fitcov for each subband (from 1st realisation)
myfitcovs = []
for isub in range(nfrecon):
    xx, yyfs, fitcov = qss.get_noise_invcov_profile(maps[0, isub, :, :], coverage, 
                                                 label='Input Map {}'.format(index+1), fit=True, norm=False,
                                                 allstokes=True, doplot=False)
    myfitcovs.append(fitcov)

# # Good Cls
# clth = pickle.load(open( global_dir + '/doc/FastSimulator/Data/cl_corr_noise_nersc200k.pk', "rb" ) )
# alpha = 4.5 # See notebook called "2pt-Correlation Function" for an empirical explanation of alpha
# clth = (clth -1 ) * alpha + 1

new_sub_maps = Qubic_sky.create_noise_maps(signoise, coverage, nsub=nfrecon,
                                            effective_variance_invcov=myfitcovs,
                                            clnoise=None, sub_bands_cov=[cI, cQ, cU], verbose=False)
print(np.shape(new_sub_maps))

# Reshape in case just 1 band
if nfrecon == 1:
    new_sub_maps = np.reshape(new_sub_maps, (1, 12*d['nside']**2, 3))
print(np.shape(new_sub_maps))

# Check we have the good correlations
for isub in range(nfrecon):
    figure()
    xx, yyfs, fitcov = qss.get_noise_invcov_profile(new_sub_maps[isub, :, :], 
                                                    coverage, 
                                                     label='FastSim sub={}/{}'.format(isub+1, nfrecon), 
                                                    fit=False, norm=False,
                                                 allstokes=False, doplot=True)
    plt.plot(myfitcovs[isub][0,:], 
             np.sqrt(myfitcovs[isub][1,:]), 
             label='End-To-End Fit sub={}/{}'.format(isub+1, nfrecon))
    plt.legend(fontsize=9)

cInew, cQnew, cUnew, fitcov, noise_norm = qss.get_cov_nunu(new_sub_maps, coverage)

# For the plot
corr_mats = [cI, cQ/2, cU/2]

new_corr_mats = [cInew, cQnew/2, cUnew/2]

figure()
stn = ['I','Q/2', 'U/2']
mini = np.min(np.array(corr_mats))
maxi = np.max(np.array(corr_mats))
for s in range(3):
    subplot(2,3,1+s)
    imshow(corr_mats[s], vmin=mini, vmax=maxi)
    colorbar(orientation='horizontal')
    title('End-To-End Cov {} nsub={}'.format(stn[s], nfrecon))
    
    subplot(2,3,4+s)
    imshow(new_corr_mats[s], vmin=mini, vmax=maxi)
    colorbar(orientation='horizontal')
    title('FastSim Cov {} nsub={}'.format(stn[s],nfrecon))

```

```{python}
# Make many realisations
nreals = 50
npix = 12 * d['nside']**2

maps_recon = np.zeros((nreals, nfrecon, npix, 3))
for i in range(nreals):
    maps_recon[i] = Qubic_sky.create_noise_maps(signoise, coverage, nsub=nfrecon,
                                            effective_variance_invcov=myfitcovs,
                                            clnoise=None, sub_bands_cov=[cI, cQ, cU], verbose=False)

print(maps_recon[0, 0, seenmap, 0])
print(maps_recon[1, 0, seenmap, 0])
```

```{python}
hp.mollview(maps_recon[0, 0, :, 0])
```

### Power spectrum with Namaster

```{python}
2*256-1
```

```{python}
# Create a Namaster object
lmin = 40
lmax = 2 * d['nside'] - 1
delta_ell = 30
print('lmin', lmin)
print('lmax', lmax)
print('delta ell', delta_ell)

mask = np.zeros(12 * d['nside']**2)
mask[seenmap] = 1

Namaster = nam.Namaster(mask, lmin=lmin, lmax=lmax, delta_ell=delta_ell)

# Make a mask
mask_apo = Namaster.get_apodized_mask()
hp.mollview(mask_apo)

# Binning
ell_binned, b = Namaster.get_binning(d['nside'])
nbins = len(ell_binned)
print('nbins:', nbins)
print('ell binned:', ell_binned)

```

### Auto spectrum

```{python}
# Auto spectrum
w = None

real = 0
cells_recon = np.zeros((nfrecon, nbins, 4))
# Get spectra
for isub in range(nfrecon):
    maps = maps_recon[real, isub, :, :] #+ x0[isub, :, :]
    leff, cells_recon[isub, :, :], w = Namaster.get_spectra(maps.T, mask_apo, w=w,
                                          purify_e=True, 
                                          purify_b=False, 
                                          beam_correction=None,
                                          pixwin_correction=True)
  
```

```{python}
import matplotlib.colors as mcolors
mcolors.TABLEAU_COLORS.keys()

colorlist = list(mcolors.TABLEAU_COLORS.keys())
```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']
# with plt.xkcd():
rc('figure', figsize=(12, 8))

fig, axs = plt.subplots(2, 2)
axs = axs.ravel()

color = ['b', 'r', 'g', 'k', 'y', 'orange', 'brown', 'purple']
for i in range(4):
    ax = axs[i]
    for isub in range(nfrecon): 
        ax.plot(leff[:], cells_recon[isub, :, i],'o', color=colorlist[isub], 
                 label='Recon {}'.format(isub))
    ax.set_xlabel('$\\ell$')
    ax.set_ylabel('$D_\\ell$')

    ax.set_title(clnames[i])

plt.tight_layout()
ax.legend(fontsize=8, loc='right')
```

### Cross sprectum

```{python}
# from itertools import combinations

# ncross = nreals * (nreals - 1) // 2
ncross = nreals // 2
print(nbins, ncross)
cells_cross = np.zeros((ncross, nfrecon, nbins, 4))
cells_conv = np.zeros((ncross, nfrecon, nbins, 4))

# Get spectra
w = None
for isub in range(nfrecon):
    print('isub:', isub)
    cross = 0
#     for c in combinations(np.arange(5), 2):
    for c1 in range(0, nreals-1, 2): # do not mix pairs to avoid correlation 
        c2 = c1 + 1 
        c = (c1, c2)
        print(c)
        map1 = maps_recon[c[0], isub, :, :] #+ x0[isub, :, :]
        map2 = maps_recon[c[1], isub, :, :] #+ x0[isub, :, :]
        leff, cells_cross[cross, isub, :, :], w = Namaster.get_spectra(map1.T, 
                                                                      mask_apo, 
                                                                      map2.T,
                                                                      w=w,
                                                                      purify_e=True, 
                                                                      purify_b=False, 
                                                                      beam_correction=None,
                                                                      pixwin_correction=True)
        cross += 1     
```

```{python}
# Average over the cross_spectrum
cross_mean = np.mean(cells_cross, axis=0)
cross_std = np.std(cells_cross, axis=0)
print(cross_mean.shape)


print(cells_cross[:, 0, 0, 0])
```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']

rc('figure', figsize=(12, 8))

fig, axs = plt.subplots(2, 2)
axs = axs.ravel()

for i in range(4):
    ax = axs[i]
    for isub in range(nfrecon):
        ax.errorbar(leff[:], cross_mean[isub, :, i],
                    yerr=cross_std[isub, :, i] * np.sqrt(2),
                    marker='o', color=colorlist[isub], linestyle='none', 
                    label='Recon cross {}'.format(isub))
    
    ax.axhline(y=0, color='k', ls='--')
    ax.set_xlabel('$\\ell$')
    ax.set_ylabel('$D_\\ell$')
#     ax.set_yscale('log')
    ax.set_title(clnames[i])
    ax.legend(fontsize=8, loc='upper left')

plt.tight_layout()
    
```

### Covariance between bands per bin in the spectrum

```{python}
cov = np.zeros((nfrecon, nfrecon, 4, nbins))
corr = np.zeros_like(cov)
for b in range(nbins):
    for s in range(4):
        c = np.cov(cells_cross[:, :, b, s].T)
        cov[:, :, s, b] = c
        corr[:, :, s, b] = amc.cov2corr(c)
        
```

```{python}
plt.figure(figsize=(20, 200))
for b in range(nbins):
    for s in range(4):
        plt.subplot(nbins, 4, b*4 + s+1)
        plt.imshow(cov[:, :, s, b])
        plt.title(clnames[s] + ' - bin {}'.format(b))
        plt.colorbar(orientation='horizontal', fraction=0.1)
        
```

```{python}
plt.figure(figsize=(20, 200))
for b in range(nbins):
    for s in range(4):
        plt.subplot(nbins, 4, b*4 + s+1)
        plt.imshow(corr[:, :, s, b])
        plt.title(clnames[s] + ' - bin {}'.format(b))
        plt.colorbar(orientation='horizontal', fraction=0.1)
        
```

```{python}
# Average correlation matrices over bins
corr_avg = np.mean(corr, axis=3)
for s in range(4):
    plt.subplot(1, 4, s+1)
    plt.imshow(corr_avg[:, :, s])
    plt.title(clnames[s] + ' Avg')
    plt.colorbar(orientation='horizontal', fraction=0.1)
        
```

### Go to Cp_prime

Not sure it is useful because if we have many realisations (easy with Fast Simulator), we can use directly Cp to average the subbands. 

```{python}
# Cp_prime over bins (normalisation by the first term)
N00, cov_prime00 = amc.Cp2Cp_prime(cov, verbose=True)

for s in range(4):
    plt.subplot(1, 4, s+1)
    plt.imshow(cov_prime00[:, :, s, 0])
    plt.title(clnames[s] + ' Avg')
    plt.colorbar(orientation='horizontal', fraction=0.1)
 
```

```{python}
# Cp_prime over bins (normalisation by the diagonal)
N, cov_prime = amc.Cp2Cp_prime_viaCorr(cov, verbose=True)

for s in range(4):
    plt.subplot(1, 4, s+1)
    plt.imshow(cov_prime[:, :, s, 0])
    plt.title(clnames[s] + ' Avg')
    plt.colorbar(orientation='horizontal', fraction=0.1)
 
```

### Weighted average of the subbands

I don't know if it is interesting to do that.

```{python}
# Using directly cov
weighted_av, sig2 = amc.make_weighted_av(cells_cross, cov, verbose=True)

# Using directly cov_prime00
weighted_av00, sig200 = amc.make_weighted_av(cells_cross, cov_prime00, verbose=True)

# Using directly cov_prime
weighted_avprime, sig2prime = amc.make_weighted_av(cells_cross, cov_prime, verbose=True)
```

```{python}
weighted_av.shape
```

### Big covariance matrix mixing TT, EE, BB, TE 

```{python}
# nreal, nfrec, npix, nstk

cells_cross.shape
```

```{python}
bigcov, bigcorr = amc.get_covcorr_patch(cells_cross, stokesjoint=True, doplot=False)
```

```{python}
plt.figure(figsize=(20, 200))
for b in range(nbins):
    
    plt.subplot(nbins, 2, b*2 +1)
    plt.imshow(bigcov[:, :, b])
    plt.title('Covariance - bin {}'.format(b))
    plt.colorbar()
    
    plt.subplot(nbins, 2, b*2 +2)
    plt.imshow(bigcorr[:, :, b])
    plt.title('Correlation - bin {}'.format(b))
    plt.colorbar()
```

```{python}
labs = []
for s in range(4):
    for i in range(nfrecon):
        labs.append(clnames[s]+'{}'.format(i))
        
print(labs)

plt.xticks(np.arange(len(labs)), labs)
plt.yticks(np.arange(len(labs)), labs)

for s in range(nfrecon):
    plt.axhline(y=(s+1)*nfrecon-0.5, lw=3, color='r')
    plt.axvline(x=(s+1)*nfrecon-0.5, lw=3, color='r')

plt.imshow(np.mean(bigcorr, axis=2))
plt.title('Correlation averaged over bin')
plt.colorbar()
```

### Covariance matrix between bins

```{python}
# We have to swith bins and (TT, EE, BB, TE)
print(cells_cross.shape)
cells_cross_reshape = np.moveaxis(cells_cross, [1, 2, 3], [3, 1, 2])
cells_cross_reshape.shape
```

```{python}
covbinband, corrbinband = amc.get_covcorr_patch(cells_cross_reshape, stokesjoint=True, doplot=False)

print(covbinband.shape)
```

```{python}
ispectre = 2
labsx,labsy = [], []
for f in range(nfrecon):
    labsx.append('f{}b0'.format(f))
    for s in range(nbins):
        labsy.append('f{}b{}'.format(f,s))
        
print(labs)
plt.figure(figsize=(30, 30))
plt.yticks(np.arange(len(labs)), labsy)
plt.xticks(np.arange(0, nbins*nfrecon, nbins), labsx)

for s in range(nfrecon-1):
    plt.axhline(y=(s+1)*nbins-0.5, lw=3, color='r')
    plt.axvline(x=(s+1)*nbins-0.5, lw=3, color='r')

plt.imshow(covbinband[:, :, ispectre])
plt.title('Covariance matrix (nfreq*nbins)x(nfreq*nbins) for {} spectrum'.format(clnames[ispectre]))
plt.colorbar()
```

```{python}
ispectre = 2
labsx,labsy = [], []
for f in range(nfrecon):
    labsx.append('f{}b0'.format(f))
    for s in range(nbins):
        labsy.append('f{}b{}'.format(f,s))
        
print(labs)
plt.figure(figsize=(30, 30))
plt.yticks(np.arange(len(labs)), labsy)
plt.xticks(np.arange(0, nbins*nfrecon, nbins), labsx)

for s in range(nfrecon-1):
    plt.axhline(y=(s+1)*nbins-0.5, lw=3, color='r')
    plt.axvline(x=(s+1)*nbins-0.5, lw=3, color='r')

plt.imshow(corrbinband[:, :, ispectre])
plt.title('Correlation matrix (nfreq*nbins)x(nfreq*nbins) for {} spectrum'.format(clnames[ispectre]))
plt.colorbar()
```

```{python}
qss.random_string(10)
```

```{python}

```
