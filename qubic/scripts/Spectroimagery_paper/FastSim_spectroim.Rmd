---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Fast simulation with spectroimaging

Make a MC with FastSim and get power spectra.

```{python}
# %matplotlib inline

import glob
import healpy as hp
import numpy as np
import matplotlib.pyplot as plt
import pickle
from itertools import combinations, combinations_with_replacement


# Specific qubic modules
from qubicpack.utilities import Qubic_DataDir
from pysimulators import FitsArray
import pysm
import qubic
from qubic import camb_interface as qc
from qubic import QubicSkySim as qss

from qubic import NamasterLib as nam
from qubic.polyacquisition import compute_freq
import AnalysisMC as amc


rc('figure', figsize=(16, 10))
rc('font', size=15)
```

```{python}
import matplotlib.colors as mcolors
mcolors.TABLEAU_COLORS.keys()

colorlist = list(mcolors.TABLEAU_COLORS.keys())
```

```{python}
### Initialize
global_dir = Qubic_DataDir(datafile='instrument.py', datadir=os.environ['QUBIC_DATADIR'])
print(global_dir)
```

```{python}
# Dictionary
config = 'FI-150'
dictfilename = global_dir + '/doc/FastSimulator/FastSimDemo_{}.dict'.format(config)
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictfilename)

d['nside'] = 256
d['filter_nu'] = 220e9

# Number of bands
nbands = 3
d['nf_recon'] = nbands
d['nf_sub'] = nbands

# Make a sky with CMB
# Calculate CMB spectra with CAMB
lmax = 2 * d['nside'] - 1
ell, totDL, unlensedDL = qc.get_camb_Dl(r=0., lmax=lmax)

# Specify the CMB description in a dictionary
cmb_dict = {'CAMBSpectra':totDL, 'ell':ell}

# sky_config = {'cmb': cmb_dict}
sky_config = {'dust': 'd1', 'cmb': cmb_dict}

Qubic_sky = qss.Qubic_sky(sky_config, d)
# maps are not convolved at the QUBIC resolution => Beam_correction=None when you make Cls
# cmb_map = Qubic_sky.get_simple_sky_map()

# Maps are convolved at the QUBIC resolution in the band => Beam_correction=True when you make Cls
dust_map = Qubic_sky.get_fullsky_convolved_maps(FWHMdeg=None, verbose=True)

```

```{python}
dust_map.shape
```

```{python}
# input_Dl = Qubic_sky.input_cmb_spectra
# input_ell = np.arange(np.shape(input_Dl)[0])
```

```{python}
# Number of bands for TOD making (instrument resolution)
d['nf_sub'] = 15

# Pointing
# Fix the same number of pointings, like the full pipeline simulation used for Fast simulator
d['npointings'] = 10000 
# You can also put it directly in the dictionary 
p = qubic.get_pointing(d)

# Scene
# Make sure the center of the patch is well define in the dictionary:
# RA_center= 0. #deg
# DEC_center=-57. #deg
s = qubic.QubicScene(d)

# Qubic Instrument
q = qubic.QubicMultibandInstrument(d)

# number of sub frequencies for reconstruction
_, nus_edge, _, _, _, _ = qubic.compute_freq(150, d['nf_sub'])

# Operator for Maps Reconstruction
a = qubic.QubicMultibandAcquisition(q, p, s, d, nus_edge)

# Coverage
qubic_coveragee = a.get_coverage()
qubic_coverage = np.sum(qubic_coverage, axis=0)# Sum the bands
qubic_coverage /= np.max(qubic_coverage)# Normalize by the max

hp.mollview(qubic_coverage)
```

```{python}
# import pickle
# DataFastSimCoverage = pickle.load(open(global_dir + '/doc/FastSimulator/Data/DataFastSimulator_FI150_coverage.pkl', "rb"))
# qubic_coverage = DataFastSimCoverage['coverage']
# hp.mollview(qubic_coverage)
```

```{python}
# Getting noise realisations with FastSimulator
nreals = 10
npix = 12 * d['nside']**2
noisemaps = np.zeros((nreals, nbands, npix, 3))

for r in range(nreals):
    noisemaps[r, ...], coverage = Qubic_sky.get_partial_sky_maps_withnoise(coverage=None,
                                                                           noise_only=True, spatial_noise=True)

# Make maps QUBIC = noise + CMB
qubicmaps = np.zeros_like(noisemaps)
for r in range(nreals):
    qubicmaps[r, ...] = noisemaps[r, ...] + dust_map

unseen = coverage < np.max(coverage) * 0.1
qubicmaps[:, :, unseen, :] = 0.
noisemaps[:, :, unseen, :] = 0.
dust_map[:, unseen, :] = 0.

```

```{python}
Stokes = ['I', 'Q', 'U']
real = 0
band = 0

for s in range(3):
    hp.gnomview(noisemaps[real, band,:,s], reso=20, sub=(3, 3, s+1), 
                title='Noise ' + Stokes[s] + f' Sub {band}')   
    hp.gnomview(dust_map[band,:,s], reso=20, sub=(3, 3, s+3+1), 
                title='CMB ' + Stokes[s] + f' Sub {band}')        
    hp.gnomview(qubicmaps[real, band,:,s], reso=20, sub=(3, 3, s+6+1), 
                title='QUBIC map ' + Stokes[s] + f' Sub {band}')        

```

### Power spectrum with Namaster

```{python}
# Make a Namaster object
lmin = 40
lmax = 2 * d['nside'] - 1
delta_ell = 30

mask = np.zeros(12 * d['nside'] ** 2)
seenmap = np.invert(unseen)
mask[seenmap] = 1
Namaster = nam.Namaster(mask, lmin=lmin, lmax=lmax, delta_ell=delta_ell)
mask_apo = Namaster.get_apodized_mask()
hp.gnomview(mask_apo, reso=20, title='Mask')

ell_binned, b = Namaster.get_binning(d['nside'])
nbins = len(ell_binned)
print('lmin:', lmin)
print('lmax:', lmax)
print('delta_ell:', delta_ell)
print('nbins:', nbins)
print('ell binned:', ell_binned)
print('Fsky: {}'.format(Namaster.fsky))


# Possible combinations between bands
combi = list(combinations_with_replacement(np.arange(nbands), 2))
ncombi = len(combi)
print('combi:', combi)
print('ncombi:', ncombi)


```

```{python}
cross_th = np.zeros((ncombi, nbins, 4))
w = None
for i, (band1, band2) in enumerate(combi):
        print(f'Bands {band1} {band2}')
        map1 = dust_map[band1, :, :]
        map2 = dust_map[band2, :, :]
        leff, cross_th[i, :, :], w = Namaster.get_spectra(map1.T,
                                                                      mask_apo,
                                                                      map2.T,
                                                                      w=w,
                                                                      purify_e=True,
                                                                      purify_b=False,
                                                                      beam_correction=True,
                                                                      pixwin_correction=None)

```

### Cross sprectum for each realisation

For each band, we make a cross spectrum between 2 realisations. This will remove the noise bias. 

```{python}
cross_samereal = np.zeros((nreals, ncombi, nbins, 4))

w = None
for real in range(nreals):
    print(f'\n Real {real}')
    for i, (band1, band2) in enumerate(combi):
        print(f'Bands {band1} {band2}')
        map1 = qubicmaps[real, band1, :, :]
        map2 = qubicmaps[real, band2, :, :]
        leff, cross_samereal[real, i, :, :], w = Namaster.get_spectra(map1.T,
                                                                      mask_apo,
                                                                      map2.T,
                                                                      w=w,
                                                                      purify_e=True,
                                                                      purify_b=False,
                                                                      beam_correction=True,
                                                                      pixwin_correction=None)

```

```{python}
avg_cross_samereal = np.mean(cross_samereal, axis=0)
error_cross_samereal = np.std(cross_samereal, axis=0) * np.sqrt(2)


BBavg_same = avg_cross_samereal[:, :, 2]
BBerror_same = error_cross_samereal[:, :, 2]
```

```{python}
plt.plot(cross_th[0, :, 0])
cross_th.shape
leff
```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']

fig, axs = plt.subplots(2, 2)
axs = axs.ravel()

for s in range(4):
    ax = axs[s]
    for cross in range(ncombi): 
        c = colorlist[cross]
        ax.errorbar(leff, 
                    avg_cross_samereal[cross, :, s],
                    yerr=error_cross_samereal[cross, :, s],
                    fmt='o',
                    color=c,
                    label='cross {}'.format(combi[cross]))
        ax.plot(leff, cross_th[cross, :, s], '--', color=c, label='Input')

    ax.set_xlabel('$\\ell$')
    ax.set_ylabel('$D_\\ell$')

    ax.set_title(clnames[s])
    ax.legend(fontsize=12, loc='upper left')
plt.tight_layout()
```

### Cross sprectum between realisations

For each band, we make a cross spectrum between 2 realisations. This will remove the noise bias. 

```{python}
ncross = nreals // 2
print('ncross:', ncross)
cross_mixreal = np.zeros((ncross, ncombi, nbins, 4))

w = None
cross = 0
for c1 in range(0, nreals - 1, 2):  # do not mix pairs to avoid correlation
    c2 = c1 + 1
    print(f'\n Reals {c1} {c2}')
    
    for i, (band1, band2) in enumerate(combi):
        print(f'Bands {band1} {band2}')
        map1 = qubicmaps[c1, band1, :, :]
        map2 = qubicmaps[c2, band2, :, :]
        leff, cross_mixreal[cross, i, :, :], w = Namaster.get_spectra(map1.T,
                                                                       mask_apo,
                                                                       map2.T,
                                                                       w=w,
                                                                       purify_e=True,
                                                                       purify_b=False,
                                                                       beam_correction=True,
                                                                       pixwin_correction=None)
        
    cross += 1

BBmixreal = cross_mixreal[:, :, :, 2]
```

```{python}
avg_cross_mixreal = np.mean(cross_mixreal, axis=0)
error_cross_mixreal = np.std(cross_mixreal, axis=0) * np.sqrt(2)

BBavg_mix = avg_cross_mixreal[:, :, 2]
BBerror_mix = error_cross_mixreal[:, :, 2]
```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']
fig, axs = plt.subplots(2, 2)
axs = axs.ravel()

for s in range(4):
    ax = axs[s]
    for co in range(ncombi): 
        c = colorlist[co]
        ax.errorbar(leff, 
                    avg_cross_mixreal[co, :, s],
                    yerr=error_cross_mixreal[co, :, s],
                    fmt='o',
                    color=c,
                    label='cross {}'.format(combi[co]))
        ax.plot(leff, cross_th[co, :, s], '--', color=c)
    
    ax.set_xlabel('$\\ell$')
    ax.set_ylabel('$D_\\ell$')

    ax.set_title(clnames[s])
    ax.legend(fontsize=12, loc='best')
plt.tight_layout()
```

```{python}

```

```{python}

```

```{python}
s = 1
for nbin in range(nbins):
    plt.scatter(cls_auto[:, 0, nbin, s], cls_auto[:, 1, nbin, s])
    pval = np.polyfit(cls_auto[:, 0, nbin, s], cls_auto[:, 1, nbin, s], deg=1)
    print(pval)
    x = np.linspace(np.min(cls_auto[:, 0, nbin, s]), np.max(cls_auto[:, 0, nbin, s]), 10)
    plt.plot(x, np.polyval(pval, x))
    plt.title(f'{nbin}')
    plt.grid()
    plt.show()
    plt.xlabel('freq 0')
    plt.ylabel('freq 1')
    
```

```{python}

```
