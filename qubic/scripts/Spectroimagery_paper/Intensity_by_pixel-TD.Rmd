---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Spectroimaging pixel by pixel

Edited by Louise, 18/06/2020

Edited by Martin, 21/06/2020 (implement FastSimulator)

In this notebook, I try to reproduce what Gabriele has done. Spectroimaging on the galaxy center, compare the reconstruction to the input sky pixel by pixel

```{python}
# %matplotlib inline

import os
import sys
import glob

# Specific science modules
import healpy as hp
import matplotlib.pyplot as plt
import numpy as np
import pickle
# Specific qubic modules
import qubic
from qubicpack.utilities import Qubic_DataDir
from qubic import QubicSkySim as qss
from qubic.polyacquisition import compute_freq
from qubic import ReadMC as rmc
from qubic import create_acquisition_operator_REC
plt.rc('text',usetex=False)
plt.rc('font', size=16)
```

Implementing FastSimulator

```{python}
# Dictionary saved during the simulation
global_dir = Qubic_DataDir(datafile='instrument.py', datadir=os.environ['QUBIC_DATADIR'])
#dictfilename = global_dir + '/doc/FastSimulator/FastSimDemo_{}.dict'.format(config)
dictfilename = global_dir + '/dicts/spectroimaging_article.dict'
dFI = qubic.qubicdict.qubicDict()
dFI.read_from_file(dictfilename)
dFI['nf_recon']=5
dFI['photon_noise']=True
dTD=dFI.copy()
dTD['config']='TD'
#dTD['detector_nep']=2.05e-16
dTD['npointings']=10000
```

```{python}
def make_covTD(d):
    pointing = qubic.get_pointing(d)
    q= qubic.QubicMultibandInstrument(d)
    s= qubic.QubicScene(d)
    nf_sub_rec = d['nf_recon']
    _, nus_edge, nus, _, _, _ = qubic.compute_freq(d['filter_nu'] / 1e9, 
                                                   nf_sub_rec, d['filter_relative_bandwidth'])
    arec = qubic.QubicMultibandAcquisition(q, pointing, s, d, nus_edge)
    cov = arec.get_coverage()
    return cov
```

```{python}
QUBICField=False

# Coordinates of the zone observed in the sky
if QUBICField:
    center = qubic.equ2gal(dTD['RA_center'], dTD['DEC_center'])
else:
    center = np.array([0,0]) #galaxy center
    dTD['RA_center'],dTD['DEC_center'] = qubic.gal2equ(center[0],center[1])
    dFI['RA_center'],dFI['DEC_center'] = dTD['RA_center'],dTD['DEC_center'] 
```

```{python}
covTD = make_covTD(dTD)
```

```{python}
#just used to compare, after is defined coverageFI. Depends if cengal is T or F
covFI = np.load(global_dir+'doc/FastSimulator/Data/coverage_nfsub15_nptgs10000_qubicpatch.pk')
```

```{python}
#covnorm=np.zeros_like(covTD)
#for i in range(len(covTD)):
#    seenpix = covTD[i] > (0.1 * np.max(covTD[i]))
#    covnorm[i] = covTD[i] / np.max(covTD[i])
coverageTD = np.sum(covTD, axis=0)# Sum the bands
coverageTD /= np.max(coverageTD)# Normalize by the max
```

```{python}
lacarte=hp.gnomview(coverageTD,rot=center,reso=13,return_projected_map=True, no_plot=True)
lacarteFI=hp.gnomview(covFI,rot=qubic.equ2gal(0,-57),
                      reso=13,return_projected_map=True, no_plot=True)
X,Y=np.meshgrid(range(200), range(200))

fig = plt.figure(figsize=(18,6))
ax = fig.add_subplot(1, 3, 1, projection='3d')
ax.set_title('covTD in galaxy center', fontsize=16)
ax.plot_surface(X,Y, lacarte, cmap=plt.cm.viridis, linewidth=0.2)

ax = fig.add_subplot(1, 3, 2, projection='3d')
ax.set_title('covFI in QUBIC field', fontsize=16)
ax.plot_surface(X,Y, lacarteFI, cmap=plt.cm.viridis, linewidth=0.2)

ax = fig.add_subplot(1, 3, 3, projection='3d')
ax.set_title('Diff = covTD-covFI', fontsize=16)
ax.plot_surface(X,Y, lacarte-lacarteFI, cmap=plt.cm.viridis, linewidth=0.2)
```

```{python}
if QUBICField:
    coverageFI = np.load(global_dir+'doc/FastSimulator/Data/coverage_nfsub15_nptgs10000_qubicpatch.pk')
    center = qubic.equ2gal(dTD['RA_center'], dTD['DEC_center'])
else:
    coverageFI = None
    center = None
```

##### QubicSkySim instanciation
seed = None
sky_config_220 = {'dust': 'd1'}
d220=d.copy()
d220['filter_nu']=220*1e9
d220['nf_recon']=5
Qubic_sky_220 = qss.Qubic_sky(sky_config_220, d220)
auxmaps220, noiseless220, _, _ = Qubic_sky_220.get_partial_sky_maps_withnoise(spatial_noise=False, 
                                                                              coverage=coverage)

```{python}
##### QubicSkySim instanciation
seed = 42#None
sky_config_TD = {'dust': 'd1'}
Qubic_sky_TD = qss.Qubic_sky(sky_config_TD, dTD)
sky_config_FI = {'dust': 'd1'}
Qubic_sky_FI = qss.Qubic_sky(sky_config_FI, dFI)

##### Getting FastSimulator output maps
mcmcmapsTD = []
mcmcmapsTD_FI = []
mcmcmapsTD_FI_nc = []
mcmcmapsFI = []
mcmcnoiseFI=[]
for i in range(15):
    auxmapsTD, maps_noiselessTD, _, coverageTD = \
        Qubic_sky_TD.get_partial_sky_maps_withnoise(spatial_noise=False, coverage=coverageTD)
    print('=== Done (TD) interation #{} ===='.format(i+1))

    auxmapsFI, maps_noiselessFI, noiseFI, coverageFI = \
        Qubic_sky_FI.get_partial_sky_maps_withnoise(spatial_noise=False, coverage=coverageFI)        
    print('=== Done (cmb 220) interation #{} ===='.format(i+1))

    mcmcmapsTD.append(auxmapsTD)
    mcmcmapsFI.append(auxmapsFI)
    mcmcmapsTD_FI_nc.append(maps_noiselessTD+noiseFI*31)
    for ifreq in range(len(noiseFI)):
        fwhmTD = dFI['synthbeam_peak150_fwhm']*150/nus[ifreq]*3 # 3: ratio betwen FI and TD
        noiseFI[ifreq] = hp.smoothing(noiseFI[ifreq].T,fwhm=np.deg2rad(fwhmTD)).T
    mcmcmapsTD_FI.append(maps_noiselessTD+noiseFI*31)
    mcmcnoiseFI.append(noiseFI)

mapsTD, stdTD=np.mean(mcmcmapsTD,axis=0), np.std(mcmcmapsTD,axis=0)
mapsTD_noiseFI,stdTD_nFI = np.mean(mcmcmapsTD_FI,axis=0), np.std(mcmcmapsTD_FI,axis=0)
mapsTD_noiseFI_nc,stdTD_nFI_nc = np.mean(mcmcmapsTD_FI_nc,axis=0), np.std(mcmcmapsTD_FI_nc,axis=0)
mapsFI, stdFI = np.mean(mcmcmapsFI,axis=0), np.std(mcmcmapsFI, axis=0)
noiseFI= np.mean(mcmcnoiseFI,axis=0)
```

Look at the maps... okk..

```{python}
#print(np.shape(maps_qubic), np.shape(maps_noiseless), np.shape(maps_noise), np.shape(coverage))
cov=np.zeros_like(coverageTD,dtype=bool)
covmsk=np.where(coverageTD > 0.01*np.max(coverageTD))
cov[covmsk] = 1
NU = 0
STK = 0
RESO = 15
plt.figure(figsize=(12,8))
hp.gnomview(mapsTD_noiseFI[NU,:,STK], sub=(2,2,1), 
            #max=0.1*np.max(mapsTD_noiseFI[NU,cov,STK]), 
            title='FastSim TD(noiseFI conv)', reso=RESO, rot=center)
hp.gnomview(mapsTD_noiseFI_nc[NU,:,STK], sub=(2,2,2), 
            #max=0.1*np.max(maps_noiselessTD[NU,:,STK]), 
            title='FastSim TD(noiseFI)', reso=RESO, rot=center)
#hp.gnomview(cov, sub=(2,3,3), title='covmsk', reso=RESO, rot=center)

hp.gnomview(mapsFI[NU,:,STK], sub=(2,2,3), title='FastSim FI', reso=RESO, rot=center)
hp.gnomview(maps_noiselessFI[NU,:,STK], sub=(2,2,4), title='noiseless FI', reso=RESO, rot=center)
#hp.gnomview(cov, sub=(2,3,6), title='covmsk', reso=RESO, rot=center)

```

```{python}
_,nus_edge,nus,_,_,_=qubic.compute_freq(dTD['filter_nu']/1e9, dTD['nf_recon'], dTD['filter_relative_bandwidth'] )
#_,nus_edge_in,nus_in,_,_,_=qubic.compute_freq(d['filter_nu']/1e9, d['nf_sub'], 
#                                              d['filter_relative_bandwidth'] )
```

```{python}
#inputmaps = Qubic_sky_dust.get_simple_sky_map()
#inputmaps_cmb = Qubic_sky_cmb.get_simple_sky_map()
#inputmaps = Qubic_sky_dust.get_fullsky_convolved_maps()
```

meanrec=[]
meaninp=[]
stdrec=[]
stdinp=[]
meanfreqcmb=[]
stdfreqcmb=[]
meanconv=[]
stdconv=[]
for i in range(3):
    meanrec.append(np.mean(maps_qubic[i,covmsk,0]))
    meanconv.append(np.mean(maps_noiseless[i,covmsk,0]))
    stdrec.append(np.std(maps_qubic[i,covmsk,0]))
    stdconv.append(np.std(maps_noiseless[i,covmsk,0]))
    meanfreqcmb.append(np.mean(maps_qubic_cmb[i,covmsk,0]))
    stdfreqcmb.append(np.std(maps_qubic_cmb[i,covmsk,0]))

for i in range(len(nus_in)):
    meaninp.append(np.mean(inputmaps[i,covmsk,0]))
    stdinp.append(np.std(inputmaps[i,covmsk,0] ))
    
#plt.yscale('log')
#plt.xscale('log')
#plt.plot(nus, stdrec)
#plt.plot(nus,stdfreqcmb)

```{python}
noiseFIconv = np.zeros_like(noiseFI)
for ifreq in range(len(noiseFI)):
    noiseFIconv[ifreq] = hp.smoothing(noiseFI[ifreq].T, 
                               fwhm = np.deg2rad(dFI['synthbeam_peak150_fwhm']*150/nus[ifreq])   ).T
```

```{python}
IPIX = covmsk[0][11500] #almost center
mctest=True

for j,ipx in enumerate(range(0,24000,3500)):
    fig,ax=plt.subplots(nrows=1,ncols=3,figsize=(16,4),)
    ax=ax.ravel()
    IPIX = covmsk[0][ipx]
    if mctest:
        ax[0].plot(nus, maps_noiselessTD[:,IPIX,0],#yerr=stdFI[:,IPIX,0], 
               'bo-',label='noiseless TD', alpha=0.7)
        ax[0].plot(nus, maps_noiselessFI[:,IPIX,0],#yerr=stdFI[:,IPIX,0], 
               'ro-',label='noiseless FI', alpha=0.7)
        #ax[0].errorbar(nus, maps_noiselessFI[:,IPIX,0],yerr=stdTD_nFI_nc[:,IPIX,0], 
        #       fmt='o-', color='r',label='noiseless FI', alpha=0.7)
        #ax[0].plot(nus, maps_noiselessTD[:,IPIX,0],
        #       'ro-',label='TD noiseless', alpha=0.8)
        #ax[0].plot(nus, maps_noiselessFI[:,IPIX,0],
        #       'bo-',label='FI noiseless', alpha=0.5)
        ax[0].set_title('Dust - TD/FI pix {}'.format(IPIX),fontsize=15)
    ax[0].set_ylabel(r'$I_\nu$ [$\mu$K]',fontsize=15)
    ax[0].set_xlabel(r'$\nu$[GHz]',fontsize=15)
    ax[0].legend(loc='best',fontsize=15)
    ax[0].grid()
    ax[1].cla()
    plt.axes(ax[1])
    hp.gnomview(maps_noiselessTD[0,:,0], reso=15,hold=True,notext=True,title='TD(noiseless)',
                #max=0.1*np.max(maps_qubic[0,:,0]), 
                rot=center)
    hp.projscatter(hp.pix2ang(dTD['nside'],IPIX),marker='+',color='r',)
    plt.axes(ax[2])
    hp.gnomview(maps_noiselessFI[0,:,0], reso=15,hold=True,notext=True,title='FI(noiseless)',
                #max=0.1*np.max(maps_qubic[0,:,0]), 
                rot=center)
    hp.projscatter(hp.pix2ang(dTD['nside'],IPIX),marker='+',color='r',)
    
plt.show()

```

Do same plots averaging and/or computing rms in maps

```{python}
mqTD = mapsTD_noiseFI.copy()
mqFI=mapsFI.copy()
```

```{python}
mqTD_FI = mapsTD_noiseFI_nc.copy()
mqTD = maps_noiselessTD.copy()

dvalsTD=[]
dvalsFI=[]
#mq = maps_qubic
threshold=0.01
fig,ax=plt.subplots(nrows=3,ncols=dTD['nf_recon'],figsize=(12,10),)
for ifreq in range(dTD['nf_recon']):
    #TD(noiseFI)
    auxmap = mqTD_FI[ifreq,:,0]
    auxmap[~cov]=hp.UNSEEN
    auxmap[auxmap>threshold*max(auxmap)] = hp.UNSEEN
    maskTD=np.where(auxmap!=hp.UNSEEN)
    dvalsTD.append(np.sqrt(np.sum(mapsTD_noiseFI_nc[ifreq,maskTD[0],0]**2)/len(maskTD[0]) ))
    ax[0,ifreq].cla()
    plt.axes(ax[0,ifreq])
    hp.gnomview(auxmap, reso=15,hold=True,notext=True,title='{:.1f}GHz'.format(nus[ifreq]),
               min=-10, max=0.2*np.max(mapsTD[ifreq,cov,0]), 
                rot=center )

for ifreq in range(dTD['nf_recon']):
    auxmap = mqTD[ifreq,:,0]
    auxmap[~cov]=hp.UNSEEN
    auxmap[auxmap>threshold*max(auxmap)] = hp.UNSEEN
    maskFI=np.where(auxmap!=hp.UNSEEN)
    dvalsFI.append(np.sqrt(np.sum(maps_noiselessTD[ifreq,maskFI[0],0]**2)/len(maskFI[0]) ))
    ax[2,ifreq].cla()
    plt.axes(ax[2,ifreq])
    hp.gnomview(auxmap, reso=15,hold=True,notext=True,title='{:.1f}GHz'.format(nus[ifreq]),
               min=-10, max=0.2*np.max(mapsFI[ifreq,cov,0]), 
                rot=center )

gs = ax[1,1].get_gridspec()
# remove the underlying axes
for iax in ax[1,0:]:
    iax.remove()
axbig = fig.add_subplot(gs[1,1:-1])
#axbig.set_yscale('log')
axbig.plot(nus, dvalsTD,
       'r-', lw=4,label='TD(FI noise)', alpha=1)
axbig.plot(nus, dvalsFI,
        'g-',lw=4,label='TD (noiseless)' , alpha=1)
axbig.set_ylabel(r'$rms$ [$\mu$K]',)
axbig.set_xlabel(r'$\nu$[GHz]',)
axbig.set_title(r'mask {:.1f}% I$_{{\rm max}}$'.format(threshold*100))
axbig.legend(bbox_to_anchor=(0.83, 0.5, 0.5, 0.5),fontsize=12)
axbig.grid()

```

```{python}
from importlib import reload
reload(qss)
noiseTD, _ = Qubic_sky_TD.get_partial_sky_maps_withnoise(coverage=coverageTD, Nyears=4., verbose=False, 
                                       spatial_noise=False,noise_only=True)
noiseFI, _ = Qubic_sky_FI.get_partial_sky_maps_withnoise(coverage=coverageFI, Nyears=4., verbose=False, 
                                       spatial_noise=False,noise_only=True)
        
```

```{python}
hp.gnomview(noiseTD[0,:,0],rot=center, sub=(121),reso=13)
hp.gnomview(noiseFI[0,:,0],rot=center, sub=(122),reso=13)
```

Test degrading map to recover Louise and Gabriele results..


newnside=8
degqubic_rec = hp.ud_grade(maps_qubic[:,:,0], newnside)
degqubic_conv = hp.ud_grade(maps_noiseless[:,:,0], newnside)

IPIXnew = hp.ang2pix(newnside, hp.pix2ang(d['nside'],IPIX)[0],hp.pix2ang(d['nside'],IPIX)[1])

fig,ax=plt.subplots(nrows=1,ncols=2,figsize=(12,4))
ax[0].plot(nus, degqubic_rec[:,IPIXnew],'ro', label='recon', alpha=0.5)
ax[0].plot(nus, degqubic_conv[:,IPIXnew], 'bo', alpha=0.5,label='convolved')
ax[0].plot(nus_in, inputmaps[:,IPIXnew,0], 'go', label='input')
ax[0].legend()
ax[0].grid()

plt.axes(ax[1])
hp.gnomview(degqubic_rec[0,:], reso=15,hold=True,notext=True,title=' ')
hp.projscatter(hp.pix2ang(newnside,IPIXnew),marker='+',color='r',)


```{python}

```

```{python}

```

### Without FastSimulator

```{python}
nfrecon = 3
datadir = os.environ['DATA_SPECTROIM']
rep = datadir + f'simu_nersc_dust_fullpipeline/nfrecon{nfrecon}/'
print(rep)
dictionary = glob.glob(rep + '/*.dict')[0]
print(dictionary)

# Dictionary saved during the simulation
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictionary)

# Coordinates of the zone observed in the sky
center = qubic.equ2gal(d['RA_center'], d['DEC_center'])

# Number of subbands used during the simulation

nfsub = d['nf_sub']
print('nf_sub = {}, nf_recon = {}'.format(nfsub, nfrecon))

# Get fits files names in a list
fits_noise = np.sort(glob.glob(rep + '*_nfsub{}_nfrecon{}_noiselessFalse*.fits'.format(nfsub, nfrecon), 
                              recursive=True))
fits_noiseless = np.sort(glob.glob(rep + '*_nfsub{}_nfrecon{}_noiselessTrue*.fits'.format(nfsub, nfrecon), 
                              recursive=True))

print(fits_noiseless)
```

```{python}
# Input sky
seed = 42
sky_config = {'dust': 'd1'}
Qubic_sky = qss.Qubic_sky(sky_config, d)
x0 = Qubic_sky.get_simple_sky_map()
print('Input map with shape:', x0.shape)
hp.mollview(x0[2,:,0],rot=center)

Nfreq_edges, nus_edge, nus, deltas, Delta, Nbbands = compute_freq(150, nfsub)
```

```{python}
# Number of noise realisations
nreals = len(fits_noise)
print('nreals = ', nreals)

# Get seen map (observed pixels)
seenmap = rmc.get_seenmap(fits_noiseless[0])
print(seenmap.shape)
thepix_old = np.where(seenmap)[0]

# Number of pixels and nside
npix = len(seenmap)
ns = d['nside']

```

```{python}
np.where(seenmap)
```

```{python}
# Get maps
_, _, nus_rec, _, _, _ = compute_freq(150, nfrecon)

maps_recon = np.empty((nreals, nfrecon, npix, 3))
maps_conv = np.empty((nreals, nfrecon, npix, 3))
for i, real in enumerate(fits_noise):
    maps_recon[i], maps_conv[i], _ = rmc.get_maps(real)

```

```{python}
# Decrease NSIDE
nside_new = 8
seenmap_dgrad = hp.ud_grade(seenmap, nside_new)
thepix = np.where(seenmap_dgrad)[0]
print(thepix)

x0_dgrad = np.zeros((len(nus), 12*nside_new**2, 3))
for nu in range(len(nus)):
    for istk in range(3):
        x0_dgrad[nu, :, istk] = hp.ud_grade(x0[nu, :, istk], nside_new)

hp.mollview(x0_dgrad[0, :, 0]*seenmap_dgrad)

maps_recon_dgrad = np.zeros((nreals, len(nus_rec), 12*nside_new**2, 3))
for real in range(nreals):
    for nu in range(len(nus_rec)):
        for istk in range(3):
            maps_recon_dgrad[real, nu, :, istk] = hp.ud_grade(maps_recon[real, nu, :, istk], nside_new)

maps_conv_dgrad = np.zeros((nreals, len(nus_rec), 12*nside_new**2, 3))
for real in range(nreals):
    for nu in range(len(nus_rec)):
        for istk in range(3):
            maps_conv_dgrad[real, nu, :, istk] = hp.ud_grade(maps_conv[real, nu, :, istk], nside_new)


```

```{python}
len(thepix_old)
```

```{python}
istk = 0
for pix in range(2000, 2020):
    pix = thepix_old[pix]
    plt.figure()

    plt.plot(nus, x0[:, pix, istk], 'go', label='Input sky')
    plt.plot(nus_rec, np.mean(maps_conv[:, :, pix, istk], axis=0), 'bo', label='convolved sky')
    plt.errorbar(nus_rec, np.mean(maps_recon[:, :, pix, istk], axis=0),
                 yerr=np.std(maps_recon[:, :, pix, istk], axis=0), 
                 fmt='o', color='r',
                 label='recon sky')
    plt.legend()
    plt.title('Pixel {}, NSIDE=256'.format(pix))
    plt.xlabel('Frequency [GHz]')
    plt.ylabel('I (µK)')
#     plt.close()
```

```{python}
len(thepix)
```

```{python}
istk = 1
Stokes = ['I', 'Q', 'U']
for i in range(20):
    pix = thepix[i]
    plt.figure(figsize=(15, 4))
    plt.subplot(121)
    plt.plot(nus, x0_dgrad[:, pix, istk], 'go', label='Input sky')
    plt.plot(nus_rec, np.mean(maps_conv_dgrad[:, :, pix, istk], axis=0), 'bo', label='convolved sky')

    plt.errorbar(nus_rec, np.mean(maps_recon_dgrad[:, :, pix, istk], axis=0),
                 yerr=np.std(maps_recon_dgrad[:, :, pix, istk], axis=0), 
                 fmt='o', color='r',
                 label='recon sky')
    plt.legend()
    plt.title('Pixel {}, NSIDE=8, {}'.format(pix, Stokes[istk]))
    plt.xlabel('Frequency [GHz]')
    plt.ylabel('I [µK]')

    x0copie = x0_dgrad[0, :, istk].copy()
    x0copie[pix] = -10
    hp.mollview(x0copie*seenmap_dgrad, sub=(122), title='Pixel {}'.format(pix))


    
```

# Compare input sky and convolution


### Try just with Healpy

```{python}
# Make a sky with dust
nfrecon = 5
d['nside'] = 4
d['nf_sub'] = nfrecon
q = qubic.QubicMultibandInstrument(d)
_, _, nus_rec, _, _, _ = compute_freq(150, nfrecon)


sky_config = {'dust': 'd1'}#, 'cmb': seed} 
Qubic_sky = qss.Qubic_sky(sky_config, d)
sky = Qubic_sky.get_simple_sky_map()

hp.mollview(sky[0, :, 0])

# Go to NSIDE=128
sky128 = np.zeros((nfrecon, 12*128**2, 3))
for i in range(nfrecon):
    for istk in range(3):
        sky128[i, :, istk] = hp.ud_grade(sky[i, :, istk], 128)
    
# Smooth the sky with 
sky_conv = np.zeros_like(sky128)
for i in range(nfrecon):
    freq = q[i].filter.nu
    print('freq:', freq)
    fwhm = q[i].synthbeam.peak150.fwhm * (150e9 / freq)
    print('\n FWHM:', fwhm * 60)
    for istk in range(3):
        sky_conv[i, :, istk] = hp.sphtfunc.smoothing(sky128[i, :, istk], fwhm)

```

```{python}
q[i].synthbeam.peak150.fwhm * 60
```

```{python}
# Decrease seenmap NSIDE to get pixels seen 
nside_new = 128
seenmap_dgrad = hp.ud_grade(seenmap, nside_new)
thepix = np.where(seenmap_dgrad)[0]
print(len(thepix))

```

### Add the qubic convolution

```{python}
# Get the convolved sky using qubic soft
_, nus_edge_rec, nus_rec, _, _, _ = compute_freq(150, nfrecon)
q = qubic.QubicMultibandInstrument(d)
p = qubic.get_pointing(d)
s = qubic.QubicScene(d)
a = qubic.QubicMultibandAcquisition(q, p, s, d, nus_edge_rec)
tod, skyqubic_conv = a.get_observation(sky) 

skyqubic_conv = np.array(skyqubic_conv)
```

```{python}
np.max(sky128)
```

```{python}
IPIXnew = hp.ang2pix(8, hp.pix2ang(d['nside'],IPIX)[0],hp.pix2ang(d['nside'],IPIX)[1])
print(IPIXnew)
```

```{python}
# istk = 0
Stokes = ['I', 'Q', 'U']
for i in range(6000):
    pix = thepix[i]
    cond1 = np.abs(sky128[4, pix, istk] - sky128[0, pix, istk]) < 50
    cond2 = np.abs(sky128[0, pix, istk] - sky_conv[0, pix, istk]) > np.abs(sky128[4, pix, istk] - sky_conv[4, pix, istk])
    if cond2:
        plt.figure(figsize=(15, 4))

        plt.subplot(131)
        plt.plot(nus_rec, sky128[:, pix, istk], 'ro', alpha=0.5, label=f'Input sky')
        plt.plot(nus_rec, sky_conv[:, pix, istk], 'bo', alpha=0.5, label=f'Convolution with Healpix')
    #     plt.plot(nus_rec, skyqubic_conv[:, pix, istk], 'go', alpha=0.5, label='Covolution with qubic soft')

        plt.legend()
        plt.title('Pixel {}, NSIDE=2, {}'.format(pix, Stokes[istk]))
        plt.xlabel('Frequency [GHz]')
        plt.ylabel('I [µK]')

        theta, phi = hp.pix2ang(128, pix)
    #     print(theta, phi)

        hp.gnomview(sky128[0, :, 0]*seenmap_dgrad, sub=(132), title='Pixel {} input'.format(pix), 
                    rot=center, reso=30)
        hp.visufunc.projscatter(theta, phi, color='r')
        print(sky128[0, pix, 0], sky128[3, pix, 0])
    #     hp.visufunc.projtext(theta, phi, sky[0, pix, 0], color='r')

        hp.gnomview(sky_conv[3, :, 0]*seenmap_dgrad, sub=(133), title='Pixel {} conv'.format(pix), 
                    rot=center, reso=30)
        hp.visufunc.projscatter(theta, phi, color='r')
    #     hp.visufunc.projtext(theta, phi, sky[3, pix, 0], color='r')



```

```{python}

```
