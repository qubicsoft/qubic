---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.6.0rc0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Spectroimaging pixel by pixel

Edited by Louise, 18/06/2020

Edited by Martin, 21/06/2020 (implement FastSimulator)

In this notebook, I try to reproduce what Gabriele has done. Spectroimaging on the galaxy center, compare the reconstruction to the input sky pixel by pixel

```{python}
# %matplotlib inline

import os
import sys
import glob

# Specific science modules
import healpy as hp
import matplotlib.pyplot as plt
import numpy as np
import pickle
# Specific qubic modules
from astropy.io import fits
import qubic
from qubicpack.utilities import Qubic_DataDir
from qubic import QubicSkySim as qss
from qubic.polyacquisition import compute_freq
from qubic import ReadMC as rmc
from mpl_toolkits.mplot3d import Axes3D
from scipy.optimize import curve_fit
import scipy.constants
from qubic import mcmc

plt.rc('text',usetex=False)
plt.rc('font', size=16)
```

```{python}
import qubic.AnalysisMC as amc
```

Implementing FastSimulator

```{python}
# Dictionary saved during the simulation
global_dir = Qubic_DataDir(datafile='instrument.py', datadir=os.environ['QUBIC_DATADIR'])
#dictfilename = global_dir + '/doc/FastSimulator/FastSimDemo_{}.dict'.format(config)
dictfilename = global_dir + '/dicts/spectroimaging_article.dict'
d150Q = qubic.qubicdict.qubicDict()
d150Q.read_from_file(dictfilename)
d150Q['nf_recon'] = 5
d150Q['nf_sub'] = 5 
d150Q['photon_noise']=True
d150Q['RA_center'] = 0.0
d150Q['DEC_center'] = -57.0
d150Q['effective_duration'] = 2
d150Q['npointings']=10000
d150Q['effective_duration'] = 3

#150 galactic center patch (thereafter GC patch)
d150G = d150Q.copy()
d150G['effective_duration'] = 1

#
# 220 Qubic patch
d220Q = d150Q.copy()
d220Q['filter_nu'] = 220e9
# 220 GC patch
d220G = d220Q.copy()
d150G['effective_duration'] = 1

# Qubic patch - galactic coordinates
centerQ = qubic.equ2gal(d150Q['RA_center'], d150Q['DEC_center'])
# Galactic center patch - galactic coordinates 
centerG = np.array([0,0])
d150G['RA_center'], d150G['DEC_center'] = qubic.gal2equ(centerG[0], centerG[1])
d220G['RA_center'], d220G['DEC_center'] = d150G['RA_center'], d150G['DEC_center']
```

```{python}
def make_covTD(d):
    pointing = qubic.get_pointing(d)
    q = qubic.QubicMultibandInstrument(d)
    s = qubic.QubicScene(d)
    nf_sub_rec = d['nf_recon']
    _, nus_edge, nus, _, _, _ = qubic.compute_freq(d['filter_nu'] / 1e9, 
                                                   nf_sub_rec, d['filter_relative_bandwidth'])
    arec = qubic.QubicMultibandAcquisition(q, pointing, s, d, nus_edge)
    cov = arec.get_coverage()
    return cov
def save_covTD(cov, savedir=os.environ['QUBIC_DATADIR']+'doc/'):
    hdu_primary = fits.PrimaryHDU()
    hdu_cov = fits.ImageHDU(data=cov, name='coverage')
    
    thefile = fits.HDUList([hdu_primary, hdu_cov])
    thefile.writeto('')
```

lala=np.where(coverage150Q>0.5*np.max(coverage150Q))
hp.gnomview(coverage150Q,rot=centerQ,reso=15)
hp.projscatter(hp.pix2ang(256,lala),alpha=0.01,color='r')


##### QubicSkySim instanciation
seed = None
sky_config_220 = {'dust': 'd1'}
d220=d.copy()
d220['filter_nu']=220*1e9
d220['nf_recon']=5
Qubic_sky_220 = qss.Qubic_sky(sky_config_220, d220)
auxmaps220, noiseless220, _, _ = Qubic_sky_220.get_partial_sky_maps_withnoise(spatial_noise=False, 
                                                                              coverage=coverage)


Make coverage..

```{python}
makeCov = False
if makeCov:
    cov150Q = make_covTD(d150Q)
    cov220Q = make_covTD(d220Q)
    cov150G = make_covTD(d150G)
    cov220G = make_covTD(d220G)
    coverage150Q = np.sum(cov150Q, axis=0)# Sum the bands
    coverage150Q /= np.max(coverage150Q)# Normalize by the max
    coverage220Q = np.sum(cov220Q, axis=0)# Sum the bands
    coverage220Q /= np.max(coverage220Q)# Normalize by the max
    coverage150G = np.sum(cov150G, axis=0)# Sum the bands
    coverage150G /= np.max(coverage150G)# Normalize by the max
    coverage220G = np.sum(cov220G, axis=0)# Sum the bands
    coverage220G /= np.max(coverage220G)# Normalize by the max
else:
    coverage150Q = np.load(global_dir+'/doc/FastSimulator/Data/DataFastSimulator_FI150Q_coverage.npy')
    coverage220Q = np.load(global_dir+'/doc/FastSimulator/Data/DataFastSimulator_FI220Q_coverage.npy')
    coverage150G = np.load(global_dir+'/doc/FastSimulator/Data/DataFastSimulator_FI150G_coverage.npy')
    coverage220G = np.load(global_dir+'/doc/FastSimulator/Data/DataFastSimulator_FI220G_coverage.npy')
```

See at the coeverages...


plt.figure(figsize = (12,5))
hp.mollview(coverage150G, sub=(141), title = '150 GC patch', rot = centerG)
hp.mollview(coverage220G, sub=(142), title = '220 GC patch', rot = centerG)
hp.mollview(coverage150Q, sub=(143), title = '150 Q patch', rot = centerQ)
hp.mollview(coverage220Q, sub=(144), title = '220 Q patch', rot = centerQ)

```{python}
lacarte = np.zeros((4, 200, 200))
lacarte[0] = hp.gnomview(coverage150Q, rot = centerQ, reso = 13, 
                         return_projected_map = True, no_plot = True)
lacarte[1] = hp.gnomview(coverage220Q, rot = centerQ, reso = 13, 
                         return_projected_map = True, no_plot = True)
lacarte[2] = hp.gnomview(coverage150G, rot = centerG, reso = 13, 
                         return_projected_map = True, no_plot = True)
lacarte[3] = hp.gnomview(coverage220G, rot = centerG, reso = 13, 
                         return_projected_map = True, no_plot = True)
X,Y=np.meshgrid(range(200), range(200))

fig = plt.figure(figsize=(18,6))
ax = fig.add_subplot(1, 4, 1, projection='3d')
ax.set_title('cov150 Q-patch', fontsize=16)
ax.plot_surface(X,Y, lacarte[0], cmap=plt.cm.viridis, linewidth=0.2)

ax = fig.add_subplot(1, 4, 2, projection='3d')
ax.set_title('cov220 Q-patch', fontsize=16)
ax.plot_surface(X,Y, lacarte[1], cmap=plt.cm.viridis, linewidth=0.2)

ax = fig.add_subplot(1, 4, 3, projection='3d')
ax.set_title('cov150 G-patch', fontsize=16)
ax.plot_surface(X,Y, lacarte[2], cmap=plt.cm.viridis, linewidth=0.2)

ax = fig.add_subplot(1, 4, 4, projection='3d')
ax.set_title('cov220 G-patch', fontsize=16)
ax.plot_surface(X,Y, lacarte[3], cmap=plt.cm.viridis, linewidth=0.2)

```

```{python}
fig = plt.figure(figsize=(20,5))
ax = fig.add_subplot(1, 4, 1, projection='3d')
ax.set_title('cov 150 Q - GC', fontsize=16)
ax.plot_surface(X,Y, lacarte[0]-lacarte[2], cmap=plt.cm.viridis, linewidth=0.2)

ax = fig.add_subplot(1, 4, 2, projection='3d')
ax.set_title('cov 220 Q - GC', fontsize=16)
ax.plot_surface(X,Y, lacarte[1]-lacarte[3], cmap=plt.cm.viridis, linewidth=0.2)

ax = fig.add_subplot(1, 4, 3, projection='3d')
ax.set_title('cov 150 Q - 220 Q', fontsize=16)
ax.plot_surface(X,Y, lacarte[0] - lacarte[1], cmap=plt.cm.viridis, linewidth=0.2)

ax = fig.add_subplot(1, 4, 4, projection='3d')
ax.set_title('cov 150 GC - 220 GC', fontsize=16)
ax.plot_surface(X,Y, lacarte[2] - lacarte[3], cmap=plt.cm.viridis, linewidth=0.2)

```

```{python}
#Averaging manually the maps into a band
band150 = d150Q['filter_nu'] / 1e9
band220 = d220Q['filter_nu'] / 1e9

### Input bands 150
Nfreq_edges150, nus_edge150, nus150, _, _, _ = qubic.compute_freq(band150, 
                                                         d150Q['nf_sub'],
                                                         d150Q['filter_relative_bandwidth'])
### Output bands 150
Nfreq_edges_out150, nus_edge_out150, nus_out150, _, _, _ = qubic.compute_freq(band150, 
                                                                     d150Q['nf_recon'],
                                                                     d150Q['filter_relative_bandwidth'])
### Input bands 220
Nfreq_edges220, nus_edge220, nus220, _, _, _ = qubic.compute_freq(band220, 
                                                         d220Q['nf_sub'],
                                                         d220Q['filter_relative_bandwidth'])
### Output bands 220
Nfreq_edges_out220, nus_edge_out220, nus_out220, _, _, _ = qubic.compute_freq(band220, 
                                                                     d220Q['nf_recon'],
                                                                     d220Q['filter_relative_bandwidth'])
##### QubicSkySim instanciation
#seed = 42#None

sky_config_150Q = {'dust': 'd1'}
Qubic_sky_150Q = qss.Qubic_sky(sky_config_150Q, d150Q)
sky_config_220Q = {'dust': 'd1'}
Qubic_sky_220Q = qss.Qubic_sky(sky_config_220Q, d220Q)
sky_config_150G = {'dust': 'd1'}
Qubic_sky_150G = qss.Qubic_sky(sky_config_150G, d150G)
sky_config_220G = {'dust': 'd1'}
Qubic_sky_220G = qss.Qubic_sky(sky_config_220G, d220G)

# Now averaging maps into reconstruction sub-bands maps
print('Averaging input maps from input sub-bands into reconstruction sub-bands:')
dust_map_150Q = np.zeros((d150Q['nf_recon'], 12 * d150Q['nside'] ** 2, 3))
dust_map_220Q = np.zeros((d220Q['nf_recon'], 12 * d220Q['nside'] ** 2, 3))
dust_map_150G = np.zeros((d150G['nf_recon'], 12 * d150G['nside'] ** 2, 3))
dust_map_220G = np.zeros((d220G['nf_recon'], 12 * d220G['nside'] ** 2, 3))

if d150Q['nf_sub'] != d150Q['nf_recon']:
    
    print('Computing maps averaging')
    # Generate convolved sky of dust without noise 
    dust_map_150Q_in = Qubic_sky_150Q.get_fullsky_convolved_maps(FWHMdeg = None, verbose = False)
    print('=== Done {}Q map ===='.format(d150Q['filter_nu'] / 1e9))
    dust_map_220Q_in = Qubic_sky_220Q.get_fullsky_convolved_maps(FWHMdeg = None, verbose = False)
    print('=== Done {}Q map ===='.format(d220Q['filter_nu'] / 1e9))
    dust_map_150G_in = Qubic_sky_150G.get_fullsky_convolved_maps(FWHMdeg = None, verbose = False)
    print('=== Done {}G map ===='.format(d150G['filter_nu'] / 1e9))
    dust_map_220G_in = Qubic_sky_220G.get_fullsky_convolved_maps(FWHMdeg = None, verbose = False)
    print('=== Done {}G map ===='.format(d220G['filter_nu'] / 1e9))
    
    for i in range(d150Q['nf_recon']):
        print('doing band 150 Q {} {} {}'.format(i, nus_edge_out150[i], nus_edge_out150[i + 1]))
        inband150 = (nus150 > nus_edge_out150[i]) & (nus150 < nus_edge_out150[i + 1])
        dust_map_150Q[i, :, :] = np.mean(dust_map_150Q_in[inband150, :, :], axis=0)    
        print('doing band 150 G {} {} {}'.format(i, nus_edge_out150[i], nus_edge_out150[i + 1]))
        dust_map_150G[i, :, :] = np.mean(dust_map_150G_in[inband150, :, :], axis=0)
    for i in range(d220Q['nf_recon']):
        print('doing band 220 Q {} {} {}'.format(i, nus_edge_out220[i], nus_edge_out220[i + 1]))
        inband220 = (nus220 > nus_edge_out220[i]) & (nus220 < nus_edge_out220[i + 1])
        dust_map_220Q[i, :, :] = np.mean(dust_map_220Q_in[inband220, :, :], axis=0)    
        print('doing band 220 G {} {} {}'.format(i, nus_edge_out220[i], nus_edge_out220[i + 1]))
        dust_map_220G[i, :, :] = np.mean(dust_map_220G_in[inband220, :, :], axis=0)

elif d150Q['nf_sub'] == d150Q['nf_recon']:
    # Generate convolved sky of dust without noise 
    print('Computing maps directly')
    dust_map_150Q = Qubic_sky_150Q.get_fullsky_convolved_maps(FWHMdeg = None, verbose = False)
    print('=== Done {}Q map ===='.format(d150Q['filter_nu'] / 1e9))
    dust_map_220Q = Qubic_sky_220Q.get_fullsky_convolved_maps(FWHMdeg = None, verbose = False)
    print('=== Done {}Q map ===='.format(d220Q['filter_nu'] / 1e9))
    dust_map_150G = Qubic_sky_150G.get_fullsky_convolved_maps(FWHMdeg = None, verbose = False)
    print('=== Done {}G map ===='.format(d150G['filter_nu'] / 1e9))
    dust_map_220G = Qubic_sky_220G.get_fullsky_convolved_maps(FWHMdeg = None, verbose = False)
    print('=== Done {}G map ===='.format(d220G['filter_nu'] / 1e9))

```

```{python}
##### Getting FastSimulator output maps
nreals=40
npix = 12 * d150Q['nside'] ** 2
noise150Q = np.zeros((nreals, d150Q['nf_recon'], npix, 3))
noise220Q = np.zeros((nreals, d220Q['nf_recon'], npix, 3))
noise150G = np.zeros((nreals, d150G['nf_recon'], npix, 3))
noise220G = np.zeros((nreals, d220G['nf_recon'], npix, 3))

for i in range(nreals):
    noise150Q[i, ...], coverage150Q = \
        Qubic_sky_150Q.get_partial_sky_maps_withnoise(spatial_noise = False, coverage=coverage150Q, 
                                                    noise_only = True, Nyears = d150Q['effective_duration'] )        
    print('=== Done interation #{} ===='.format(i+1))
    noise220Q[i, ...], coverage220Q = \
        Qubic_sky_220Q.get_partial_sky_maps_withnoise(spatial_noise = False, coverage=coverage220Q, 
                                                    noise_only = True, Nyears = d220Q['effective_duration'])        
    print('=== Done interation #{} ===='.format(i+1))
    noise150G[i, ...], coverage150G = \
        Qubic_sky_150G.get_partial_sky_maps_withnoise(spatial_noise = False, coverage=coverage150G, 
                                                    noise_only = True, Nyears = d150G['effective_duration'])        
    print('=== Done interation #{} ===='.format(i+1))
    noise220G[i, ...], coverage220G = \
        Qubic_sky_220G.get_partial_sky_maps_withnoise(spatial_noise = False, coverage=coverage220G, 
                                                    noise_only = True, Nyears = d220G['effective_duration'])        
    print('=== Done interation #{} ===='.format(i+1))
    #gc.collect()
    
```

```{python}
import gc
noisymaps150Q = np.zeros_like(noise150Q)
noisymaps220Q = np.zeros_like(noise220Q)
noisymaps150G = np.zeros_like(noise150G)
noisymaps220G = np.zeros_like(noise220G)

for i in range(nreals):
    noisymaps150Q[i, ...] = noise150Q[i, ...] + dust_map_150Q
    noisymaps220Q[i, ...] = noise220Q[i, ...] + dust_map_220Q
    noisymaps150G[i, ...] = noise150G[i, ...] + dust_map_150G
    noisymaps220G[i, ...] = noise220G[i, ...] + dust_map_220G
    gc.collect()
    print('============= Done real {}'.format(i+1))
#
maps150Q, std150Q = np.mean(noisymaps150Q, axis = 0), np.std(noisymaps150Q, axis = 0)
maps220Q, std220Q = np.mean(noisymaps220Q, axis = 0), np.std(noisymaps220Q, axis = 0)
maps150G, std150G = np.mean(noisymaps150G, axis = 0), np.std(noisymaps150G, axis = 0)
maps220G, std220G = np.mean(noisymaps220G, axis = 0), np.std(noisymaps220G, axis = 0)
```

Look at the maps... okk..

```{python}
#centerG = np.array([0,0])
print(centerG,centerQ)
pixG = hp.ang2pix(256, np.pi/2-np.radians(centerG[1]), np.radians(centerG[0]))
pixQ = hp.ang2pix(256, np.pi/2-np.radians(centerQ[1]), np.radians(centerQ[0]))
print(pixQ,pixG)
```

```{python}
cov150Q = np.zeros_like(coverage150Q,dtype=bool)
covmsk150Q = np.where(coverage150Q > 0.01*np.max(coverage150Q))
cov150Q[covmsk150Q] = 1

cov220Q = np.zeros_like(coverage220Q,dtype=bool)
covmsk220Q = np.where(coverage220Q > 0.01*np.max(coverage220Q))
cov220Q[covmsk220Q] = 1

cov150G = np.zeros_like(coverage150G,dtype=bool)
covmsk150G = np.where(coverage150G > 0.01*np.max(coverage150G))
cov150G[covmsk150G] = 1

cov220G = np.zeros_like(coverage220G,dtype=bool)
covmsk220G = np.where(coverage220G > 0.01*np.max(coverage220G))
cov220G[covmsk220G] = 1
```

```{python}
for iNU in range(d150Q['nf_recon']):
    maps150Q[iNU,~cov150Q,0] = hp.UNSEEN
    maps220Q[iNU,~cov220Q,0] = hp.UNSEEN
    maps150G[iNU,~cov150G,0] = hp.UNSEEN
    maps220G[iNU,~cov220G,0] = hp.UNSEEN
```

```{python}
NU = 0
STK = 0
RESO = 15

capsize=3
plt.rc('font', size=15)

pixQ = [hp.ang2pix(d150Q['nside'], np.pi / 2 - np.deg2rad(centerQ[1] + 15), 
                   np.deg2rad(centerQ[0] - 13) ), ]
pixG = [hp.ang2pix(d150G['nside'], np.pi / 2 - np.deg2rad(centerG[1] + 3), 
                   np.deg2rad(centerG[0] + 7) ), ]

for j in range(1):#enumerate(range(600,12000,500)):
    fig,ax=plt.subplots(nrows=1,ncols=4,figsize=(18,4.5),)
    ax=ax.ravel()
    IPIXQ = pixQ[j]
    IPIXG = pixG[j]
    print(pixQ[j], pixG[j])
    ax[0].errorbar(nus_out150, maps150G[:,IPIXG,0],yerr=std150G[:,IPIXG,0], capsize=capsize,
           fmt='o-', color='r',label='reconstructed', alpha=0.8)
    ax[0].errorbar(nus_out220, maps220G[:,IPIXG,0],yerr=std220G[:,IPIXG,0], capsize=capsize,
           fmt='o-', color='r', alpha=0.8)
    ax[0].plot(nus_out150, dust_map_150G[:,IPIXG,0],
           'bo-',label='convolved', alpha=0.7)
    ax[0].plot(nus_out220, dust_map_220G[:,IPIXG,0],
           'bo-', alpha=0.7)
    ax[0].axvspan(nus150[-1],nus220[0],color='k',alpha=0.2)

    ax[2].errorbar(nus_out150, maps150Q[:,pixQ[j],0],yerr=std150Q[:,pixQ[j],0], capsize=capsize,
           fmt='o-', color='r',label='reconstructed', alpha=0.8)
    ax[2].errorbar(nus_out220, maps220Q[:,pixQ[j],0],yerr=std220Q[:,pixQ[j],0], capsize=capsize,
           fmt='o-', color='r',alpha=0.8)
    ax[2].plot(nus_out150, dust_map_150Q[:,pixQ[j],0],
           'bo-',label='convolved', alpha=0.7)
    ax[2].plot(nus_out220, dust_map_220Q[:,pixQ[j],0],
           'bo-', alpha=0.5)

    ax[2].grid(which='both')
    ax[2].axvspan(nus150[-1], nus220[0],color='k',alpha=0.2)
        
    ax[0].set_title('GC patch',fontsize=17)
    ax[0].set_ylabel(r'$I_\nu$ [$\mu$K]',fontsize=18)
    ax[0].set_xlabel(r'$\nu$[GHz]',fontsize=18)
    ax[2].set_title('QUBIC patch',fontsize=17)
    #ax[2].set_ylabel(r'$I_\nu$ [$\mu$K]',fontsize=18)
    ax[2].set_xlabel(r'$\nu$[GHz]',fontsize=18)
    ax[0].legend(loc='best',fontsize=12)
    ax[0].grid()
    ax[1].cla()
    plt.axes(ax[1])
    hp.gnomview(maps150G[-1,:,0], reso = 15,hold = True, notext = True, title = ' ',unit = r'$\mu$K',
                max = 0.23 * np.max(maps150G[-1,:,0]), rot = centerG)
    hp.projscatter(hp.pix2ang(d150G['nside'], IPIXG), marker = '+', color = 'r',)
    ax[3].cla()
    plt.axes(ax[3])
    hp.gnomview(maps150Q[-1,:,0], reso = 15, hold = True, notext = True, title = ' ',unit = r'$\mu$K',
                max = 0.7*np.max(maps150Q[0,:,0]), rot = centerQ)
    hp.projscatter(hp.pix2ang(d150Q['nside'], pixQ[j]),marker = '+', color = 'r',)
    #plt.savefig('Figs-FI-SED/nrec{}_nside{}_pixQ{}_pixG{}_Intensity.svg'.format(d150Q['nf_recon'],
    #                                                                                          d150Q['nside'],
    #                                                           pixQ[j], IPIXG), 
    #            format = 'svg')
    #plt.savefig('Figs-FI-SED/nrec{}_nside{}_pixQ{}_pixG{}_Intensity.pdf'.format(d150Q['nf_recon'],
    #                                                                                          d150Q['nside'],
    #                                                           pixQ[j], IPIXG), 
    #            format = 'pdf')
    #plt.savefig('Figs-FI-SED/nrec{}_nside{}_pixQ{}_pixG{}_Intensity'.format(d150Q['nf_recon'],
    #                                                                                      d150Q['nside'],
    #                                                                 pixQ[j], IPIXG))
plt.show()
```

### Udgrade

```{python}
nside_new = 64
npix_ud = 12 * nside_new **2 
noise150Q_ud = np.zeros((nreals, len(nus_out150), npix_ud, 3))
noise220Q_ud = np.zeros((nreals, len(nus_out150), npix_ud, 3))
noise150G_ud = np.zeros((nreals, len(nus_out150), npix_ud, 3))
noise220G_ud = np.zeros((nreals, len(nus_out150), npix_ud, 3))
#noisymapsFI_ud = np.zeros_like(noisymapsTD_ud)

for ireal in range(nreals):
    for irec in range(len(nus_out150)):
        noise150Q_ud[ireal, irec] = hp.ud_grade(noise150Q[ireal, irec].T, nside_new).T
        noise220Q_ud[ireal, irec] = hp.ud_grade(noise220Q[ireal, irec].T, nside_new).T
        noise150G_ud[ireal, irec] = hp.ud_grade(noise150G[ireal, irec].T, nside_new).T
        noise220G_ud[ireal, irec] = hp.ud_grade(noise220G[ireal, irec].T, nside_new).T
        #noisymapsFI_ud = hp.ud_grade(noisymapsFI[ireal, irec].T, nside_new).T
#
dust_map_150Q_ud = np.zeros((len(nus_out150), 12 * nside_new ** 2, 3))
dust_map_220Q_ud = np.zeros_like(dust_map_150Q_ud)
dust_map_150G_ud = np.zeros_like(dust_map_150Q_ud)
dust_map_220G_ud = np.zeros_like(dust_map_150Q_ud)

for irec in range(len(nus_out150)):
    dust_map_150Q_ud[irec] = hp.ud_grade(dust_map_150Q[irec].T, nside_new).T
    dust_map_220Q_ud[irec] = hp.ud_grade(dust_map_220Q[irec].T, nside_new).T
    dust_map_150G_ud[irec] = hp.ud_grade(dust_map_150G[irec].T, nside_new).T
    dust_map_220G_ud[irec] = hp.ud_grade(dust_map_220G[irec].T, nside_new).T
#
```

```{python}
maps150Q_ud_i = np.zeros_like(noise150Q_ud)
maps220Q_ud_i = np.zeros_like(noise220Q_ud)
maps150G_ud_i = np.zeros_like(noise150G_ud)
maps220G_ud_i = np.zeros_like(noise220G_ud)

for i in range(nreals):
    maps150Q_ud_i[i, ...] = noise150Q_ud[i, ...] + dust_map_150Q_ud
    maps220Q_ud_i[i, ...] = noise220Q_ud[i, ...] + dust_map_220Q_ud
    maps150G_ud_i[i, ...] = noise150G_ud[i, ...] + dust_map_150G_ud
    maps220G_ud_i[i, ...] = noise220G_ud[i, ...] + dust_map_220G_ud
#

maps150Q_ud, std150Q_ud = np.mean(maps150Q_ud_i, axis = 0), np.std(maps150Q_ud_i, axis = 0)
maps220Q_ud, std220Q_ud = np.mean(maps220Q_ud_i, axis = 0), np.std(maps220Q_ud_i, axis = 0)
maps150G_ud, std150G_ud = np.mean(maps150G_ud_i, axis = 0), np.std(maps150G_ud_i, axis = 0)
maps220G_ud, std220G_ud = np.mean(maps220G_ud_i, axis = 0), np.std(maps220G_ud_i, axis = 0)
```

```{python}
PixPix = lambda p: hp.ang2pix(nside_new, hp.pix2ang(d150Q['nside'], p)[0], hp.pix2ang(d150Q['nside'], p)[1] )
```
Computing the error bars considering covariance between sub-bands

```{python}
cov150Q_ud = hp.ud_grade(cov150Q, nside_new)
cov220Q_ud = hp.ud_grade(cov220Q, nside_new)
cov150G_ud = hp.ud_grade(cov150G, nside_new)
cov220G_ud = hp.ud_grade(cov220G, nside_new)

Cp150Q = amc.get_Cp(noise150Q_ud[:, :, cov150Q_ud, :], verbose = False, doplot = False)
Cp220Q = amc.get_Cp(noise220Q_ud[:, :, cov220Q_ud, :], verbose = False, doplot = False)
Cp150G = amc.get_Cp(noise150G_ud[:, :, cov150G_ud, :], verbose = False, doplot = False)
Cp220G = amc.get_Cp(noise220G_ud[:, :, cov220G_ud, :], verbose = False, doplot = False)

_, Cp150Q_prime = amc.Cp2Cp_prime_viaCorr(Cp150Q, verbose = False)
_, Cp220Q_prime = amc.Cp2Cp_prime_viaCorr(Cp220Q, verbose = False)
_, Cp150G_prime = amc.Cp2Cp_prime_viaCorr(Cp150G, verbose = False)
_, Cp220G_prime = amc.Cp2Cp_prime_viaCorr(Cp220G, verbose = False)

plt.figure()
plt.imshow(Cp150Q_prime[:, :, 0, 0])
plt.colorbar()
```

Do same plots averaging and/or computing rms in maps

```{python}
for iNU in range(d150Q['nf_recon']):
    maps150Q_ud[iNU,~cov150Q_ud,:] = hp.UNSEEN
    maps220Q_ud[iNU,~cov220Q_ud,:] = hp.UNSEEN
    maps150G_ud[iNU,~cov150G_ud,:] = hp.UNSEEN
    maps220G_ud[iNU,~cov220G_ud,:] = hp.UNSEEN
```

### FIT

```{python}
pixQ = [hp.ang2pix(d150Q['nside'], np.pi / 2 - np.deg2rad(centerQ[1] + 12), np.deg2rad(centerQ[0] - 10  ) ), ]
pixG = [hp.ang2pix(d150G['nside'], np.pi / 2 - np.deg2rad(centerG[1] - 8), np.deg2rad(centerG[0] + 0 ) ), ]
pixQ_ud = PixPix(pixQ[0])
pixG_ud = PixPix(pixG[0])

pixQ_red = np.where(np.where(cov150Q_ud == True)[0] == pixQ_ud)[0][0]
pixG_red = np.where(np.where(cov150G_ud == True)[0] == pixG_ud)[0][0]

plt.figure(figsize = (10,4))
hp.gnomview(maps150G_ud[-1,:,0], reso = 15,#hold = True, 
            notext = True, title = 'G patch ', sub = (121),
            max = 0.4*np.max(maps150G_ud[-1,:,0]), 
            unit = r'$\mu$K',
            rot = centerG)
hp.projscatter(hp.pix2ang(nside_new, pixG_ud), marker = '*', color = 'r', s = 200)
hp.gnomview(maps220Q_ud[-1,:,0], reso = 15, title = 'Q patch ',
            unit = r'$\mu$K', sub = (122),
            rot = centerQ)
hp.projscatter(hp.pix2ang(nside_new, pixQ_ud), marker = '*', color = 'r', s = 200)
```

```{python}
#from lmfit import Model

def funcPot(x, a, b):
    return a + x**b

def quad(x, a, b,c):
    return a*x**2 + b*x + c

def Bnu(nuGHz, temp):
    h = scipy.constants.h
    c = scipy.constants.c
    k = scipy.constants.k
    nu = nuGHz * 1e9
    return 2 * h * nu ** 3 / c ** 2 / (np.exp(h * nu / k / temp ) - 1 )

def func353(x, a, b):
    Tdust = 19.6
    bnu = Bnu(x, Tdust)
    return a * 1e18 * bnu * (x / 353) ** (b / 2)

def PixSED_Xstk(nus, maps, FuncModel, pix, pix_red, istk, covMat, nus_edge,
           maxfev = 10000, initP0 = None, verbose = False,
          nsamples = 5000):
    
    popt, _ = curve_fit(FuncModel, nus, maps[:, pix, istk], 
                            sigma=covMat[:, :, istk, pix_red], absolute_sigma=True,
                            maxfev = maxfev, p0 = initP0)

    myfit = mcmc.LogLikelihood(xvals = nus, yvals = maps[:, pix, istk], 
                               errors = covMat[:, :, istk, pix_red], 
                               model = FuncModel, p0=popt)
    fit_prep = myfit.run(nsamples)
    flat_samples = fit_prep.get_chain(discard = nsamples//2, thin=32, flat=True)
    nspls = flat_samples.shape[0]
    #Generating realizations for parameters of the model (fake X(nu))
    
    x = np.linspace(nus_edge[0], nus_edge[-1], nsamples//2)
    vals = np.zeros((len(x), nspls))
    for i in range(len(x)):
        for j in range(nspls):
            vals[i, j] = FuncModel(x[i], *flat_samples[j, :])
    
    mvals = np.mean(vals, axis=1)
    svals = np.std(vals, axis=1)
    
    return mvals, svals, x
    
    
```

```{python}
import time
t0 = time.time()
FuncModel = func353
istk = 0
Imvals150Q, Isvals150Q, x150 = PixSED_Xstk(nus_out150, dust_map_150Q_ud, FuncModel, pixQ_ud, pixQ_red, 
                               istk, Cp150Q_prime, nus_edge150)
Imvals150G, Isvals150G, _ = PixSED_Xstk(nus_out150, dust_map_150G_ud, FuncModel, pixG_ud, pixG_red, 
                               istk, Cp150G_prime, nus_edge150)

Imvals220Q, Isvals220Q, x220 = PixSED_Xstk(nus_out220, dust_map_220Q_ud, FuncModel, pixQ_ud, pixQ_red, 
                               istk, Cp220Q_prime, nus_edge220)
Imvals220G, Isvals220G, _ = PixSED_Xstk(nus_out220, dust_map_220G_ud, FuncModel, pixG_ud, pixG_red, 
                               istk, Cp220G_prime, nus_edge220)
print('Done in {:.2f} min'.format((time.time()-t0)/60 ))
```

```{python}
t1 = time.time()
istk = 1
print("===============  Doing {} stokes  ====================".format(d150Q['kind'][istk]))
Qmvals150Q, Qsvals150Q, _ = PixSED_Xstk(nus_out150, dust_map_150Q_ud, FuncModel, pixQ_ud, pixQ_red, 
                               istk, Cp150Q_prime, nus_edge150)
Qmvals150G, Qsvals150G, _ = PixSED_Xstk(nus_out150, dust_map_150G_ud, FuncModel, pixG_ud, pixG_red, 
                               istk, Cp150G_prime, nus_edge150)

Qmvals220Q, Qsvals220Q, _ = PixSED_Xstk(nus_out220, dust_map_220Q_ud, FuncModel, pixQ_ud, pixQ_red, 
                               istk, Cp220Q_prime, nus_edge220)
Qmvals220G, Qsvals220G, _ = PixSED_Xstk(nus_out220, dust_map_220G_ud, FuncModel, pixG_ud, pixG_red, 
                               istk, Cp220G_prime, nus_edge220)
istk = 2
print("===============  Doing {} stokes  =====================".format(d150Q['kind'][istk]))
Umvals150Q, Usvals150Q, _ = PixSED_Xstk(nus_out150, dust_map_150Q_ud, FuncModel, pixQ_ud, pixQ_red, 
                               istk, Cp150Q_prime, nus_edge150)
Umvals150G, Usvals150G, _ = PixSED_Xstk(nus_out150, dust_map_150G_ud, FuncModel, pixG_ud, pixG_red, 
                               istk, Cp150G_prime, nus_edge150)

Umvals220Q, Usvals220Q, _ = PixSED_Xstk(nus_out220, dust_map_220Q_ud, FuncModel, pixQ_ud, pixQ_red, 
                               istk, Cp220Q_prime, nus_edge220)
Umvals220G, Usvals220G, _ = PixSED_Xstk(nus_out220, dust_map_220G_ud, FuncModel, pixG_ud, pixG_red, 
                               istk, Cp220G_prime, nus_edge220)
print('Done in {:.2f} min'.format((time.time()-t1)/60 ))
```

Average realizations and compute std of realizations

```{python}
# Modeling fit to map values
xSED150 = nus_out150
xSED220 = nus_out220
ySED150Q = dust_map_150Q_ud[:,pixQ_ud,0]
ySED220Q = dust_map_220Q_ud[:,pixQ_ud,0]
ySED150G = dust_map_150G_ud[:,pixG_ud,0]
ySED220G = dust_map_220G_ud[:,pixG_ud,0]

p_opt150Q, p_cov150Q = curve_fit(quad, xSED150, ySED150Q)
p_opt220Q, p_cov220Q = curve_fit(quad, xSED220, ySED220Q)
p_opt150G, p_cov150G = curve_fit(quad, xSED150, ySED150G)
p_opt220G, p_cov220G = curve_fit(quad, xSED220, ySED220G)
```

```{python}
xnew1 = np.linspace(130,170,1000)
xnew2 = np.linspace(190,240,1000)
plt.subplot(121)
plt.plot(xnew1, quad(xnew1, *p_opt150Q),'r-',label='150Q')
plt.plot(xnew1, quad(xnew1, *p_opt150G),'b-',label='150G')
plt.plot(xSED150, ySED150Q, 'ro')
plt.plot(xSED150, ySED150G, 'bo')
plt.legend()
plt.subplot(122)
plt.plot(xnew2, quad(xnew2, *p_opt220Q),'r-',label='220Q')
plt.plot(xnew2, quad(xnew2, *p_opt220G),'b-',label='220G')
plt.plot(xSED220, ySED220Q, 'ro')
plt.plot(xSED220, ySED220G, 'bo')
plt.legend()
```

```{python}
RESO = 15
capsize=3
plt.rc('font', size=14)

ySED150Q_fit = quad(x150, *p_opt150Q)
ySED220Q_fit = quad(x220, *p_opt220Q)
ySED150G_fit = quad(x150, *p_opt150G)
ySED220G_fit = quad(x220, *p_opt220G)

fig,ax=plt.subplots(nrows=1,ncols=4,figsize=(19,4.5),)
ax=ax.ravel()
# Plotting
ax[0].plot(nus_out150, dust_map_150G_ud[:,pixG_ud,0], 'ro', label = 'Input sky')
ax[0].plot(nus_out220, dust_map_220G_ud[:,pixG_ud,0], 'ro')
ax[0].fill_between(x150, y1 = ySED150G_fit - Isvals150G, y2 = ySED150G_fit + Isvals150G, 
                   color = 'g', alpha = 0.3, label = '68% C.L.')
ax[0].fill_between(x220, y1 = ySED220G_fit - Isvals220G, y2 = ySED220G_fit + Isvals220G, 
                   color = 'g', alpha = 0.3)

ax[0].axvspan(nus_edge150[-1], nus_edge220[0],color='k',alpha=0.2)

ax[2].plot(nus_out150, dust_map_150Q_ud[:,pixQ_ud,0], 'ro')
ax[2].plot(nus_out220, dust_map_220Q_ud[:,pixQ_ud,0], 'ro')
ax[2].fill_between(x150, y1 = ySED150Q_fit - Isvals150Q, y2 = ySED150Q_fit + Isvals150Q, 
                   color = 'g', alpha = 0.3)
ax[2].fill_between(x220, y1 = ySED220Q_fit - Isvals220Q, y2 = ySED220Q_fit + Isvals220Q, 
                   color = 'g', alpha = 0.3)
ax[2].axvspan(nus_edge150[-1],nus_edge220[0],color='k',alpha=0.2)

# Settings
ax[2].grid(which='both')
ax[0].legend(loc=2,fontsize=12)
ax[0].grid()
ax[0].set_title('GC patch - {} year'.format(d150G['effective_duration']),fontsize=14)
ax[0].set_ylabel(r'$I(\nu)$ [$\mu$K]',fontsize=14)
ax[0].set_xlabel(r'$\nu$[GHz]',fontsize=14)

ax[2].set_title('QUBIC patch - {} years'.format(d150Q['effective_duration']),fontsize=14)
ax[2].set_ylabel(r'$I(\nu)$ [$\mu$K]',fontsize=14)
ax[2].set_xlabel(r'$\nu$[GHz]',fontsize=14)

# Displaying maps
ax[1].cla()
plt.axes(ax[1])
hp.gnomview(maps150G_ud[-1,:,0], reso = 15,hold = True, 
            notext = True, title = ' ',
            max = 0.4*np.max(maps150G_ud[-1,:,0]), 
            unit = r'$\mu$K',
            rot = centerG)
hp.projscatter(hp.pix2ang(nside_new, pixG_ud), marker = '*', color = 'r', s = 180)
ax[3].cla()
plt.axes(ax[3])
hp.gnomview(maps220Q_ud[-1,:,0], reso = 15, hold = True, 
            notext = True, title = ' ',
            unit = r'$\mu$K',
            rot = centerQ)
hp.projscatter(hp.pix2ang(nside_new, pixQ_ud),marker = '*', color = 'r', s = 180)
#plt.savefig('Figs-FI-SED/nrec{}_nside{}_pixQ{}_pixG{}_Intensity.svg'.format(d150Q['nf_recon'],nside_new,
#                                                           pixQ_ud, pixG_ud), 
#            format = 'svg')
plt.savefig('Figs-FI-SED/{}_nrec{}_nside{}_pixQ{}_pixG{}_Intensity.pdf'.format(FuncModel.__name__,
                                                                               d150Q['nf_recon'],nside_new,
                                                           pixQ_ud, pixG_ud), 
            format = 'pdf')
plt.savefig('Figs-FI-SED/{}_nrec{}_nside{}_pixQ{}_pixG{}_Intensity'.format(FuncModel.__name__, 
                                                                           d150Q['nf_recon'],
                                                                           nside_new,pixQ_ud, pixG_ud))
plt.show()
```

plt.errorbar(nus_out150, maps150Q_ud[:,pixQ_ud,0],yerr=std150Q_ud[:,pixQ_ud,0], capsize=capsize,
       fmt='o-', color='r',label='MC', alpha=0.8)
plt.plot(x150, mvals150Q, 'g', label='MCMC')
plt.fill_between(x150, y1 = mvals150Q - svals150Q, y2 = mvals150Q + svals150Q, 
                   color = 'g', alpha = 0.3)

#plt.plot(x150_cf, mvals150Q_cf, 'c', label='curve fit')
#plt.fill_between(x150_cf, y1 = mvals150Q_cf - svals150Q_cf, y2 = mvals150Q_cf + svals150Q_cf, 
#                   color = 'c', alpha = 0.3)

plt.ylabel(r'$I(\nu)$ [$\mu$K]',fontsize=18)
plt.xlabel(r'$\nu$[GHz]',fontsize=14)
plt.legend(loc='best',fontsize=12)


plt.plot(nus_out150, dust_map_150Q_ud[:,pixQ_ud,0],
       'bo-',label='convolved', )
plt.plot(nus_out220, dust_map_220Q_ud[:,pixQ_ud,0],
       'bo-')
plt.plot(x150, mvals150Q, 'g', label='reconstructed')
plt.fill_between(x150, y1 = mvals150Q - svals150Q, y2 = mvals150Q + svals150Q, 
                   color = 'g', alpha = 0.3)
plt.plot(x220, mvals220Q, 'g')
plt.fill_between(x220, y1 = mvals220Q - svals220Q, y2 = mvals220Q + svals220Q, 
                   color = 'g', alpha = 0.3)

plt.axvspan(nus_edge150[-1],nus_edge220[0],color='k',alpha=0.2)

plt.ylabel(r'$I(\nu)$ [$\mu$K]',fontsize=18)
plt.xlabel(r'$\nu$[GHz]',fontsize=14)
plt.legend(loc='best',fontsize=12)


### Polarization

Average realizations and compute std of realizations
```{python}
# Modeling fit to map values
ySED150G_pol = np.sqrt(dust_map_150G_ud[:,pixG_ud,1] ** 2 + dust_map_150G_ud[:,pixG_ud,2] ** 2)
ySED220G_pol = np.sqrt(dust_map_220G_ud[:,pixG_ud,1] ** 2 + dust_map_220G_ud[:,pixG_ud,2] ** 2)
ySED150Q_pol = np.sqrt(dust_map_150Q_ud[:,pixQ_ud,1] ** 2 + dust_map_150Q_ud[:,pixQ_ud,2] ** 2)
ySED220Q_pol = np.sqrt(dust_map_220Q_ud[:,pixQ_ud,1] ** 2 + dust_map_220Q_ud[:,pixQ_ud,2] ** 2)

p_opt150Q_pol, p_cov150Q_pol = curve_fit(quad, xSED150, ySED150Q_pol)
p_opt220Q_pol, p_cov220Q_pol = curve_fit(quad, xSED220, ySED220Q_pol)
p_opt150G_pol, p_cov150G_pol = curve_fit(quad, xSED150, ySED150G_pol)
p_opt220G_pol, p_cov220G_pol = curve_fit(quad, xSED220, ySED220G_pol)
```

```{python}
ErrBar = lambda xmean, xstd, px: np.sqrt( xmean[:,px,1] ** 2 *xstd[:,px,1] ** 2 + \
                                         xmean[:,px,2] ** 2 * xstd[:,px,2] ** 2) / \
                                           np.sqrt( xmean[:,px,1] ** 2 + xmean[:,px,2] ** 2)
```

```{python}
ErrBar2 = lambda Q, U, Qerr, Uerr: np.sqrt( Q ** 2 * Qerr ** 2 + U ** 2 * Uerr ** 2) / \
                np.sqrt( Q ** 2 + U ** 2)
```

```{python}
Pmean150G = np.sqrt(Qmvals150G ** 2 + Umvals150G ** 2)
Pmean220G = np.sqrt(Qmvals220G ** 2 + Umvals220G ** 2)
Pmean150Q = np.sqrt(Qmvals150Q ** 2 + Umvals150Q ** 2)
Pmean220Q = np.sqrt(Qmvals220Q ** 2 + Umvals220Q ** 2)
#Error bar 150 G
Perr150G = ErrBar2(Qmvals150G, Umvals150G, Qsvals150G, Usvals150G)
#Error bar 220 G
Perr220G = ErrBar2(Qmvals220G, Umvals220G, Qsvals220G, Usvals220G)
#Error bar 150 Q
Perr150Q = ErrBar2(Qmvals150Q, Umvals150Q, Qsvals150Q, Usvals150Q)
#Error bar 220 Q
Perr220Q = ErrBar2(Qmvals220Q, Umvals220Q, Qsvals220Q, Usvals220Q)

ySED150Q_fit_pol = quad(x150, *p_opt150Q_pol)
ySED220Q_fit_pol = quad(x220, *p_opt220Q_pol)
ySED150G_fit_pol = quad(x150, *p_opt150G_pol)
ySED220G_fit_pol = quad(x220, *p_opt220G_pol)

fig,ax = plt.subplots(nrows = 1,ncols = 4, figsize = (19,4.5),)
ax = ax.ravel()

# Plotting
ax[0].plot(nus_out150, 
               np.sqrt(dust_map_150G_ud[:,pixG_ud,1] ** 2 + dust_map_150G_ud[:,pixG_ud,2] ** 2),
               'ro', lw = 3, label = 'Input sky')
ax[0].plot(nus_out220, 
               np.sqrt(dust_map_220G_ud[:,pixG_ud,1] ** 2 + dust_map_220G_ud[:,pixG_ud,2] ** 2),
               'ro', lw = 3)

ax[0].fill_between(x150, y1 = ySED150G_fit_pol - Perr150G, y2 = ySED150G_fit_pol + Perr150G, 
                   color = 'g', alpha = 0.3, label = '68% C.L. ')
ax[0].fill_between(x220, y1 = ySED220G_fit_pol - Perr220G, y2 = ySED220G_fit_pol + Perr220G, 
                   color = 'g', alpha = 0.3)
ax[0].axvspan(nus_edge150[-1], nus_edge220[0], color = 'k', alpha = 0.2)
ax[2].plot(nus_out150, 
               np.sqrt(dust_map_150Q_ud[:,pixQ_ud,1] ** 2 + dust_map_150Q_ud[:,pixQ_ud,2] ** 2),
               'ro', lw = 3)
ax[2].plot(nus_out220, 
               np.sqrt(dust_map_220Q_ud[:,pixQ_ud,1] ** 2 + dust_map_220Q_ud[:,pixQ_ud,2] ** 2),
               'ro', lw = 3)
ax[2].fill_between(x150, y1 = ySED150Q_fit_pol - Perr150Q, y2 = ySED150Q_fit_pol + Perr150Q, 
                   color = 'g', alpha = 0.3)
ax[2].fill_between(x220, y1 = ySED220Q_fit_pol - Perr220Q, y2 = ySED220Q_fit_pol + Perr220Q, 
                   color = 'g', alpha = 0.3)

# Setting
ax[0].set_title('GC patch - {} year'.format(d150G['effective_duration']),fontsize=14)
ax[0].set_ylabel(r'$P(\nu)~[\mu$K]', fontsize = 14)
ax[0].set_xlabel(r'$\nu~[GHz]$', fontsize = 14)
ax[0].legend(loc = 2, fontsize = 12)
ax[0].grid()
ax[2].set_xlabel(r'$\nu~[GHz]$', fontsize = 14)
ax[2].axvspan(nus_edge150[-1], nus_edge220[0], color = 'k', alpha = 0.2)
ax[2].set_ylabel(r'$P(\nu)~[\mu$K]', fontsize = 14)
ax[2].set_title('QUBIC patch - {} years'.format(d150Q['effective_duration']),fontsize=14)
ax[2].grid()

# Displaying maps    
plt.axes(ax[1])
auxmapG = np.sqrt(maps150G_ud[0,:,1] ** 2 + maps150G_ud[0,:,2] ** 2)
auxmapG[~cov150G_ud] = hp.UNSEEN
hp.gnomview(auxmapG,
            reso = 15, hold = True, notext = True, 
            title = ' ',
            cbar = True,
            unit = r'$\mu$K',
            rot = centerG)
hp.projscatter(hp.pix2ang(nside_new,pixG_ud),marker = '*',color = 'r', s = 200)

plt.axes(ax[3])
auxmapQ = np.sqrt(maps150Q_ud[0,:,1] ** 2 + maps150Q_ud[0,:,2] ** 2)
auxmapQ[~cov150Q_ud] = hp.UNSEEN
hp.gnomview(auxmapQ,
            reso = 15, hold = True, notext = True, 
            #max = 1e2,
            title = ' ',
            cbar = True,
            unit = r'$\mu$K',
            rot = centerQ)
hp.projscatter(hp.pix2ang(nside_new,pixQ_ud),marker='*',color='r', s = 200)
#plt.savefig('Figs-FI-SED/nrec{}_nside{}_pixQ{}_pixG{}_Polarization.svg'.format(d150Q['nf_recon'], nside_new,
#                                                           pixQ_ud, pixG_ud), 
#            format = 'svg')
plt.savefig('Figs-FI-SED/{}_nrec{}_nside{}_pixQ{}_pixG{}_Polarization.pdf'.format(FuncModel.__name__,
                                                                                  d150Q['nf_recon'], nside_new,
                                                           pixQ_ud, pixG_ud), 
            format = 'pdf')
plt.savefig('Figs-FI-SED/{}_nrec{}_nside{}_pixQ{}_pixG{}_Polarization'.format(FuncModel.__name__,
                                                                           d150Q['nf_recon'], 
                                                                           nside_new,pixQ_ud, pixG_ud))
plt.show()
```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

Look at one component of polarization


```{python}
stkP = 1
RESO = 15
capsize=3
plt.rc('font', size=14)

fig,ax=plt.subplots(nrows=1,ncols=4,figsize=(19,4.5),)
ax=ax.ravel()
# Plotting
ax[0].errorbar(nus_out150, dust_map_150G_ud[:,pixG_ud,stkP],yerr = std150G_ud[:,pixG_ud,stkP], capsize=capsize,
       fmt = 'o', color = 'r',label = 'MC')
ax[0].errorbar(nus_out220, dust_map_220G_ud[:,pixG_ud,stkP],yerr = std220G_ud[:,pixG_ud,stkP], capsize=capsize,
       fmt = 'o', color = 'r')

#ax[0].plot(nus_out150, dust_map_150G_ud[:,pixG_ud,stkP], 'bo-', label = 'convolved')
#ax[0].plot(nus_out220, dust_map_220G_ud[:,pixG_ud,stkP], 'bo-')

ax[0].plot(x150, Qmvals150G, 'g-', label = '68% C.L.')
ax[0].fill_between(x150, y1 = Qmvals150G - Qsvals150G, y2 = Qmvals150G + Qsvals150G, 
                   color = 'g', alpha = 0.3)
ax[0].plot(x220, Qmvals220G , 'g-')
ax[0].fill_between(x220, y1 = Qmvals220G - Qsvals220G, y2 = Qmvals220G + Qsvals220G, 
                   color = 'g', alpha = 0.3)

ax[0].axvspan(nus_edge150[-1], nus_edge220[0],color='k',alpha=0.2)

ax[2].errorbar(nus_out150, dust_map_150Q_ud[:,pixQ_ud,stkP],yerr=std150Q_ud[:,pixQ_ud,stkP], capsize=capsize,
       fmt='o', color='r', alpha=0.8)
ax[2].errorbar(nus_out220, dust_map_220Q_ud[:,pixQ_ud,stkP],yerr=std220Q_ud[:,pixQ_ud,stkP], capsize=capsize,
       fmt='o', color='r',alpha=0.8)
#ax[2].plot(nus_out150, dust_map_150Q_ud[:,pixQ_ud,stkP], 'bo-')
#ax[2].plot(nus_out220, dust_map_220Q_ud[:,pixQ_ud,stkP], 'bo-')
ax[2].plot(x150, Qmvals150Q, 'g')
ax[2].fill_between(x150, y1 = Qmvals150Q - Qsvals150Q, y2 = Qmvals150Q + Qsvals150Q, 
                   color = 'g', alpha = 0.3)
ax[2].plot(x220, Qmvals220Q, 'g')
ax[2].fill_between(x220, y1 = Qmvals220Q - Qsvals220Q, y2 = Qmvals220Q + Qsvals220Q, 
                   color = 'g', alpha = 0.3)
ax[2].axvspan(nus_edge150[-1],nus_edge220[0],color='k',alpha=0.2)

# Settings
ax[2].grid(which = 'both')
ax[0].legend(loc = 2,fontsize = 12)
ax[0].grid()
ax[0].set_title('GC patch - {} year'.format(d150G['effective_duration']),fontsize=14)
ax[0].set_ylabel(r'$Q(\nu)$ [$\mu$K]',fontsize=14)
ax[0].set_xlabel(r'$\nu$[GHz]',fontsize=14)

ax[2].set_title('QUBIC patch - {} years'.format(d150Q['effective_duration']),fontsize=14)
ax[2].set_ylabel(r'$Q(\nu)$ [$\mu$K]',fontsize=14)
ax[2].set_xlabel(r'$\nu$[GHz]',fontsize=14)

# Displaying maps
ax[1].cla()
plt.axes(ax[1])
hp.gnomview(maps150G_ud[-1,:,stkP], reso = 15,hold = True, 
            notext = True, title = ' ',
            max = 0.6*np.max(maps150G_ud[-1,:,stkP]), 
            unit = r'$\mu$K',
            rot = centerG)
hp.projscatter(hp.pix2ang(nside_new, pixG_ud), marker = '+', color = 'r',)
ax[3].cla()
plt.axes(ax[3])
hp.gnomview(maps220Q_ud[-1,:,stkP], reso = 15, hold = True, 
            notext = True, title = ' ',
            unit = r'$\mu$K',
            rot = centerQ)
hp.projscatter(hp.pix2ang(nside_new, pixQ_ud),marker = '+', color = 'r',)
plt.savefig('Figs-FI-SED/{}_nrec{}_nside{}_pixQ{}_pixG{}_Qstk_Polarization'.format(FuncModel.__name__,
                                                                           d150Q['nf_recon'], 
                                                                           nside_new,pixQ_ud, pixG_ud))
```

```{python}
stkP = 2
RESO = 15
capsize=3
plt.rc('font', size=14)

fig,ax=plt.subplots(nrows=1,ncols=4,figsize=(19,4.5),)
ax=ax.ravel()
# Plotting
ax[0].errorbar(nus_out150, dust_map_150G_ud[:,pixG_ud,stkP],yerr = std150G_ud[:,pixG_ud,stkP], capsize=capsize,
       fmt = 'o', color = 'r',label = 'MC')
ax[0].errorbar(nus_out220, dust_map_220G_ud[:,pixG_ud,stkP],yerr = std220G_ud[:,pixG_ud,stkP], capsize=capsize,
       fmt = 'o', color = 'r')

#ax[0].plot(nus_out150, dust_map_150G_ud[:,pixG_ud,stkP], 'bo-', label = 'convolved')
#ax[0].plot(nus_out220, dust_map_220G_ud[:,pixG_ud,stkP], 'bo-')

ax[0].plot(x150, Umvals150G, 'g-', label = '68% C.L.')
ax[0].fill_between(x150, y1 = Umvals150G - Usvals150G, y2 = Umvals150G + Usvals150G, 
                   color = 'g', alpha = 0.3)
ax[0].plot(x220, Umvals220G , 'g-')
ax[0].fill_between(x220, y1 = Umvals220G - Usvals220G, y2 = Umvals220G + Usvals220G, 
                   color = 'g', alpha = 0.3)

ax[0].axvspan(nus_edge150[-1], nus_edge220[0],color = 'k',alpha = 0.2)

ax[2].errorbar(nus_out150, dust_map_150Q_ud[:,pixQ_ud,stkP], yerr = std150Q_ud[:,pixQ_ud,stkP], 
               capsize = capsize, fmt = 'o', color = 'r', alpha = 0.8)
ax[2].errorbar(nus_out220, dust_map_220Q_ud[:,pixQ_ud,stkP], yerr = std220Q_ud[:,pixQ_ud,stkP], 
               capsize = capsize, fmt='o', color = 'r', alpha = 0.8)
#ax[2].plot(nus_out150, dust_map_150Q_ud[:,pixQ_ud,stkP], 'bo-')
#ax[2].plot(nus_out220, dust_map_220Q_ud[:,pixQ_ud,stkP], 'bo-')
ax[2].plot(x150, Umvals150Q, 'g')
ax[2].fill_between(x150, y1 = Umvals150Q - Usvals150Q, y2 = Umvals150Q + Usvals150Q, 
                   color = 'g', alpha = 0.3)
ax[2].plot(x220, Umvals220Q, 'g')
ax[2].fill_between(x220, y1 = Umvals220Q - Usvals220Q, y2 = Umvals220Q + Usvals220Q, 
                   color = 'g', alpha = 0.3)
ax[2].axvspan(nus_edge150[-1],nus_edge220[0],color='k',alpha=0.2)

# Settings
ax[2].grid(which = 'both')
ax[0].legend(loc = 2,fontsize = 12)
ax[0].grid()
ax[0].set_title('GC patch - {} year'.format(d150G['effective_duration']),fontsize=14)
ax[0].set_ylabel(r'$U(\nu)$ [$\mu$K]',fontsize=14)
ax[0].set_xlabel(r'$\nu$[GHz]',fontsize=14)

ax[2].set_title('QUBIC patch - {} years'.format(d150Q['effective_duration']),fontsize=14)
ax[2].set_ylabel(r'$U(\nu)$ [$\mu$K]',fontsize=14)
ax[2].set_xlabel(r'$\nu$[GHz]',fontsize=14)

# Displaying maps
ax[1].cla()
plt.axes(ax[1])
hp.gnomview(maps150G_ud[-1,:,stkP], reso = 15,hold = True, 
            notext = True, title = ' ',
            max = 0.6*np.max(maps150G_ud[-1,:,stkP]), 
            unit = r'$\mu$K',
            rot = centerG)
hp.projscatter(hp.pix2ang(nside_new, pixG_ud), marker = '+', color = 'r',)
ax[3].cla()
plt.axes(ax[3])
hp.gnomview(maps220Q_ud[-1,:,stkP], reso = 15, hold = True, 
            notext = True, title = ' ',
            unit = r'$\mu$K',
            rot = centerQ)
hp.projscatter(hp.pix2ang(nside_new, pixQ_ud),marker = '+', color = 'r',)
plt.savefig('Figs-FI-SED/{}_nrec{}_nside{}_pixQ{}_pixG{}_Ustk_Polarization'.format(FuncModel.__name__,
                                                                       d150Q['nf_recon'], 
                                                                       nside_new,pixQ_ud, pixG_ud))

```

```{python}

```

### curve_fit 

<!-- #region -->
FuncModel = func353
#FuncModel220 = func220

istk = 0

popt150Q, pcov150Q = curve_fit(FuncModel, nus_out150, maps150Q_ud[:, pixQ_ud, istk], 
                               sigma=Cp150Q_prime[:, :, istk, pixQ_red], absolute_sigma=True,
                              maxfev = 1000000, p0 = [8, 2])
popt220Q, pcov220Q = curve_fit(FuncModel, nus_out220, maps220Q_ud[:, pixQ_ud, istk], 
                               sigma=Cp220Q_prime[:, :, istk, pixQ_red], absolute_sigma=True)
popt150G, pcov150G = curve_fit(FuncModel, nus_out150, maps150G_ud[:, pixG_ud, istk], 
                               sigma=Cp150G_prime[:, :, istk, pixG_red], absolute_sigma=True)
popt220G, pcov220G = curve_fit(FuncModel, nus_out220, maps220G_ud[:, pixG_ud, istk], 
                               sigma=Cp220G_prime[:, :, istk, pixG_red], absolute_sigma=True)

perr150Q = np.sqrt(np.diag(pcov150Q))
perr220Q = np.sqrt(np.diag(pcov220Q))
perr150G = np.sqrt(np.diag(pcov150G))
perr220G = np.sqrt(np.diag(pcov220G))

print("150Q a =", popt150Q[0], "+/-", perr150Q[0])
print("150Q b =", popt150Q[1], "+/-", perr150Q[1])

print("220Q a =", popt220Q[0], "+/-", perr220Q[0])
print("220Q b =", popt220Q[1], "+/-", perr220Q[1])

print("150G a =", popt150G[0], "+/-", perr150G[0])
print("150G b =", popt150G[1], "+/-", perr150G[1])

print("220G a =", popt220G[0], "+/-", perr220G[0])
print("220G b =", popt220G[1], "+/-", perr220G[1])

print(pcov150Q)
print(pcov220Q)
print(pcov150G)
print(pcov220G)
# realisations of fit parameters that take into account the correlations pcov we found
nsamples = 1000
psamples150Q = np.random.multivariate_normal(popt150Q, pcov150Q, nsamples)
psamples220Q = np.random.multivariate_normal(popt220Q, pcov220Q, nsamples)
psamples150G = np.random.multivariate_normal(popt150G, pcov150G, nsamples)
psamples220G = np.random.multivariate_normal(popt220G, pcov220G, nsamples)

x150_cf = np.linspace(nus_edge_out150[0], nus_edge_out150[-1], nsamples)
x220_cf = np.linspace(nus_edge_out220[0], nus_edge_out220[-1], nsamples)

vals150Q = np.zeros((len(x150), nsamples))
vals220Q = np.zeros((len(x220), nsamples))
vals150G = np.zeros((len(x150), nsamples))
vals220G = np.zeros((len(x220), nsamples))

for i in range(len(x150)):
    for j in range(nsamples):
        vals150Q[i, j] = FuncModel(x150[i], *psamples150Q[j, :])
        vals220Q[i, j] = FuncModel(x220[i], *psamples220Q[j, :])
        vals150G[i, j] = FuncModel(x150[i], *psamples150G[j, :])
        vals220G[i, j] = FuncModel(x220[i], *psamples220G[j, :])

mvals150Q_cf, mvals220Q_cf = np.mean(vals150Q, axis=1), np.mean(vals220Q, axis=1)
mvals150G_cf, mvals220G_cf = np.mean(vals150G, axis=1), np.mean(vals220G, axis=1)

svals150Q_cf, svals220Q_cf = np.std(vals150Q, axis=1), np.std(vals220Q, axis=1)
svals150G_cf, svals220G_cf = np.std(vals150G, axis=1), np.std(vals220G, axis=1)

#svals150Q, svals220Q = np.std(vals150Q, axis=1), np.std(vals220Q, axis=1)
#svals150G, svals220G = np.std(vals150G, axis=1), np.std(vals220G, axis=1)

istk = 1

Qpopt150Q, Qpcov150Q = curve_fit(FuncModel, nus_out150, maps150Q_ud[:, pixQ_ud, istk], 
                               sigma=Cp150Q_prime[:, :, istk, pixQ_red], absolute_sigma=True,
                                maxfev = 1000000, p0 = [8, 2])
Qpopt220Q, Qpcov220Q = curve_fit(FuncModel, nus_out220, maps220Q_ud[:, pixQ_ud, istk], 
                               sigma=Cp220Q_prime[:, :, istk, pixQ_red], absolute_sigma=True)
Qpopt150G, Qpcov150G = curve_fit(FuncModel, nus_out150, maps150G_ud[:, pixG_ud, istk], 
                               sigma=Cp150G_prime[:, :, istk, pixG_red], absolute_sigma=True)
Qpopt220G, Qpcov220G = curve_fit(FuncModel, nus_out220, maps220G_ud[:, pixG_ud, istk], 
                               sigma=Cp220G_prime[:, :, istk, pixG_red], absolute_sigma=True)

Qperr150Q = np.sqrt(np.diag(Qpcov150Q))
Qperr220Q = np.sqrt(np.diag(Qpcov220Q))
Qperr150G = np.sqrt(np.diag(Qpcov150G))
Qperr220G = np.sqrt(np.diag(Qpcov220G))

# realisations of fit parameters that take into account the correlations pcov we found
nsamples = 1000
Qpsamples150Q = np.random.multivariate_normal(Qpopt150Q, Qpcov150Q, nsamples)
Qpsamples220Q = np.random.multivariate_normal(Qpopt220Q, Qpcov220Q, nsamples)
Qpsamples150G = np.random.multivariate_normal(Qpopt150G, Qpcov150G, nsamples)
Qpsamples220G = np.random.multivariate_normal(Qpopt220G, Qpcov220G, nsamples)

x150 = np.linspace(nus_edge_out150[0], nus_edge_out150[-1], nsamples)
x220 = np.linspace(nus_edge_out220[0], nus_edge_out220[-1], nsamples)

Qvals150Q = np.zeros((len(x150), nsamples))
Qvals220Q = np.zeros((len(x220), nsamples))
Qvals150G = np.zeros((len(x150), nsamples))
Qvals220G = np.zeros((len(x220), nsamples))

for i in range(len(x150)):
    for j in range(nsamples):
        Qvals150Q[i, j] = FuncModel(x150[i], *Qpsamples150Q[j, :])
        Qvals220Q[i, j] = FuncModel(x220[i], *Qpsamples220Q[j, :])
        Qvals150G[i, j] = FuncModel(x150[i], *Qpsamples150G[j, :])
        Qvals220G[i, j] = FuncModel(x220[i], *Qpsamples220G[j, :])

Qmvals150Q, Qmvals220Q = np.mean(Qvals150Q, axis=1), np.mean(Qvals220Q, axis=1)
Qmvals150G, Qmvals220G = np.mean(Qvals150G, axis=1), np.mean(Qvals220G, axis=1)

Qsvals150Q, Qsvals220Q = np.std(Qvals150Q, axis=1), np.std(Qvals220Q, axis=1)
Qsvals150G, Qsvals220G = np.std(Qvals150G, axis=1), np.std(Qvals220G, axis=1)


istk = 2

Upopt150Q, Upcov150Q = curve_fit(FuncModel, nus_out150, maps150Q_ud[:, pixQ_ud, istk], 
                               sigma=Cp150Q_prime[:, :, istk, pixQ_red], absolute_sigma=True,
                                maxfev = 1000000, p0 = [8, 2])
Upopt220Q, Upcov220Q = curve_fit(FuncModel, nus_out220, maps220Q_ud[:, pixQ_ud, istk], 
                               sigma=Cp220Q_prime[:, :, istk, pixQ_red], absolute_sigma=True)
Upopt150G, Upcov150G = curve_fit(FuncModel, nus_out150, maps150G_ud[:, pixG_ud, istk], 
                               sigma=Cp150G_prime[:, :, istk, pixG_red], absolute_sigma=True)
Upopt220G, Upcov220G = curve_fit(FuncModel, nus_out220, maps220G_ud[:, pixG_ud, istk], 
                               sigma=Cp220G_prime[:, :, istk, pixG_red], absolute_sigma=True)

Uperr150Q = np.sqrt(np.diag(Upcov150Q))
Uperr220Q = np.sqrt(np.diag(Upcov220Q))
Uperr150G = np.sqrt(np.diag(Upcov150G))
Uperr220G = np.sqrt(np.diag(Upcov220G))

# realisations of fit parameters that take into account the correlations pcov we found
nsamples = 1000
Upsamples150Q = np.random.multivariate_normal(Upopt150Q, Upcov150Q, nsamples)
Upsamples220Q = np.random.multivariate_normal(Upopt220Q, Upcov220Q, nsamples)
Upsamples150G = np.random.multivariate_normal(Upopt150G, Upcov150G, nsamples)
Upsamples220G = np.random.multivariate_normal(Upopt220G, Upcov220G, nsamples)

x150 = np.linspace(nus_edge_out150[0], nus_edge_out150[-1], nsamples)
x220 = np.linspace(nus_edge_out220[0], nus_edge_out220[-1], nsamples)

Uvals150Q = np.zeros((len(x150), nsamples))
Uvals220Q = np.zeros((len(x220), nsamples))
Uvals150G = np.zeros((len(x150), nsamples))
Uvals220G = np.zeros((len(x220), nsamples))

for i in range(len(x150)):
    for j in range(nsamples):
        Uvals150Q[i, j] = FuncModel(x150[i], *Upsamples150Q[j, :])
        Uvals220Q[i, j] = FuncModel(x220[i], *Upsamples220Q[j, :])
        Uvals150G[i, j] = FuncModel(x150[i], *Upsamples150G[j, :])
        Uvals220G[i, j] = FuncModel(x220[i], *Upsamples220G[j, :])

Umvals150Q, Umvals220Q = np.mean(Uvals150Q, axis=1), np.mean(Uvals220Q, axis=1)
Umvals150G, Umvals220G = np.mean(Uvals150G, axis=1), np.mean(Uvals220G, axis=1)

Usvals150Q, Usvals220Q = np.std(Uvals150Q, axis=1), np.std(Uvals220Q, axis=1)
Usvals150G, Usvals220G = np.std(Uvals150G, axis=1), np.std(Uvals220G, axis=1)

<!-- #endregion -->

```{python}

```

```{python}

```

```{python}

```

```{python}
istk = 1

Qpopt150Q, Qpcov150Q = curve_fit(FuncModel, nus_out150, maps150Q_ud[:, pixQ_ud, istk], 
                               sigma=Cp150Q_prime[:, :, istk, pixQ_red], absolute_sigma=True)
Qpopt220Q, Qpcov220Q = curve_fit(FuncModel, nus_out220, maps220Q_ud[:, pixQ_ud, istk], 
                               sigma=Cp220Q_prime[:, :, istk, pixQ_red], absolute_sigma=True)
Qpopt150G, Qpcov150G = curve_fit(FuncModel, nus_out150, maps150G_ud[:, pixG_ud, istk], 
                               sigma=Cp150G_prime[:, :, istk, pixG_red], absolute_sigma=True)
Qpopt220G, Qpcov220G = curve_fit(FuncModel, nus_out220, maps220G_ud[:, pixG_ud, istk], 
                               sigma=Cp220G_prime[:, :, istk, pixG_red], absolute_sigma=True)

Qperr150Q = np.sqrt(np.diag(Qpcov150Q))
Qperr220Q = np.sqrt(np.diag(Qpcov220Q))
Qperr150G = np.sqrt(np.diag(Qpcov150G))
Qperr220G = np.sqrt(np.diag(Qpcov220G))

# realisations of fit parameters that take into account the correlations pcov we found
nsamples = 1000
Qpsamples150Q = np.random.multivariate_normal(Qpopt150Q, Qpcov150Q, nsamples)
Qpsamples220Q = np.random.multivariate_normal(Qpopt220Q, Qpcov220Q, nsamples)
Qpsamples150G = np.random.multivariate_normal(Qpopt150G, Qpcov150G, nsamples)
Qpsamples220G = np.random.multivariate_normal(Qpopt220G, Qpcov220G, nsamples)

x150 = np.linspace(nus_edge_out150[0], nus_edge_out150[-1], nsamples)
x220 = np.linspace(nus_edge_out220[0], nus_edge_out220[-1], nsamples)

Qvals150Q = np.zeros((len(x150), nsamples))
Qvals220Q = np.zeros((len(x220), nsamples))
Qvals150G = np.zeros((len(x150), nsamples))
Qvals220G = np.zeros((len(x220), nsamples))

for i in range(len(x150)):
    for j in range(nsamples):
        Qvals150Q[i, j] = FuncModel(x150[i], *Qpsamples150Q[j, :])
        Qvals220Q[i, j] = FuncModel(x220[i], *Qpsamples220Q[j, :])
        Qvals150G[i, j] = FuncModel(x150[i], *Qpsamples150G[j, :])
        Qvals220G[i, j] = FuncModel(x220[i], *Qpsamples220G[j, :])

Qmvals150Q, Qmvals220Q = np.mean(Qvals150Q, axis=1), np.mean(Qvals220Q, axis=1)
Qmvals150G, Qmvals220G = np.mean(Qvals150G, axis=1), np.mean(Qvals220G, axis=1)

Qsvals150Q, Qsvals220Q = np.std(Qvals150Q, axis=1), np.std(Qvals220Q, axis=1)
Qsvals150G, Qsvals220G = np.std(Qvals150G, axis=1), np.std(Qvals220G, axis=1)
```

```{python}
istk = 2

Upopt150Q, Upcov150Q = curve_fit(FuncModel, nus_out150, maps150Q_ud[:, pixQ_ud, istk], 
                               sigma=Cp150Q_prime[:, :, istk, pixQ_red], absolute_sigma=True)
Upopt220Q, Upcov220Q = curve_fit(FuncModel, nus_out220, maps220Q_ud[:, pixQ_ud, istk], 
                               sigma=Cp220Q_prime[:, :, istk, pixQ_red], absolute_sigma=True)
Upopt150G, Upcov150G = curve_fit(FuncModel, nus_out150, maps150G_ud[:, pixG_ud, istk], 
                               sigma=Cp150G_prime[:, :, istk, pixG_red], absolute_sigma=True)
Upopt220G, Upcov220G = curve_fit(FuncModel, nus_out220, maps220G_ud[:, pixG_ud, istk], 
                               sigma=Cp220G_prime[:, :, istk, pixG_red], absolute_sigma=True)

Uperr150Q = np.sqrt(np.diag(Upcov150Q))
Uperr220Q = np.sqrt(np.diag(Upcov220Q))
Uperr150G = np.sqrt(np.diag(Upcov150G))
Uperr220G = np.sqrt(np.diag(Upcov220G))

# realisations of fit parameters that take into account the correlations pcov we found
nsamples = 1000
Upsamples150Q = np.random.multivariate_normal(Upopt150Q, Upcov150Q, nsamples)
Upsamples220Q = np.random.multivariate_normal(Upopt220Q, Upcov220Q, nsamples)
Upsamples150G = np.random.multivariate_normal(Upopt150G, Upcov150G, nsamples)
Upsamples220G = np.random.multivariate_normal(Upopt220G, Upcov220G, nsamples)

x150 = np.linspace(nus_edge_out150[0], nus_edge_out150[-1], nsamples)
x220 = np.linspace(nus_edge_out220[0], nus_edge_out220[-1], nsamples)

Uvals150Q = np.zeros((len(x150), nsamples))
Uvals220Q = np.zeros((len(x220), nsamples))
Uvals150G = np.zeros((len(x150), nsamples))
Uvals220G = np.zeros((len(x220), nsamples))

for i in range(len(x150)):
    for j in range(nsamples):
        Uvals150Q[i, j] = FuncModel(x150[i], *Upsamples150Q[j, :])
        Uvals220Q[i, j] = FuncModel(x220[i], *Upsamples220Q[j, :])
        Uvals150G[i, j] = FuncModel(x150[i], *Upsamples150G[j, :])
        Uvals220G[i, j] = FuncModel(x220[i], *Upsamples220G[j, :])

Umvals150Q, Umvals220Q = np.mean(Uvals150Q, axis=1), np.mean(Uvals220Q, axis=1)
Umvals150G, Umvals220G = np.mean(Uvals150G, axis=1), np.mean(Uvals220G, axis=1)

Usvals150Q, Usvals220Q = np.std(Uvals150Q, axis=1), np.std(Uvals220Q, axis=1)
Usvals150G, Usvals220G = np.std(Uvals150G, axis=1), np.std(Uvals220G, axis=1)
```

```{python}
ErrBar2 = lambda Qerr, Uerr: 1 / np.sqrt(2) * np.sqrt( Qerr ** 2 + Uerr)** 2 / \
                                           np.sqrt( Qerr ** 2 + Uerr ** 2)
```
