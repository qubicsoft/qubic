---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Spectroimaging pixel by pixel

Edited by Louise, 18/06/2020

Edited by Martin, 21/06/2020 (implement FastSimulator)

In this notebook, I try to reproduce what Gabriele has done. Spectroimaging on the galaxy center, compare the reconstruction to the input sky pixel by pixel

```{python}
# %matplotlib inline

import os
import sys
import glob

# Specific science modules
import healpy as hp
import matplotlib.pyplot as plt
import numpy as np
import pickle
# Specific qubic modules
from astropy.io import fits
import qubic
from qubicpack.utilities import Qubic_DataDir
from qubic import QubicSkySim as qss
from qubic.polyacquisition import compute_freq
from qubic import ReadMC as rmc
plt.rc('text',usetex=False)
plt.rc('font', size=16)
```

Implementing FastSimulator

```{python}
# Dictionary saved during the simulation
config = 'FI-150'
global_dir = Qubic_DataDir(datafile='instrument.py', datadir=os.environ['QUBIC_DATADIR'])
#dictfilename = global_dir + '/doc/FastSimulator/FastSimDemo_{}.dict'.format(config)
dictfilename = global_dir + '/dicts/spectroimaging_article.dict'
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictfilename)

# Coordinates of the zone observed in the sky
center = qubic.equ2gal(d['RA_center'], d['DEC_center'])
```

```{python}
QUBICField=False
#if QUBICField:
coverage150Q = np.load(global_dir+'doc/FastSimulator/Data/coverage_nfsub15_nptgs10000_qubicpatch.pk')
simu = fits.open(global_dir+'doc/FastSimulator/Data/coverage_220_nfsub15_nptgs10000_qubicpatch.pk')
#simu = fits.open(global_dir+'doc/FastSimulator/Data/DataFastSimulator_FI220_coverage.pkl')
#simu = fits.open(global_dir+'doc/FastSimulator/Data/DataFastSimulator_FI220_coverage.pkl')
coverage220Q = simu['coverage'].data
centerQ = qubic.equ2gal(d['RA_center'], d['DEC_center'])
#else:
#With no specification between 150 or 220 because is loaded from qss
coverageG = None
centerG = None
```

```{python}
lala=np.where(coverage150Q>0.5*np.max(coverage150Q))
hp.gnomview(coverage150Q,rot=centerQ,reso=15)
hp.projscatter(hp.pix2ang(256,lala),alpha=0.01,color='r')
```

##### QubicSkySim instanciation
seed = None
sky_config_220 = {'dust': 'd1'}
d220=d.copy()
d220['filter_nu']=220*1e9
d220['nf_recon']=5
Qubic_sky_220 = qss.Qubic_sky(sky_config_220, d220)
auxmaps220, noiseless220, _, _ = Qubic_sky_220.get_partial_sky_maps_withnoise(spatial_noise=False, 
                                                                              coverage=coverage)

```{python}
d['nf_recon']=5
d['photon_noise']=True
d220Q=d.copy()
d220Q['filter_nu']=220e9

dG=d.copy()
dG['RA_center'], dG['DEC_center'] = 0,0
d220G = dG.copy()
d220G['filter_nu']=220*1e9

##### QubicSkySim instanciation
seed = 42#None
#sky_config_dust = {'dust': 'd1'}
#Qubic_sky_dust = qss.Qubic_sky(sky_config_dust, d)
#sky_config_cmb = {'cmb': seed}
#Qubic_sky_cmb = qss.Qubic_sky(sky_config_cmb, d)
#sky_config_220_dust = {'dust': 'd1'}
#Qubic_sky_220_dust = qss.Qubic_sky(sky_config_220_dust, d220)
#sky_config_220_cmb = {'cmb': seed}
#Qubic_sky_220_cmb = qss.Qubic_sky(sky_config_220_cmb, d220)

sky_config_150Q = {'dust': 'd1'}
Qubic_sky_150Q = qss.Qubic_sky(sky_config_150Q, d)
sky_config_220Q = {'dust': 'd1'}
Qubic_sky_220Q = qss.Qubic_sky(sky_config_220Q, d220Q)
sky_config_150G = {'dust': 'd1'}
Qubic_sky_150G = qss.Qubic_sky(sky_config_150G, dG)
sky_config_220G = {'dust': 'd1'}
Qubic_sky_220G = qss.Qubic_sky(sky_config_220G, d220G)

##### Getting FastSimulator output maps
mctest = True
if mctest:
    #mcmcmaps = []
    #mcmcmapscmb = []
    #mcmcmaps220=[]
    #mcmcmapscmb220=[]
    mcmc150Q=[]
    mcmc220Q=[]
    mcmc150G=[]
    mcmc220G=[]
    for i in range(15):
        #auxmaps, maps_noiseless, _, coverage = \
        #    Qubic_sky_dust.get_partial_sky_maps_withnoise(spatial_noise=False, coverage=coverage)
        #print('=== Done (dust 150) interation #{} ===='.format(i+1))
        #auxmapscmb, maps_noiseless_cmb, _, coverage_cmb = \
        #    Qubic_sky_cmb.get_partial_sky_maps_withnoise(spatial_noise=False, coverage=coverage)        
        #print('=== Done (cmb 150) interation #{} ===='.format(i+1))
        #auxmaps220, maps_noiseless220, _, coverage220 = \
        #    Qubic_sky_220_dust.get_partial_sky_maps_withnoise(spatial_noise=False, coverage=coverage)
        #print('=== Done (dust 220) interation #{} ===='.format(i+1))
        #auxmaps220cmb, maps_noiseless_220cmb, _, coverage_220cmb = \
        #    Qubic_sky_220_cmb.get_partial_sky_maps_withnoise(spatial_noise=False, coverage=coverage)        
        #print('=== Done (cmb 220) interation #{} ===='.format(i+1))
        auxmaps150Q, maps_noiseless150Q, _, coverage150Q = \
                Qubic_sky_150Q.get_partial_sky_maps_withnoise(spatial_noise=False, coverage=coverage150Q)
        print('=== Done (dust QUBIC 150) interation #{} ===='.format(i+1))
        auxmaps220Q, maps_noiseless220Q, _, coverage220Q = \
                Qubic_sky_220Q.get_partial_sky_maps_withnoise(spatial_noise=False, coverage=coverage220Q)
        print('=== Done (dust QUBIC 220) interation #{} ===='.format(i+1))
        auxmaps150G, maps_noiseless150G, _, coverage150G = \
                Qubic_sky_150G.get_partial_sky_maps_withnoise(spatial_noise=False, coverage=coverageG)
        print('=== Done (dust Galaxy filed 150) interation #{} ===='.format(i+1))
        auxmaps220G, maps_noiseless220G, _, coverage220G = \
                Qubic_sky_220G.get_partial_sky_maps_withnoise(spatial_noise=False, coverage=coverageG)
        print('=== Done (dust Galaxy field 220) interation #{} ===='.format(i+1))
        
        #mcmcmaps.append(auxmaps)
        #mcmcmapscmb.append(auxmapscmb)        
        #mcmcmaps220.append(auxmaps220)
        #mcmcmapscmb220.append(auxmaps220cmb)
        mcmc150Q.append(auxmaps150Q)
        mcmc220Q.append(auxmaps220Q)
        mcmc150G.append(auxmaps150G)
        mcmc220G.append(auxmaps220G)
    #maps_qubic, std_qubic=np.mean(mcmcmaps,axis=0), np.std(mcmcmaps,axis=0)
    #maps_qubic_cmb, std_qubic_cmb = np.mean(mcmcmapscmb,axis=0), np.std(mcmcmapscmb, axis=0)
    #maps_qubic220, std_qubic220=np.mean(mcmcmaps220,axis=0), np.std(mcmcmaps220,axis=0)
    #maps_qubic_cmb220, std_qubic_cmb220 = np.mean(mcmcmapscmb220,axis=0), np.std(mcmcmapscmb220, axis=0)
    maps_qubic150Q, std_qubic150Q = np.mean(mcmc150Q,axis=0), np.std(mcmc150Q, axis=0)
    maps_qubic220Q, std_qubic220Q = np.mean(mcmc220Q,axis=0), np.std(mcmc220Q, axis=0)
    maps_qubic150G, std_qubic150G = np.mean(mcmc150G,axis=0), np.std(mcmc150G, axis=0)
    maps_qubic220G, std_qubic220G = np.mean(mcmc220G,axis=0), np.std(mcmc220G, axis=0)
else: 
    maps_qubic, maps_noiseless, maps_noise, coverage = Qubic_sky.get_partial_sky_maps_withnoise(spatial_noise=False)
    
##### Getting FastSimulator output maps

```

Look at the maps... okk..

```{python}
#print(np.shape(maps_qubic), np.shape(maps_noiseless), np.shape(maps_noise), np.shape(coverage))
cov150Q=np.zeros_like(coverage150Q,dtype=bool)
covmsk150Q=np.where(coverage150Q > 0.01*np.max(coverage150Q))
cov150Q[covmsk150Q] = 1
cov220Q=np.zeros_like(coverage220Q,dtype=bool)
covmsk220Q=np.where(coverage220Q > 0.01*np.max(coverage220Q))
cov220Q[covmsk220Q] = 1

cov150G=np.zeros_like(coverage150G,dtype=bool)
covmsk150G=np.where(coverage150G > 0.01*np.max(coverage150G))
cov150G[covmsk150G] = 1
cov220G=np.zeros_like(coverage220G,dtype=bool)
covmsk220G=np.where(coverage220G > 0.01*np.max(coverage220G))
cov220G[covmsk220G] = 1

NU = 0
STK = 0
RESO = 15
plt.figure(figsize=(12,8))
hp.gnomview(cov150Q,rot=centerQ,reso=RESO,title='150Q',sub=(141))
hp.gnomview(cov220Q,rot=centerQ,reso=RESO,title='220Q',sub=(142))
hp.gnomview(cov150G,rot=centerG,reso=RESO,title='150G',sub=(143))
hp.gnomview(cov220G,rot=centerG,reso=RESO,title='220G',sub=(144))

hp.gnomview(np.array(cov150Q,dtype=int)-np.array(cov220Q,dtype=int),reso=RESO,title='diff150-220Q',sub=(121))
hp.gnomview(np.array(cov150G,dtype=int)-np.array(cov220G,dtype=int),reso=RESO,title='diff150-220G',sub=(122))
#hp.gnomview(maps_qubic150Q[NU,:,STK], sub=(2,3,1), 
#            max=0.1*np.max(maps_qubic150Q[NU,:,STK]), title='150 rec QUBIC patch', reso=RESO, rot=center)
#hp.gnomview(maps_noiseless150Q[NU,:,STK], sub=(2,3,2), 
#            max=0.1*np.max(maps_noiseless150Q[NU,:,STK]), title='150 nl', reso=RESO, rot=center)
#hp.gnomview(cov150Q, sub=(2,3,3), title='covmsk', reso=RESO, rot=center)##

#hp.gnomview(maps_qubic220Q[NU,:,STK], sub=(2,3,4), title='220 rec QUBIC patch', reso=RESO, rot=center)
#hp.gnomview(maps_noiseless220Q[NU,:,STK], sub=(2,3,5), title='220 nl', reso=RESO, rot=center)
#hp.gnomview(cov150G, sub=(2,3,6), title='covmsk', reso=RESO, rot=centerG)

```

```{python}
_,nus_edge,nus,_,_,_=qubic.compute_freq(d['filter_nu']/1e9, d['nf_recon'], d['filter_relative_bandwidth'] )
_,nus_edge_220,nus_220,_,_,_=qubic.compute_freq(d220Q['filter_nu']/1e9, d220Q['nf_recon'], 
                                                d220Q['filter_relative_bandwidth'] )
_,nus_edge_in,nus_in,_,_,_=qubic.compute_freq(d['filter_nu']/1e9, d['nf_sub'], 
                                              d['filter_relative_bandwidth'] )
```

```{python}
testdust=Qubic_sky_150Q.get_simple_sky_map()
```

tema=hp.gnomview(maps_qubic150G[-1,:,0], reso=15,notext=True,title=' ',return_projected_map=True,
                max=5e3, rot=centerG,cbar=False, no_plot=True)
fultema=hp.mollview(testdust[8,:,0], max = 5e3, coord='C',notext=True, title=' ',
                    return_projected_map=True,)
plt.clf()
fig, axmap = plt.subplots(nrows=1,ncols=1, figsize=(12,12))
#plt.axes(axmap)
axmap.imshow(fultema,vmax=5e3)
axins = axmap.inset_axes([0.3, 0.65, 0.2, 0.3])
axins.imshow(tema, interpolation="nearest",
          origin="lower",vmax=5e3)
axins.set_xticklabels('')
axins.set_yticklabels('')
#print(axmap.get_ylim())
#axins.set_xlim(0.4,0.6)
#axins.set_ylim(0.4,0.6)
#axins.indicate_inset_zoom([0.4,0.6,0.4,0.6])


```{python}
mctest=True
capsize=3
plt.rc('font', size=15)
for j,ipx in enumerate(range(600,12000,500)):
    fig,ax=plt.subplots(nrows=1,ncols=4,figsize=(16,4),)
    ax=ax.ravel()
    IPIXQ = covmsk150Q[0][ipx]
    IPIXG = covmsk220G[0][ipx]
    if mctest:
        ax[0].errorbar(nus, maps_qubic150G[:,IPIXG,0],yerr=std_qubic150G[:,IPIXG,0], capsize=capsize,
               fmt='o-', color='r',label='reconstructed', alpha=0.8)
        ax[0].errorbar(nus_220, maps_qubic220G[:,IPIXG,0],yerr=std_qubic220G[:,IPIXG,0], capsize=capsize,
               fmt='o-', color='r', alpha=0.8)
        ax[0].plot(nus, maps_noiseless150G[:,IPIXG,0],
               'bo-',label='convolved', alpha=0.7)
        ax[0].plot(nus_220, maps_noiseless220G[:,IPIXG,0],
               'bo-', alpha=0.7)
        ax[0].axvspan(nus[-1],nus_220[0],color='k',alpha=0.2)
        
        ax[2].errorbar(nus, maps_qubic150Q[:,IPIXQ,0],yerr=std_qubic150Q[:,IPIXQ,0], capsize=capsize,
               fmt='o-', color='r',label='reconstructed', alpha=0.8)
        ax[2].errorbar(nus_220, maps_qubic220Q[:,IPIXQ,0],yerr=std_qubic220Q[:,IPIXQ,0], capsize=capsize,
               fmt='o-', color='r',alpha=0.8)
        ax[2].plot(nus, maps_noiseless150Q[:,IPIXQ,0],
               'bo-',label='input', alpha=0.7)
        ax[2].plot(nus_220, maps_noiseless220Q[:,IPIXQ,0],
               'bo-', alpha=0.5)
        
        ax[2].grid(which='both')
        ax[2].axvspan(nus[-1],nus_220[0],color='k',alpha=0.2)
        
    ax[0].set_title('GC patch',fontsize=17)
    ax[0].set_ylabel(r'$I_\nu$ [$\mu$K]',fontsize=18)
    ax[0].set_xlabel(r'$\nu$[GHz]',fontsize=18)
    ax[2].set_title('QUBIC patch',fontsize=17)
    #ax[2].set_ylabel(r'$I_\nu$ [$\mu$K]',fontsize=18)
    ax[2].set_xlabel(r'$\nu$[GHz]',fontsize=18)
    ax[0].legend(loc='best',fontsize=12)
    ax[0].grid()
    ax[1].cla()
    plt.axes(ax[1])
    hp.gnomview(maps_qubic150G[-1,:,0], reso=15,hold=True,notext=True,title=' ',#'{:.1f}GHz'.format(nus[0]),
                max=0.3*np.max(maps_qubic150G[0,:,0]), rot=centerG)
    hp.projscatter(hp.pix2ang(d['nside'],IPIXG),marker='+',color='r',)
    ax[3].cla()
    plt.axes(ax[3])
    hp.gnomview(maps_qubic150Q[-1,:,0], reso=15,hold=True,notext=True,title=' ',#'{:.1f}GHz'.format(nus[0]),
                max=np.max(maps_qubic150Q[0,:,0]), rot=centerQ)
    hp.projscatter(hp.pix2ang(d['nside'],IPIXQ),marker='+',color='r',)

plt.show()

```

Do same plots averaging and/or computing rms in maps

```{python}
mq = maps_qubic.copy()
mq220=maps_qubic220.copy()
```

```{python}
mq = maps_qubic.copy()
mq220 = maps_qubic220.copy()
#import gc
#gc.collect()
dvals=[]
dvals220=[]
cvals=[]
cvals220=[]
#mq = maps_qubic
threshold=0.08
fig,ax=plt.subplots(nrows=3,ncols=d['nf_recon'],figsize=(12,10),)
for ifreq in range(d['nf_recon']):
    auxmap = mq[ifreq,:,0]
    auxmap[~cov]=hp.UNSEEN
    auxmap[auxmap>threshold*max(auxmap)] = hp.UNSEEN
    mask=np.where(auxmap!=hp.UNSEEN)
    dvals.append(np.sqrt(np.sum(maps_qubic[ifreq,mask[0],0]**2)/len(mask[0]) ))
    cvals.append(np.sqrt(np.sum(maps_qubic_cmb[ifreq,mask[0],0]**2)/len(mask[0]) ))
    ax[0,ifreq].cla()
    plt.axes(ax[0,ifreq])
    hp.gnomview(auxmap, reso=15,hold=True,notext=True,title='{:.1f}GHz'.format(nus[ifreq]),
               min=-10, max=0.2*np.max(maps_qubic[ifreq,cov,0]), rot=center )

for ifreq in range(d['nf_recon']):
    auxmap = mq220[ifreq,:,0]
    auxmap[~cov]=hp.UNSEEN
    auxmap[auxmap>threshold*max(auxmap)] = hp.UNSEEN
    mask220=np.where(auxmap!=hp.UNSEEN)
    dvals220.append(np.sqrt(np.sum(maps_qubic220[ifreq,mask220[0],0]**2)/len(mask220[0]) ))
    cvals220.append(np.sqrt(np.sum(maps_qubic_cmb220[ifreq,mask220[0],0]**2)/len(mask220[0]) ))
    ax[2,ifreq].cla()
    plt.axes(ax[2,ifreq])
    hp.gnomview(auxmap, reso=15,hold=True,notext=True,title='{:.1f}GHz'.format(nus_220[ifreq]),
               min=-10, max=0.2*np.max(maps_qubic220[ifreq,cov,0]), rot=center )

    
#ax=ax.ravel()
gs = ax[1,1].get_gridspec()
# remove the underlying axes
for iax in ax[1,0:]:
    iax.remove()
axbig = fig.add_subplot(gs[1,1:-1])
#axbig.set_yscale('log')
axbig.plot(nus, dvals,
       'r-', lw=4,label='Dust', alpha=1)
axbig.plot(nus_220, dvals220,
       'r-', lw=4,label=None, alpha=1)
axbig.plot(nus, cvals,
        'g-',lw=4,label='CMB' , alpha=1)
axbig.plot(nus_220, cvals220,
        'g-',lw=4,label=None , alpha=1)
axbig.axvspan(nus[-1],nus_220[0],color='k',alpha=0.2)
axbig.set_ylabel(r'$rms$ [$\mu$K]',)
axbig.set_xlabel(r'$\nu$[GHz]',)
axbig.set_title(r'R2 - mask {:.1f}% I$_{{\rm max}}$'.format(threshold*100))
axbig.legend(bbox_to_anchor=(0.83, 0.5, 0.5, 0.5),fontsize=12)
axbig.grid()
#for iax in range(d['nf_recon']):
#    ax[0,iax].cla()
#    plt.axes(ax[0,iax])
#    hp.gnomview(auxmap, reso=15,hold=True,notext=True,title='{:.1f}GHz'.format(nus[0]),
#               max=np.max(auxmap))
    
```

Test degrading map to recover Louise and Gabriele results..


newnside=8
degqubic_rec = hp.ud_grade(maps_qubic[:,:,0], newnside)
degqubic_conv = hp.ud_grade(maps_noiseless[:,:,0], newnside)

IPIXnew = hp.ang2pix(newnside, hp.pix2ang(d['nside'],IPIX)[0],hp.pix2ang(d['nside'],IPIX)[1])

fig,ax=plt.subplots(nrows=1,ncols=2,figsize=(12,4))
ax[0].plot(nus, degqubic_rec[:,IPIXnew],'ro', label='recon', alpha=0.5)
ax[0].plot(nus, degqubic_conv[:,IPIXnew], 'bo', alpha=0.5,label='convolved')
ax[0].plot(nus_in, inputmaps[:,IPIXnew,0], 'go', label='input')
ax[0].legend()
ax[0].grid()

plt.axes(ax[1])
hp.gnomview(degqubic_rec[0,:], reso=15,hold=True,notext=True,title=' ')
hp.projscatter(hp.pix2ang(newnside,IPIXnew),marker='+',color='r',)


```{python}

```

```{python}

```

### Without FastSimulator

```{python}
nfrecon = 3
datadir = os.environ['DATA_SPECTROIM']
rep = datadir + f'simu_nersc_dust_fullpipeline/nfrecon{nfrecon}/'
print(rep)
dictionary = glob.glob(rep + '/*.dict')[0]
print(dictionary)

# Dictionary saved during the simulation
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictionary)

# Coordinates of the zone observed in the sky
center = qubic.equ2gal(d['RA_center'], d['DEC_center'])

# Number of subbands used during the simulation

nfsub = d['nf_sub']
print('nf_sub = {}, nf_recon = {}'.format(nfsub, nfrecon))

# Get fits files names in a list
fits_noise = np.sort(glob.glob(rep + '*_nfsub{}_nfrecon{}_noiselessFalse*.fits'.format(nfsub, nfrecon), 
                              recursive=True))
fits_noiseless = np.sort(glob.glob(rep + '*_nfsub{}_nfrecon{}_noiselessTrue*.fits'.format(nfsub, nfrecon), 
                              recursive=True))

print(fits_noiseless)
```

```{python}
# Input sky
seed = 42
sky_config = {'dust': 'd1'}
Qubic_sky = qss.Qubic_sky(sky_config, d)
x0 = Qubic_sky.get_simple_sky_map()
print('Input map with shape:', x0.shape)
hp.mollview(x0[2,:,0],rot=center)

Nfreq_edges, nus_edge, nus, deltas, Delta, Nbbands = compute_freq(150, nfsub)
```

```{python}
# Number of noise realisations
nreals = len(fits_noise)
print('nreals = ', nreals)

# Get seen map (observed pixels)
seenmap = rmc.get_seenmap(fits_noiseless[0])
print(seenmap.shape)
thepix_old = np.where(seenmap)[0]

# Number of pixels and nside
npix = len(seenmap)
ns = d['nside']

```

```{python}
np.where(seenmap)
```

```{python}
# Get maps
_, _, nus_rec, _, _, _ = compute_freq(150, nfrecon)

maps_recon = np.empty((nreals, nfrecon, npix, 3))
maps_conv = np.empty((nreals, nfrecon, npix, 3))
for i, real in enumerate(fits_noise):
    maps_recon[i], maps_conv[i], _ = rmc.get_maps(real)

```

```{python}
# Decrease NSIDE
nside_new = 8
seenmap_dgrad = hp.ud_grade(seenmap, nside_new)
thepix = np.where(seenmap_dgrad)[0]
print(thepix)

x0_dgrad = np.zeros((len(nus), 12*nside_new**2, 3))
for nu in range(len(nus)):
    for istk in range(3):
        x0_dgrad[nu, :, istk] = hp.ud_grade(x0[nu, :, istk], nside_new)

hp.mollview(x0_dgrad[0, :, 0]*seenmap_dgrad)

maps_recon_dgrad = np.zeros((nreals, len(nus_rec), 12*nside_new**2, 3))
for real in range(nreals):
    for nu in range(len(nus_rec)):
        for istk in range(3):
            maps_recon_dgrad[real, nu, :, istk] = hp.ud_grade(maps_recon[real, nu, :, istk], nside_new)

maps_conv_dgrad = np.zeros((nreals, len(nus_rec), 12*nside_new**2, 3))
for real in range(nreals):
    for nu in range(len(nus_rec)):
        for istk in range(3):
            maps_conv_dgrad[real, nu, :, istk] = hp.ud_grade(maps_conv[real, nu, :, istk], nside_new)


```

```{python}
len(thepix_old)
```

```{python}
istk = 0
for pix in range(2000, 2020):
    pix = thepix_old[pix]
    plt.figure()

    plt.plot(nus, x0[:, pix, istk], 'go', label='Input sky')
    plt.plot(nus_rec, np.mean(maps_conv[:, :, pix, istk], axis=0), 'bo', label='convolved sky')
    plt.errorbar(nus_rec, np.mean(maps_recon[:, :, pix, istk], axis=0),
                 yerr=np.std(maps_recon[:, :, pix, istk], axis=0), 
                 fmt='o', color='r',
                 label='recon sky')
    plt.legend()
    plt.title('Pixel {}, NSIDE=256'.format(pix))
    plt.xlabel('Frequency [GHz]')
    plt.ylabel('I (µK)')
#     plt.close()
```

```{python}
len(thepix)
```

```{python}
istk = 1
Stokes = ['I', 'Q', 'U']
for i in range(20):
    pix = thepix[i]
    plt.figure(figsize=(15, 4))
    plt.subplot(121)
    plt.plot(nus, x0_dgrad[:, pix, istk], 'go', label='Input sky')
    plt.plot(nus_rec, np.mean(maps_conv_dgrad[:, :, pix, istk], axis=0), 'bo', label='convolved sky')

    plt.errorbar(nus_rec, np.mean(maps_recon_dgrad[:, :, pix, istk], axis=0),
                 yerr=np.std(maps_recon_dgrad[:, :, pix, istk], axis=0), 
                 fmt='o', color='r',
                 label='recon sky')
    plt.legend()
    plt.title('Pixel {}, NSIDE=8, {}'.format(pix, Stokes[istk]))
    plt.xlabel('Frequency [GHz]')
    plt.ylabel('I [µK]')

    x0copie = x0_dgrad[0, :, istk].copy()
    x0copie[pix] = -10
    hp.mollview(x0copie*seenmap_dgrad, sub=(122), title='Pixel {}'.format(pix))


    
```

# Compare input sky and convolution


### Try just with Healpy

```{python}
# Make a sky with dust
nfrecon = 5
d['nside'] = 4
d['nf_sub'] = nfrecon
q = qubic.QubicMultibandInstrument(d)
_, _, nus_rec, _, _, _ = compute_freq(150, nfrecon)


sky_config = {'dust': 'd1'}#, 'cmb': seed} 
Qubic_sky = qss.Qubic_sky(sky_config, d)
sky = Qubic_sky.get_simple_sky_map()

hp.mollview(sky[0, :, 0])

# Go to NSIDE=128
sky128 = np.zeros((nfrecon, 12*128**2, 3))
for i in range(nfrecon):
    for istk in range(3):
        sky128[i, :, istk] = hp.ud_grade(sky[i, :, istk], 128)
    
# Smooth the sky with 
sky_conv = np.zeros_like(sky128)
for i in range(nfrecon):
    freq = q[i].filter.nu
    print('freq:', freq)
    fwhm = q[i].synthbeam.peak150.fwhm * (150e9 / freq)
    print('\n FWHM:', fwhm * 60)
    for istk in range(3):
        sky_conv[i, :, istk] = hp.sphtfunc.smoothing(sky128[i, :, istk], fwhm)

```

```{python}
q[i].synthbeam.peak150.fwhm * 60
```

```{python}
# Decrease seenmap NSIDE to get pixels seen 
nside_new = 128
seenmap_dgrad = hp.ud_grade(seenmap, nside_new)
thepix = np.where(seenmap_dgrad)[0]
print(len(thepix))

```

### Add the qubic convolution

```{python}
# Get the convolved sky using qubic soft
_, nus_edge_rec, nus_rec, _, _, _ = compute_freq(150, nfrecon)
q = qubic.QubicMultibandInstrument(d)
p = qubic.get_pointing(d)
s = qubic.QubicScene(d)
a = qubic.QubicMultibandAcquisition(q, p, s, d, nus_edge_rec)
tod, skyqubic_conv = a.get_observation(sky) 

skyqubic_conv = np.array(skyqubic_conv)
```

```{python}
np.max(sky128)
```

```{python}
IPIXnew = hp.ang2pix(8, hp.pix2ang(d['nside'],IPIX)[0],hp.pix2ang(d['nside'],IPIX)[1])
print(IPIXnew)
```

```{python}
# istk = 0
Stokes = ['I', 'Q', 'U']
for i in range(6000):
    pix = thepix[i]
    cond1 = np.abs(sky128[4, pix, istk] - sky128[0, pix, istk]) < 50
    cond2 = np.abs(sky128[0, pix, istk] - sky_conv[0, pix, istk]) > np.abs(sky128[4, pix, istk] - sky_conv[4, pix, istk])
    if cond2:
        plt.figure(figsize=(15, 4))

        plt.subplot(131)
        plt.plot(nus_rec, sky128[:, pix, istk], 'ro', alpha=0.5, label=f'Input sky')
        plt.plot(nus_rec, sky_conv[:, pix, istk], 'bo', alpha=0.5, label=f'Convolution with Healpix')
    #     plt.plot(nus_rec, skyqubic_conv[:, pix, istk], 'go', alpha=0.5, label='Covolution with qubic soft')

        plt.legend()
        plt.title('Pixel {}, NSIDE=2, {}'.format(pix, Stokes[istk]))
        plt.xlabel('Frequency [GHz]')
        plt.ylabel('I [µK]')

        theta, phi = hp.pix2ang(128, pix)
    #     print(theta, phi)

        hp.gnomview(sky128[0, :, 0]*seenmap_dgrad, sub=(132), title='Pixel {} input'.format(pix), 
                    rot=center, reso=30)
        hp.visufunc.projscatter(theta, phi, color='r')
        print(sky128[0, pix, 0], sky128[3, pix, 0])
    #     hp.visufunc.projtext(theta, phi, sky[0, pix, 0], color='r')

        hp.gnomview(sky_conv[3, :, 0]*seenmap_dgrad, sub=(133), title='Pixel {} conv'.format(pix), 
                    rot=center, reso=30)
        hp.visufunc.projscatter(theta, phi, color='r')
    #     hp.visufunc.projtext(theta, phi, sky[3, pix, 0], color='r')



```

```{python}

```
