---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
# %matplotlib inline

import os
import sys
import glob

# Specific science modules
import healpy as hp
import matplotlib.pyplot as plt
import numpy as np
import emcee
import corner

# Specific qubic modules
from astropy.io import fits
import qubic
from qubicpack.utilities import Qubic_DataDir
from qubic import QubicSkySim as qss
from qubic.polyacquisition import compute_freq
from qubic import ReadMC as rmc
from qubic import AnalysisMC as amc

plt.rc('text',usetex=False)
plt.rc('font', size=14)
```

```{python}
### Initialize
global_dir = Qubic_DataDir(datafile='instrument.py', datadir=os.environ['QUBIC_DATADIR'])
print(global_dir)

```

```{python}
# Dictionary saved during the simulation
freq = 220 #GHz

d = qubic.qubicdict.qubicDict()
d.read_from_file('spectroimaging_article_gal.dict')

d['filter_nu'] = freq * 1e9
print(d['config'])

Qubicpatch = False
if Qubicpatch:
    d['RA_center'] = 0.
    d['DEC_center'] = -57.
    coverage = np.load(global_dir + 'data/FastSimulator_version01/DataFastSimulator_FI150Q_coverage.npy')
else:
    coverage = np.load(global_dir + 'data/FastSimulator_version01/DataFastSimulator_FI150G_coverage.npy')


# Coordinates of the zone observed in the sky
center = qubic.equ2gal(d['RA_center'], d['DEC_center'])
                       
nbands = 5
d['nf_recon'] = nbands
d['nf_sub'] = nbands

d['nside'] = 256
```

```{python}
_, _, nus, _, _, _ = compute_freq(freq, nbands)
print(nus)
```

#### Make skies

PySM dust models:

d1: Thermal dust is modelled as a single-component modified black body (mbb). We use dust templates for emission at 545 GHz in intensity and 353 GHz in polarisation from the Planck-2015 analysis, and scale these to different frequencies with a mbb spectrum using the spatially varying temperature and spectral index obtained from the Planck data using the Commander code (Planck Collaboration 2015, arXiv:1502.01588). Note that it therefore assumes the same spectral index for polarization as for intensity. The input intensity template at 545 GHz is simply the available 2048 product degraded to nside 512. The polarization templates have been smoothed with a Gaussian kernel of FWHM 2.6 degrees, and had small scales added via the procedure described in the accompanying paper.

d0: Simplified version of the d1 model with a fixed spectral index of 1.54 and a black body temperature of 20 K.

```{python}
sky_config = {'dust':'d0'}#, 'cmb':seed}#, 'synchrotron':'s1'}
Qubic_sky = qss.Qubic_sky(sky_config, d)
conv = Qubic_sky.get_fullsky_convolved_maps(FWHMdeg=None, verbose=True)
pysm = Qubic_sky.get_simple_sky_map()

# Getting noise realisations with FastSimulator
# nreals = 50
# npix = 12 * d['nside'] ** 2
# noisemaps = np.zeros((nreals, nbands, npix, 3))
# for r in range(nreals):
#     noisemaps[r, ...], coverage = Qubic_sky.get_partial_sky_maps_withnoise(coverage=mycoverage,
#                                                                            noise_only=True,
#                                                                            spatial_noise=False,
#                                                                            Nyears=3.)

# # Make maps QUBIC = noise + dust
# qubicmaps = np.zeros_like(noisemaps)
# for r in range(nreals):
#     qubicmaps[r, ...] = noisemaps[r, ...] + conv

unseen = coverage < np.max(coverage) * 0.1
seenmap = np.invert(unseen)
# qubicmaps[:, :, unseen, :] = hp.UNSEEN
# noisemaps[:, :, unseen, :] = hp.UNSEEN
conv[:, unseen, :] = 0.#hp.UNSEEN
pysm[:, unseen, :] = 0.#hp.UNSEEN
```

```{python}
# look at the maps
real = 0
iband = 0
istk = 0

plt.figure(figsize=(15,7))
hp.gnomview(pysm[iband, :, istk], reso=15, rot=center, sub=(131), title='Pysm map')
hp.gnomview(conv[iband, :, istk], reso=15, rot=center, sub=(132), title='Input map convolved')
# hp.gnomview(noisemaps[real, iband, :, istk], reso=15, rot=center, sub=(133), title='Noise map')
# hp.gnomview(qubicmaps[real, iband, :, istk], reso=15, rot=center, sub=(133), title='QUBIC map')
```

```{python}
# Decrease NSIDE
nside_new = 32
npix_new = 12*nside_new**2
seenmap_dgrad = hp.ud_grade(seenmap, nside_new)
thepix = np.where(seenmap_dgrad)[0]
# print(thepix)

# qubicmaps_dgrad = np.zeros((nreals, nbands, 12*nside_new**2, 3))
# noisemaps_dgrad = np.zeros((nreals, nbands, 12*nside_new**2, 3))
# for real in range(nreals):
#     for nu in range(nbands):
#         qubicmaps_dgrad[real, nu, :, :] = hp.ud_grade(qubicmaps[real, nu, :, :].T, nside_new).T
#         noisemaps_dgrad[real, nu, :, :] = hp.ud_grade(noisemaps[real, nu, :, :].T, nside_new).T

conv_dgrad = np.zeros((nbands, npix_new, 3))
pysm_dgrad = np.zeros((nbands, npix_new, 3))
for nu in range(nbands):
    conv_dgrad[nu, :, :] = hp.ud_grade(conv[nu, :, :].T, nside_new).T
    pysm_dgrad[nu, :, :] = hp.ud_grade(pysm[nu, :, :].T, nside_new).T

istk = 0
plt.figure(figsize=(15, 7))
hp.gnomview(pysm_dgrad[iband, :, istk], reso=20, rot=center, sub=(121), title='PySM dgrad')
hp.gnomview(conv_dgrad[iband, :, istk], reso=20, rot=center, sub=(122), title='Conv map dgrad')
```

```{python}
# Cp = amc.get_Cp(noisemaps_dgrad[:, :, seenmap_dgrad, :])
# print(Cp.shape)

# N, Cp_prime = amc.Cp2Cp_prime_viaCorr(Cp)
# print(Cp_prime.shape)

# plt.figure()
# plt.imshow(Cp_prime[:, :, 0, 0])
# plt.colorbar()
```

### Choose a pixel

```{python}
seenpix = np.where(pysm_dgrad[0, :, 0] != 0.)[0]
seenpix.shape

```

```{python}
istk = 0
pix = hp.ang2pix(nside_new, np.pi/2-np.radians(center[1]), np.radians(center[0]))
print(pix)

# themean = np.mean(qubicmaps_dgrad[:, :, pix, istk], axis=0)
# thestd = np.std(qubicmaps_dgrad[:, :, pix, istk], axis=0)
```

```{python}
for pix in seenpix:#[300:305]:
    print(pysm_dgrad[-1, pix, istk] - pysm_dgrad[0, pix, istk])
    fig, (ax0, ax1) = plt.subplots(1, 2, figsize=(15, 6) )
    # plt.subplot(121)
    ax0.plot(nus, pysm_dgrad[:, pix, istk], 'bo', label='PySM Sky')
    ax0.plot(nus, conv_dgrad[:, pix, istk], 'ro', label='Sky convolved')
    # ax0.errorbar(nus, themean,
    #              yerr=thestd, 
    #              fmt='o', 
    #              color='r',
    #              label='recon sky')
    ax0.set_title(f'PIX {pix}')
    ax0.legend()
    # ax0.set_title(f'Pixel {thepix[indexPIX]}')
    ax0.set_xlabel('Frequency [GHz]')
    if istk == 0:
        ax0.set_ylabel(r'$I$ [µK]')
    else:
        ax0.set_ylabel(r'$P$ [µK]')
    ax0.grid()

    plt.axes(ax1)
    hp.gnomview(conv_dgrad[iband, :, istk], reso=20, rot=center, title='Conv map', hold=True)
    hp.projscatter(hp.pix2ang(nside_new, pix), marker = '+', color = 'r', s=200)
```

```{python}
# Convert the maps in K_RJ
import pysm3
import pysm3.models.dust as dust
import pysm3.units as u

pysm_RJ = np.zeros_like(pysm_dgrad)
conv_RJ = np.zeros_like(conv_dgrad)
pysm_Jy = np.zeros_like(pysm_dgrad)
conv_Jy = np.zeros_like(conv_dgrad)
for i, nu in enumerate(nus):
    CMB_to_RJ = u.cmb_equivalencies(nu*u.GHz)[0][2]
    pysm_RJ[i, :, :] = CMB_to_RJ(pysm_dgrad[i, :, :])
    conv_RJ[i, :, :] = CMB_to_RJ(conv_dgrad[i, :, :])
    
    CMB_to_Jy = u.cmb_equivalencies(nu*u.GHz)[2][2]
    pysm_Jy[i, :, :] = CMB_to_Jy(pysm_dgrad[i, :, :])
    conv_Jy[i, :, :] = CMB_to_Jy(conv_dgrad[i, :, :])

```

## FIT

```{python}
from scipy.optimize import curve_fit
import scipy.constants as const

def mbb(nu, A, beta):
    h = const.h
    k = const.k
    Tdust = 20
    nu_0 = 545
    blackbody = dust.blackbody_nu(nu, Tdust)
    mblackbody = A * 1e16* blackbody * (nu / nu_0)**(beta)
    return mblackbody 

beta_pysm = np.zeros((npix_new, 3))
beta_conv = np.zeros((npix_new, 3))
istk = 0
for pix in seenpix:
    popt, pcov = curve_fit(mbb, nus, pysm_RJ[:, pix, istk], sigma=None, absolute_sigma=True)
    beta_pysm[pix, istk] = popt[1]
    print("beta =", popt[1], "+/-", perr[1])
        
    popt, pcov = curve_fit(mbb, nus, conv_RJ[:, pix, istk], sigma=None, absolute_sigma=True)
    beta_conv[pix, istk] = popt[1]
    
    perr = np.sqrt(np.diag(pcov))
#     print("A =", popt[0], "+/-", perr[0])
#     print("beta =", popt[1], "+/-", perr[1])
```

```{python}
x = np.linspace(nus[0]-5, nus[-1]+5, 100)
plt.figure()

plt.plot(nus, conv_RJ[:, pix, istk], 'bo', label='PySM sky')

# plt.errorbar(nus, 
#              themean,
#              yerr=thestd, 
#              fmt='o', print(pcov)
#              color='r',
#              label='recon sky')

popt_up = popt + perr
popt_down = popt - perr

y  = mbb(x, *popt)
y1 = mbb(x, *popt_up)
y2 = mbb(x, *popt_down)

plt.plot(x, y, 'g-', label='Curve fit')
plt.plot(x, y1, 'g--')
plt.plot(x, y2, 'g--')
plt.fill_between(x, y1, y2, facecolor='g', alpha=0.15)

plt.legend()
plt.title('Pixel {}'.format(pix))
plt.xlabel('Frequency [GHz]')
if istk == 0:
    plt.ylabel(r'$I$ [µK]')
else:
    plt.ylabel(r'$P$ [µK]')
plt.grid()
```

```{python}
plt.figure(figsize=(13, 7))
hp.gnomview(beta_pysm[:, istk], reso=20, rot=center, sub=(131), title='beta PySM', min=1.6, max=1.7)
hp.gnomview(beta_conv[:, istk], reso=20, rot=center, sub=(132), title='beta conv', min=1.6, max=1.7)
hp.gnomview(beta_conv[:, istk] - beta_pysm[:, istk], reso=20, rot=center, sub=(133), title='Diff')
```

```{python}
# realisations of fit parameters that have the correlations pcov we found
nsamples = 1000
psamples = np.random.multivariate_normal(popt, pcov, nsamples)
print(psamples.shape)

plt.errorbar(nus, 
             themean,
             yerr=thestd, 
             fmt='o', 
             color='r',
             label='recon sky')
for i in range(1000):
    plt.plot(x, func(x, *psamples[i, :]), 'b', alpha=0.01)
    
plt.legend()
plt.title('Pixel {}'.format(pix))
plt.xlabel('Frequency [GHz]')
if istk == 0:
    plt.ylabel(r'$I$ [µK]')
else:
    plt.ylabel(r'$P$ [µK]')
plt.grid()
```

```{python}
vals = np.zeros((len(x), nsamples))
for i in range(len(x)):
    for j in range(nsamples):
        vals[i, j] = func(x[i], *psamples[j, :])

mvals = np.mean(vals, axis=1)
svals = np.std(vals, axis=1)

```

```{python}
plt.plot(nus, inputmaps_dgrad[:, pix, istk], 'ko', label='Input sky')

plt.errorbar(nus, 
             themean,
             yerr=thestd, 
             fmt='o', 
             color='r',
             label='recon sky')
y1 =  mvals + svals
y2 = mvals - svals
plt.plot(x, mvals, 'b', label='Curve fit')
plt.plot(x, y1, 'b--', label='1 sigma')
plt.plot(x, y2, 'b--')
plt.fill_between(x, y1, y2, facecolor='b', alpha=0.15)

# plt.plot(x, mvals + 3*svals, 'b:', label='3 sigma')
# plt.plot(x, mvals - 3*svals, 'b:')

plt.legend()
plt.title('Curve fit - Pixel {}'.format(pix))
plt.xlabel('Frequency [GHz]')
if istk == 0:
    plt.ylabel(r'$I$ [µK]')
else:
    plt.ylabel(r'$P$ [µK]')
plt.grid()

```

```{python}
fig = corner.corner(psamples, labels=["$a$", "$b$"],
                      truths=[afit, bfit])
```

## With a MCMC

```{python}
def chi2(theta, x, y, icov):
    a, b = theta
    model = func(x, a, b)
    return ((y-model).T @ icov) @ (y-model)

def lnlike(theta, x, y, icov):
    return - 0.5 * chi2(theta, x, y, icov)
```

```{python}
invCp_prime = np.linalg.inv(Cp_prime[:, :, istk, indexPIX])
```

```{python}
# Sample the distribution using emcee
ndim = 2
nwalkers = 100

# Initial guess: small gaussian distrib around the results we get from the linear fit
pos = [popt + 1e-4*np.random.randn(ndim) for i in range(nwalkers)]

# Make a sampler and run it
sampler = emcee.EnsembleSampler(nwalkers, ndim, lnlike, args=(nus, themean, invCp_prime))
sampler.run_mcmc(pos, 1000)
```

```{python}
print(sampler.chain.shape)
samples = sampler.chain.reshape((-1, ndim))
print(samples.shape)

afit = popt[0]
bfit = popt[1]

fig, (ax0, ax1) = plt.subplots(2, 1, figsize=(15, 10))
ax0.plot(samples[:, 0])
ax0.axhline(afit, color='r', label='Linear Fit')
ax0.set_xlabel('step number')
ax0.set_ylabel('a')

ax1.plot(samples[:, 1])
ax1.axhline(bfit, color='r', label='Linear Fit')
ax1.set_xlabel('step number')
ax1.set_ylabel('b')

```

```{python}
fig = corner.corner(samples, labels=["$a$", "$b$"], truths=[afit, bfit])
```

```{python}
for a, b in samples[np.random.randint(len(samples), size=100)]:
    plt.plot(x, func(x, a, b), color="g", alpha=0.1)

plt.plot(x, func(x, afit, bfit), color="b", lw=2, alpha=0.8, label='Curve Fit')

plt.errorbar(nus, 
             themean,
             yerr=thestd, 
             fmt='o', 
             color='r',
             label='recon sky')

plt.legend()
plt.title('Pixel {}'.format(pix))
plt.xlabel('Frequency [GHz]')
if istk == 0:
    plt.ylabel(r'$I$ [µK]')
else:
    plt.ylabel(r'$P$ [µK]')
plt.grid()

```

```{python}
error = np.std(samples, axis=0)

print("a =", afit, "+/-", error[0])
print("b =", bfit, "+/-", error[1])

```

```{python}
valsMC = np.zeros((len(x), 1000))
for i in range(len(x)):
    for j in range(1000):
        valsMC[i, j] = func(x[i], *samples[j, :])

mvalsMC = np.mean(valsMC, axis=1)
svalsMC = np.std(valsMC, axis=1)

```

```{python}
plt.figure(figsize=(10, 10))
plt.plot(nus, inputmaps_dgrad[:, pix, istk], 'ko', label='Input sky')
plt.errorbar(nus, 
             themean,
             yerr=thestd, 
             fmt='o', 
             color='r',
             label='recon sky')

y1 = mvalsMC + svalsMC
y2 = mvalsMC - svalsMC
plt.plot(x, mvalsMC, 'g', label='MCMC mean')
plt.plot(x, y1, 'g--', label=r'MCMC $1 \sigma$')
plt.plot(x, y2, 'g--')
plt.fill_between(x, y1, y2, facecolor='g', alpha=0.15)
# plt.plot(x, mvalsMC + 3*svalsMC, 'g:')
# plt.plot(x, mvalsMC - 3*svalsMC, 'g:')

plt.plot(x, mvals, 'b', label='Curve fit')
# plt.plot(x, mvals + svals, 'b--', label='1 sigma')
# plt.plot(x, mvals - svals, 'b--')

plt.legend()
plt.title('MCMC - Pixel {}'.format(pix))
plt.xlabel('Frequency [GHz]')
if istk == 0:
    plt.ylabel(r'$I$ [µK]')
else:
    plt.ylabel(r'$P$ [µK]')
plt.grid()

```

```{python}

```
