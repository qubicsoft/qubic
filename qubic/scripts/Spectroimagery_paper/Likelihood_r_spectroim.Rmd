---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Likelihood on r

```{python}
# %matplotlib inline

import healpy as hp
import numpy as np
import matplotlib.pyplot as plt
import scipy
import pickle
from itertools import combinations, combinations_with_replacement

# Specific qubic modules
from qubicpack.utilities import Qubic_DataDir
import pysm
import qubic
from qubic import QubicSkySim as qss
from qubic import camb_interface as qc
from qubic import NamasterLib as nam
from qubic import mcmc
import AnalysisMC as amc

rc('figure', figsize=(16, 10))
rc('font', size=15)
plt.rcParams['image.cmap'] = 'jet'
```

```{python}
import matplotlib.colors as mcolors
mcolors.TABLEAU_COLORS.keys()

colorlist = list(mcolors.TABLEAU_COLORS.keys())
```

```{python}
### Initialize
global_dir = Qubic_DataDir(datafile='instrument.py', datadir=os.environ['QUBIC_DATADIR'])
print(global_dir)

```

## Make maps with Fast Simulator

```{python}
# Dictionary
config = 'FI-150'
dictfilename = global_dir + '/doc/FastSimulator/FastSimDemo_{}.dict'.format(config)
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictfilename)

d['nside'] = 256

# Number of bands
nbands = 1
d['nf_recon'] = nbands
d['nf_sub'] = nbands

# Make a sky with CMB
# seed = 42
# sky_config = {'cmb': seed}

# Calculate CMB spectra with CAMB
ell, totDL, unlensedDL = qss.get_camb_Dl(r=0., lmax=2*d['nside']-1)

# Specify the CMB description in a dictionary
cmb_dict = {'CAMBSpectra':totDL, 'ell':ell}

sky_config = {'cmb': cmb_dict}

Qubic_sky = qss.Qubic_sky(sky_config, d)
cmb_map = Qubic_sky.get_simple_sky_map()


```

```{python}
input_Dl = Qubic_sky.input_cmb_spectra
input_ell = np.arange(np.shape(input_Dl)[0])
```

```{python}
hp.mollview(cmb_map[0, :, 0])
```

```{python}
# Getting noise realisations with FastSimulator
nreals = 300
npix = 12 * d['nside']**2
noisemaps = np.zeros((nreals, nbands, npix, 3))

for r in range(nreals):
    noisemaps[r, ...], coverage = Qubic_sky.get_partial_sky_maps_withnoise(noise_only=True, spatial_noise=True)

# Make maps QUBIC = noise + CMB
qubicmaps = np.zeros_like(noisemaps)
for r in range(nreals):
    qubicmaps[r, ...] = noisemaps[r, ...] + cmb_map

unseen = coverage < np.max(coverage) * 0.1
qubicmaps[:, :, unseen, :] = 0.
noisemaps[:, :, unseen, :] = 0.
cmb_map[:, unseen, :] = 0.

```

```{python}
Stokes = ['I', 'Q', 'U']
real = 2
band = 0

for s in range(3):
    hp.gnomview(noisemaps[real, band,:,s], reso=20, sub=(3, 3, s+1), 
                title='Noise ' + Stokes[s] + f' Sub {band}')   
    hp.gnomview(cmb_map[band,:,s], reso=20, sub=(3, 3, s+3+1), 
                title='CMB ' + Stokes[s] + f' Sub {band}')        
    hp.gnomview(qubicmaps[real, band,:,s], reso=20, sub=(3, 3, s+6+1), 
                title='QUBIC map ' + Stokes[s] + f' Sub {band}')        

        
```

## Make spectra using Namaster

```{python}
# Make a Namaster object
lmin = 40
lmax = 2 * d['nside'] - 1
delta_ell = 30

mask = np.zeros(12 * d['nside'] ** 2)
seenmap = np.invert(unseen)
mask[seenmap] = 1
Namaster = nam.Namaster(mask, lmin=lmin, lmax=lmax, delta_ell=delta_ell)
mask_apo = Namaster.get_apodized_mask()
hp.gnomview(mask_apo, reso=20, title='Mask')

ell_binned, b = Namaster.get_binning(d['nside'])
nbins = len(ell_binned)
print('lmin:', lmin)
print('lmax:', lmax)
print('delta_ell:', delta_ell)
print('nbins:', nbins)
print('ell binned:', ell_binned)
print('Fsky: {}'.format(Namaster.fsky))


# Possible combinations between bands
combi = list(combinations_with_replacement(np.arange(nbands), 2))
ncombi = len(combi)
print('combi:', combi)
print('ncombi:', ncombi)


```

#### Cross spectrum between bands but same real

```{python}
cross_samereal = np.zeros((nreals, ncombi, nbins, 4))

w = None
for real in range(nreals):
    print(f'\n Real {real}')
    for i, (band1, band2) in enumerate(combi):
        print(f'Bands {band1} {band2}')
        map1 = qubicmaps[real, band1, :, :]
        map2 = qubicmaps[real, band2, :, :]
        leff, cross_samereal[real, i, :, :], w = Namaster.get_spectra(map1.T,
                                                                      mask_apo,
                                                                      map2.T,
                                                                      w=w,
                                                                      purify_e=True,
                                                                      purify_b=False,
                                                                      beam_correction=None,
                                                                      pixwin_correction=None)

BBsamereal = cross_samereal[:, :, :, 2]
```

```{python}
avg_cross_samereal = np.mean(cross_samereal, axis=0)
error_cross_samereal = np.std(cross_samereal, axis=0) * np.sqrt(2)


BBavg_same = avg_cross_samereal[:, :, 2]
BBerror_same = error_cross_samereal[:, :, 2]
```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']

fig, axs = plt.subplots(2, 2)
axs = axs.ravel()

for s in range(4):
    ax = axs[s]
    for cross in range(ncombi): 
        c = colorlist[cross]
        ax.errorbar(leff, 
                    avg_cross_samereal[cross, :, s],
                    yerr=error_cross_samereal[cross, :, s],
                    fmt='o',
                    color=c)
#         ax.plot(leff, 
#                 cross_samereal[0, cross, :, s],
#                     'o',
#                     color=c)
    ax.plot(input_ell[lmin:lmax], input_Dl[lmin:lmax, s], 'r', label='Input')

    ax.set_xlabel('$\\ell$')
    ax.set_ylabel('$D_\\ell$')

    ax.set_title(clnames[s])
#     ax.legend(fontsize=12, loc='upper right')
plt.tight_layout()

```

#### Cross spectrum between bands with different real

```{python}
ncross = nreals // 2
print('ncross:', ncross)
cross_mixreal = np.zeros((ncross, ncombi, nbins, 4))

w = None
cross = 0
for c1 in range(0, nreals - 1, 2):  # do not mix pairs to avoid correlation
    c2 = c1 + 1
    print(f'\n Reals {c1} {c2}')
    
    for i, (band1, band2) in enumerate(combi):
        print(f'Bands {band1} {band2}')
        map1 = qubicmaps[c1, band1, :, :]
        map2 = qubicmaps[c2, band2, :, :]
#         map1 = cmb_map[band1, :, :]
#         map2 = cmb_map[band2, :, :]
        leff, cross_mixreal[cross, i, :, :], w = Namaster.get_spectra(map1.T,
                                                                       mask_apo,
                                                                       map2.T,
                                                                       w=w,
                                                                       purify_e=True,
                                                                       purify_b=False,
                                                                       beam_correction=None,
                                                                       pixwin_correction=None)
    cross += 1

BBmixreal = cross_mixreal[:, :, :, 2]
```

```{python}
avg_cross_mixreal = np.mean(cross_mixreal, axis=0)
error_cross_mixreal = np.std(cross_mixreal, axis=0) * np.sqrt(2)

BBavg_mix = avg_cross_mixreal[:, :, 2]
BBerror_mix = error_cross_mixreal[:, :, 2]
```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']
fig, axs = plt.subplots(2, 2)
axs = axs.ravel()

for s in range(4):
    ax = axs[s]
    for co in range(ncombi): 
        c = colorlist[co]
        ax.errorbar(leff, 
                    avg_cross_mixreal[co, :, s],
                    yerr=error_cross_mixreal[co, :, s],
                    fmt='o',
                    color=c)
    ax.plot(np.arange(lmin, lmax), input_Dl[lmin:lmax, s], 'r', label='input')

    ax.set_xlabel('$\\ell$')
    ax.set_ylabel('$D_\\ell$')

    ax.set_title(clnames[s])
    ax.legend(fontsize=12, loc='upper right')
plt.tight_layout()
```

## Make Covariance matrix between bins and bands

```{python}
# We have to reshape cls_cross as (nreals, nbins, 4, nfrecon)
print('Old shape:', cross_mixreal.shape)
cross_mixreal_reshape = np.moveaxis(cross_mixreal, [1, 2, 3], [3, 1, 2])
print('New shape:', cross_mixreal_reshape.shape)

# print('Old shape:', cross_samereal.shape)
# cross_samereal_reshape = np.moveaxis(cross_samereal, [1, 2, 3], [3, 1, 2])
# print('New shape:', cross_samereal_reshape.shape)
```

```{python}
covbinband, corrbinband = amc.get_covcorr_patch(cross_mixreal_reshape, stokesjoint=True, doplot=False)

print(nbins)
print(covbinband.shape)

BBcov = covbinband[:, :, 2]
```

```{python}
labs = []
for i in range(ncombi):
    labs.append(f'Cross {combi[i][0]}{combi[i][1]}')

plt.figure(figsize=(20, 20))

plt.yticks(np.arange(8, nbins*ncombi, nbins), labs, fontsize=20)
plt.xticks(np.arange(8, nbins*ncombi, nbins), labs, fontsize=20)

for s in range(ncombi-1):
    plt.axhline(y=(s+1)*nbins-0.5, lw=3, color='k')
    plt.axvline(x=(s+1)*nbins-0.5, lw=3, color='k')
    
vmax = np.max(np.abs(BBcov))
plt.imshow(BBcov, vmin=-vmax, vmax=vmax, cmap='bwr')
plt.title('Covariance matrix (nfreq*nbins)x(nfreq*nbins) for BB spectrum', 
         fontsize=20)
plt.colorbar()
```

## Make theoretical spectra with CAMB

```{python}
# Make a Camb library
rvalues = np.arange(0., 0.0805, 0.0005)
print(rvalues)
# camblib = qc.rcamblib(rvalues, lmax=lmax, save=global_dir + '/doc/CAMB/camblib.pkl')
```

```{python}
# Load the CAMB library already saved
with open(global_dir + '/doc/CAMB/camblib.pkl', "rb") as file:
    camblib = pickle.load(file)
```

```{python}
[lll, rvalues, spec, specunlensed] = camblib
# print('lll:', lll)
```

### Bin the spectra

```{python}
nside = d['nside']
print(nside)

binned_camblib = qc.bin_camblib(Namaster, global_dir + '/doc/CAMB/camblib.pkl', nside, verbose=True)
```

```{python}
[lll_b, rvalues_b, spec_b, specunlensed_b] = binned_camblib
```

```{python}
lmax
```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']
r_idx = 0

fig, axs = plt.subplots(2, 2)
axs = axs.ravel()

for s in range(4):
    ax = axs[s]
    for cross in range(ncombi): 
        c = colorlist[cross]
        ax.plot(input_ell[lmin:lmax], 
                input_Dl[lmin:lmax, s],
                color='g',
                label='Input')
        ax.plot(lll[lmin:lmax], 
                spec[lmin:lmax, s, r_idx],
                color=c, 
                label=f'Theory with r = {rvalues[r_idx]}')
#         ax.plot(lll_b, 
#                 spec_b[:, s, r_idx],
#                 'o',
#                 color=c,
#                 label=f'Theory with r = {rvalues[r_idx]}')
        ax.errorbar(leff, 
                    avg_cross_mixreal[cross, :, s],
                    yerr=error_cross_mixreal[cross, :, s],
                    fmt='o',
                    color='r',
                    label='Measure')


    ax.set_xlabel('$\\ell$')
    ax.set_ylabel('$D_\\ell$')

    ax.set_title(clnames[s])
    ax.legend(fontsize=12, loc='upper right')
plt.tight_layout()

```

```{python}
# BB unlensed spectrum
r_idx = 0

plt.figure()
for cross in range(ncombi): 
    c = colorlist[cross]
    plt.plot(lll, 
            specunlensed[:, 2, r_idx],
            color=c, 
            label='Theory')
    plt.plot(lll_b, 
            specunlensed_b[:, 2, r_idx],
            'o',
            color=c)
#     plt.plot(lll_b, 
#             clBB,
#             'o',
#             color='g')
    plt.errorbar(leff, 
                BBavg_same[cross, :],
                yerr=BBerror_same[cross, :],
                fmt='o',
                color='r',
                label='Measure')

plt.xlabel('$\\ell$')
plt.ylabel('$D_\\ell$')

plt.title(clnames[2] + f' unlensed with r = {rvalues[r_idx]}')
plt.legend(fontsize=12, loc='upper right')

```

#### Get directly binned BB spectrum 

```{python}
### And we need a fast one for BB only as well
def myBBth(ell, r):
    clBB = qc.get_Dl_fromlib(ell, r, lib=binned_camblib, unlensed=False, specindex=2)[0]
    return clBB

clBB = myBBth(lll_b, r=0.)
print(clBB.shape)

```

## Likelihood on r

```{python}
data = BBavg_mix[0, :]
fakedata = clBB
error = BBcov #BBerror_mix[0, :]

loglikelihood = mcmc.LogLikelihood(xvals=lll_b, 
                                   yvals=data, 
                                   errors=error, 
                                   model=myBBth, 
                                   flatprior=[[0,1]], 
                                   covariance_model_funct=Namaster.knox_covariance)

```

```{python}
likelihood = [np.exp(loglikelihood([rvalues[i]])) for i in range(len(rvalues))]
    
cumint = scipy.integrate.cumtrapz(likelihood, x=rvalues)
cumint /= np.max(cumint)
sigma68 = np.interp(0.68, cumint, rvalues[1:])
sigma95 = np.interp(0.95, cumint, rvalues[1:])

max_index = np.where(likelihood == np.max(likelihood))[0][0]
print(max_index)
print(rvalues[max_index])
```

```{python}
plt.plot(rvalues, likelihood / np.max(likelihood), 'o', label='QUBIC FI-150')
plt.axvline(x=sigma68, linestyle='--', color='k', label=' $\sigma(r)={0:6.4f}$ at 68% C. L.'.format(sigma68))
plt.axvline(x=sigma95, linestyle='--', color='r', label=' $\sigma(r)={0:6.4f}$ at 95% C. L.'.format(sigma95))
plt.axvline(x=rvalues[max_index], linestyle='-', color='g', label='Max at r = {0:6.4f}'.format(rvalues[max_index]))

plt.xlim(0, 0.08)
plt.xlabel('r')
plt.ylabel('Posterior')

plt.legend()
```

```{python}

```
