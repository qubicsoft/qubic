---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.6.0rc0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
# %matplotlib inline

import os
import sys
import glob
from importlib import reload
import gc
# Specific science modules
import healpy as hp
import matplotlib.pyplot as plt
import numpy as np
#import pickle 
#import astropy.io as fits

# Specific qubic modules
import qubic
#from qubicpack.utilities import Qubic_DataDir
#from qubic import QubicSkySim as qss
from qubic.polyacquisition import compute_freq
#from qubic import ReadMC as rmc
#from qubic import create_acquisition_operator_REC
import ForegroundsSED as fsed
#import qubic.AnalysisMC as amc
from matplotlib.legend_handler import HandlerLine2D, HandlerTuple
from matplotlib.ticker import (MultipleLocator, AutoMinorLocator)
from mpl_toolkits.mplot3d import Axes3D

#from pysimulators import FitsArray
import time
from scipy.optimize import curve_fit
import scipy.constants
from qubic import mcmc
#import qubic.AnalysisMC as amc
import pickle as pk

plt.rc('text',usetex=False)
plt.rc('font', size=16)
```

```{python}
nside = 64
savefigs = False
nreals = 43
component = "polarization"
# pixels used in paper:
if component == "intensity":
    #For Intensity
    pixQ_ud, pixG_ud = 47149, 26754
elif component == "polarization":
    # For Polarization
    pixQ_ud, pixG_ud = 42505, 27776
```

## Fit from data


Read data generated by Intensity_by_pixel.Rmd

```{python}
readdata = False

if readdata:
    file = open("DataSED/FI-component_data.pk", 'rb')
    dictionaries, centers = pk.load(file)
    file.close()

    bandreg = ["Qubic_Field150FI", "Qubic_Field220FI",
               "GalCen_Field150FI", "GalCen_Field220FI"]
    Cp_prime = []
    for j, idict in enumerate(dictionaries):
        file = open("DataSED/SED_CovarMatrix_config{}_nside{}_nreals{}.pk".format(bandreg[j], 
                                                                                       nside,
                                                                                       nreals), "rb")
        Cp_prime.append(pk.load(file))
        file.close()
    
    file = open("DataSED/MCMC_run_{}nside{}_nreals{}_pixG{}_pixQ{}.pk".format(dictionaries[0]["config"],
                                                                  nside,
                                                                nreals,
                                                                pixG_ud, pixQ_ud), "rb")
    Mean_mcmc, Std_mcmc, xarr_mcmc, ySED_fit, Pmean, Perr, pixs_ud = pk.load(file)
    file.close()
    
    file = open("DataSED/ForegroundMaps_{}nside{}.pk".format(dictionaries[0]["config"],
                                                                  nside), "rb")
    fgr_map_dust_ud, fgr_map_synch_ud, fgr_map_ud, maps_ud, cov_ud = pk.load(file)
    file.close()
    
elif not readdata:
    file = open("DataSED/FI-component_data.pk", 'rb')
    dictionaries, centers = pk.load(file)
    file.close()

    file = open("DataSED/data_torun_MCMC_nside64_nreals43_pixG27776_pixQ42505.pk", "rb")
    dictionaries, _, Cp_prime, nus_out, nus_edge, pixs_ud, pixs_red = pk.load(file)
    file.close()

    file = open("DataSED/ForegroundMaps_{}nside{}.pk".format(dictionaries[0]["config"],
                                                                  nside), "rb")
    fgr_map_dust_ud, fgr_map_synch_ud, fgr_map_ud, maps_ud, cov_ud = pk.load(file)
    file.close()

nf_recon = dictionaries[0]['nf_recon']
_, nus_edge150, nus150, _, _, _ = qubic.compute_freq(dictionaries[0]['filter_nu'] / 1e9,  
                            nf_recon,
                            dictionaries[0]['filter_relative_bandwidth'])
_, nus_edge220, nus220, _, _, _ = qubic.compute_freq(dictionaries[1]['filter_nu'] / 1e9,  
                            nf_recon,
                            dictionaries[1]['filter_relative_bandwidth'])

```

Define dust model to use with mcmc_old and fibtools_old

```{python}
if not readdata:
    def Bnu(nuGHz, temp):
        h = scipy.constants.h
        c = scipy.constants.c
        k = scipy.constants.k
        nu = nuGHz * 1e9
        return 2 * h * nu ** 3 / c ** 2 / (np.exp(h * nu / k / temp ) - 1 )
    def func353(x, a, b):
        #a = pars[0]
        #b = pars[1]
        Tdust = 19.6
        bnu = Bnu(x, Tdust)
        return a * 1e18 * bnu * (x / 353) ** (b / 2)

    past_mcmc = False
    if past_mcmc:
        FuncModel = func353
    else:
        FuncModel = fsed.ThermDust_Planck353

    p0 = np.array([1e3,3])

    Chi2Model = None

    flatprior = None#[np.array([1e1,1.5]), np.array([[0.3, 0.3], [0.3, 0.3]])]

    Mean_mcmc2, Std_mcmc2, _, flat_samples2 = fsed.foregrounds_run_mcmc(dictionaries, fgr_map_dust_ud, Cp_prime, 
                                                    FuncModel, nus_out, nus_edge, pixs_ud, 
                                                    pixs_red = pixs_red, chi2=Chi2Model, 
                                                    samples = 5000, verbose = False, initP0 = p0,
                                                    flatprior = None, plotcovar = False, past_mcmc = past_mcmc)
    
    
    FuncPoint = fsed.ThermDust_Planck353_pointer
    initGuess = np.array([1, 3])
    
    xSED = [nus150, nus220, nus150, nus220]

    ySED_fit2, Pmean2, Perr2 = fsed.make_fit_SED(xSED, xarr_mcmc, Mean_mcmc2, Std_mcmc2,
                                          FuncPoint, fgr_map_ud, pixs_ud, nf_recon, 
                                          initP0 = initGuess, 
                                          maxfev = 15000)
```

```{python}
#
#                  Intensity
#
# NEW (17 feb 2021)
RESO = 15
capsize = 3
plt.rc('font', size = 14)

fig,ax = plt.subplots(nrows = 1, ncols = 4,figsize = (19,4.5), gridspec_kw = {'wspace': 0.4})
ax = ax.ravel()
plt.subplots_adjust(wspace = 0.1)
# Plotting
# Dust galactic center
t0, = ax[0].plot(nus150, fgr_map_dust_ud[2,:,pixs_ud[2],0], ls = '', 
           marker = 'd', color = 'g',alpha = 0.5, label = 'Dust')
ax[0].plot(nus220, fgr_map_dust_ud[3,:,pixs_ud[2],0], marker = 'd', ls = '', color = 'g', alpha = 0.5)
#Synch galactic center
t1, = ax[0].plot(nus150, fgr_map_synch_ud[2,:,pixs_ud[2],0], ls = '', 
           marker = 's', color = 'g', alpha = 0.5, label = 'Synchrotron')
ax[0].plot(nus220, fgr_map_synch_ud[3,:,pixs_ud[2],0], marker = 's', ls = '', color = 'g', alpha = 0.5)
#Two components
p1, = ax[0].plot(nus150, fgr_map_ud[2, :, pixs_ud[2], 0], 'ro', label = 'Input sky')
p2, = ax[0].plot(nus220, fgr_map_ud[3, :, pixs_ud[2], 0], 'bo')


e1 = ax[0].fill_between(xarr_mcmc[2,:], y1 = ySED_fit[2,:,0] - Std_mcmc[2, :, 0], 
                                y2 = ySED_fit[2, :, 0] + Std_mcmc[2, :, 0], 
                 color = 'r', alpha = 0.3, label = '68% C.L.')
e2 = ax[0].fill_between(xarr_mcmc[3, :], y1 = ySED_fit[3, :, 0] - Std_mcmc[3, :, 0], 
                        y2 = ySED_fit[3, :, 0] + Std_mcmc[3, :, 0], 
                   color = 'b', alpha = 0.3)

# Dust galactic center
ax[2].plot(nus150, fgr_map_dust_ud[0,:,pixs_ud[0],0], ls = '', 
           marker = 'd', color = 'g',alpha = 0.5, label = 'Dust')
ax[2].plot(nus220, fgr_map_dust_ud[1,:,pixs_ud[0],0], marker = 'd', ls = '', color = 'g', alpha = 0.5)
#Synch galactic center
ax[2].plot(nus150, fgr_map_synch_ud[0,:,pixs_ud[0],0], ls = '', 
           marker = 's', color = 'g', alpha = 0.5, label = 'Synchrotron')
ax[2].plot(nus220, fgr_map_synch_ud[1,:,pixs_ud[0],0], marker = 's', ls = '', color = 'g', alpha = 0.5)

ax[2].plot(nus150, fgr_map_ud[0, :, pixs_ud[0], 0], 'ro')
ax[2].plot(nus220, fgr_map_ud[1, :, pixs_ud[0], 0], 'bo')
ax[2].fill_between(xarr_mcmc[0, :], y1 = ySED_fit[0, :, 0] - Std_mcmc[0, :, 0], 
                   y2 = ySED_fit[0, :, 0] + Std_mcmc[0, :, 0], 
                   color = 'r', alpha = 0.3)
ax[2].fill_between(xarr_mcmc[1, :], y1 = ySED_fit[1, :, 0] - Std_mcmc[1, :, 0], 
                   y2 = ySED_fit[1, :, 0] + Std_mcmc[1, :, 0], 
                   color = 'b', alpha = 0.3)

# Settings
greyscale = 0.1
ax[2].axvspan(nus_edge150[-1], nus_edge220[0],color='k',alpha = greyscale)
ax[0].axvspan(nus_edge150[-1], nus_edge220[0],color='k',alpha = greyscale)
xlim = ax[0].get_xlim()
ylim = ax[0].get_ylim()
xlim2 = ax[2].get_xlim()
ylim2 = ax[2].get_ylim()
ax[0].axvspan(xlim[0], nus_edge150[0], color = 'k', alpha = greyscale)
ax[0].axvspan(nus_edge220[-1], xlim[-1], color = 'k', alpha = greyscale)

ax[2].axvspan(xlim2[0], nus_edge150[0], color = 'k', alpha = greyscale)
ax[2].axvspan(nus_edge220[-1], xlim2[-1], color = 'k', alpha = greyscale)

ax[0].set_xlim(xlim)
ax[0].set_ylim(ylim)
ax[2].set_xlim(xlim2)
ax[2].set_ylim(ylim2)

ax[2].grid(which='both')
l = ax[0].legend([(t0,t1), (p1, p2), (e1, e2)], ["Dust - Synch", 'Input sky ', '68% C.L.'], numpoints=1, 
                 loc = 2, fontsize = 12,
               handler_map={tuple: HandlerTuple(ndivide=None)})

ax[0].grid()
ax[0].set_title('GC patch - {} year'.format(dictionaries[0]['effective_duration']),fontsize=16)
ax[0].set_ylabel(r'$I(\nu)$ [$\mu$K]',fontsize=16)
ax[0].set_xlabel(r'$\nu$[GHz]',fontsize=16)

ax[2].set_title('QUBIC patch - {} years'.format(dictionaries[0]['effective_duration']),fontsize=16)
ax[2].set_ylabel(r'$I(\nu)$ [$\mu$K]',fontsize=16)
ax[2].set_xlabel(r'$\nu$[GHz]',fontsize=16)

# Displaying maps
ax[1].cla()
plt.axes(ax[1])
hp.gnomview(maps_ud[2, -1, :, 0], reso = 15,hold = True, 
            notext = True, title = ' ',
            min = 0,
            max = 0.4*np.max(maps_ud[2, -1, :, 0]), 
            unit = r'$\mu$K',
            rot = centers[2])
hp.projscatter(hp.pix2ang(nside, pixs_ud[2]), marker = '*', color = 'r', s = 180)
dpar = 10
dmer = 20
#Watch out, the names are wrong (change it)
mer_coordsG = [centers[2][0] - dmer, centers[2][0], centers[2][0] + dmer]
long_coordsG = [centers[2][1] - 2*dpar, centers[2][1] - dpar, 
                centers[2][1], centers[2][1] + dpar, centers[2][1] + 2 * dpar]
#paralels
for ilong in long_coordsG:
    plt.text(np.deg2rad(mer_coordsG[0] - 12), 1.1*np.deg2rad(ilong), 
             r'{}$\degree$'.format(ilong))
#meridians
for imer in mer_coordsG:
    if imer < 0:
        jmer = imer + 360
        ip, dp = divmod(jmer/15,1)
    else:
        ip, dp = divmod(imer/15,1)
    if imer == 0:
        plt.text(-np.deg2rad(imer + 3), np.deg2rad(long_coordsG[-1] + 6), 
             r'{}$\degree$'.format(int(ip) ))
    else:
        plt.text(-np.deg2rad(imer + 3), np.deg2rad(long_coordsG[-1] + 6), 
             r'{}$\degree$'.format(imer))
             #r'{}h{}m'.format(int(ip), int(round(dp*60))))
hp.projtext(mer_coordsG[1] + 2, long_coordsG[0] - 6, '$l$',  color = 'k', lonlat=True)
hp.projtext(mer_coordsG[2] + 12.5, long_coordsG[2] - 1, '$b$', rotation = 90, color = 'k', lonlat=True)

ax[3].cla()
plt.axes(ax[3])
hp.gnomview(maps_ud[1, -1, :, 0], reso = 15, hold = True, 
            notext = True, title = ' ',
            unit = r'$\mu$K',
            min = 0,
            max = 0.4*np.max(maps_ud[1, -1, :, 0]), 
            rot = centers[0])
hp.projscatter(hp.pix2ang(nside, pixQ_ud),marker = '*', color = 'r', s = 180)

mer_coordsQ = [centers[1][0] - dmer, centers[0][0]+0, centers[0][0] + dmer]
long_coordsQ = [centers[0][1] - 2*dpar, centers[0][1] - dpar, centers[0][1], 
                centers[0][1] + dpar, centers[0][1] + 2 * dpar]
#paralels
for ilong in long_coordsQ:
    plt.text(np.deg2rad(mer_coordsQ[0]-360+31), 1.1*np.deg2rad(ilong+58), r'{:.0f}$\degree$'.format(ilong),)
#meridians
for imer in mer_coordsQ:
    ip, dp = divmod(imer/15,1)
    plt.text(-np.deg2rad(imer-360+48), np.deg2rad(long_coordsQ[-1]+58+7), 
         r'{:.1f}$\degree$'.format(imer))
         #r'{}h{}m'.format(int(ip), int(round(dp*60))))
#hp.projtext(mer_coordsQ[0] , long_coordsQ[0] - 6, r'$l$',  color = 'k', lonlat=True)
#hp.projtext(mer_coordsQ[2] - 360, long_coordsQ[2] + 10, r'$b$', rotation = 90, color = 'k', lonlat=True)

hp.graticule(dpar = dpar, dmer = dmer, alpha = 0.6, verbose = False)

plt.tight_layout()
if savefigs:
    plt.savefig('Figs-FI-SED/March2021/NSIDE{}/{}_nrec{}_nside{}_pixQ{}_pixG{}_Intensity_grat.svg'.format(nside,
                                                                            FuncModel.__name__,
                                                                            d150Q['nf_recon'],nside,
                                                           pixQ_ud, pixG_ud), 
            format = 'svg', bbox_inches='tight')
    plt.savefig('Figs-FI-SED/March2021/NSIDE{}/{}_nrec{}_nside{}_pixQ{}_pixG{}_Intensity_grat.pdf'.format(nside,
                                                                                FuncModel.__name__,
                                                                               d150Q['nf_recon'],nside,
                                                           pixQ_ud, pixG_ud), 
            format = 'pdf', bbox_inches='tight')
    plt.savefig('Figs-FI-SED/March2021/NSIDE{}/{}_nrec{}_nside{}_pixQ{}_pixG{}_Intensity'.format(nside,
                                                                        FuncModel.__name__, 
                                                                           d150Q['nf_recon'],
                                                                           nside,pixQ_ud, pixG_ud),
           bbox_inches='tight')
else:
    plt.show()
```

```{python}
#
#                  Polarization
#

fig,ax = plt.subplots(nrows = 1,ncols = 4, figsize = (19,4.5), gridspec_kw = {'wspace': 0.4})
ax = ax.ravel()
plt.subplots_adjust(wspace=0.1)

# Dust galactic center
t0, = ax[0].plot(nus150, np.sqrt(fgr_map_dust_ud[2,:,pixs_ud[2],1] ** 2 + \
                 fgr_map_dust_ud[2,:,pixs_ud[2],2] **2),
           ls = '', marker = 'd', color = 'g',alpha = 0.5, label = 'Dust')
ax[0].plot(nus220, np.sqrt(fgr_map_dust_ud[3,:,pixs_ud[2],1] ** 2 + \
                 fgr_map_dust_ud[3,:,pixs_ud[2],2] **2), 
           marker = 'd', ls = '', color = 'g', alpha = 0.5)
#Synch galactic center
t1, = ax[0].plot(nus150, np.sqrt(fgr_map_synch_ud[2,:,pixs_ud[2],1] ** 2 + \
                                    fgr_map_synch_ud[2,:,pixs_ud[2],2] ** 2), 
                 ls = '', marker = 's', color = 'g', alpha = 0.5, label = 'Synchrotron')
ax[0].plot(nus220, np.sqrt(fgr_map_synch_ud[3,:,pixs_ud[2],1] ** 2 + \
                                    fgr_map_synch_ud[3,:,pixs_ud[2],2] ** 2),
           marker = 's', ls = '', color = 'g', alpha = 0.5)

# Plotting
p1, = ax[0].plot(nus150, 
               np.sqrt(fgr_map_ud[2,:,pixs_ud[2],1] ** 2 + fgr_map_ud[2,:,pixs_ud[2],2] ** 2),
               'ro', lw = 3, label = 'Input sky')
p2, = ax[0].plot(nus220, 
               np.sqrt(fgr_map_ud[3,:,pixs_ud[3],1] ** 2 + fgr_map_ud[3,:,pixs_ud[3],2] ** 2),
               'bo', lw = 3)

e1 = ax[0].fill_between(xarr_mcmc[2], y1 = ySED_fit[2, :, 1] - Perr[2], 
                        y2 = ySED_fit[2, :, 1] + Perr[2], 
                   color = 'r', alpha = 0.3, label = '68% C.L. ')
e2 = ax[0].fill_between(xarr_mcmc[3], y1 = ySED_fit[3, :, 1] - Perr[3], 
                        y2 = ySED_fit[3, :, 1] + Perr[3], 
                   color = 'b', alpha = 0.3)

# Dust galactic center
ax[2].plot(nus150, np.sqrt(fgr_map_dust_ud[0,:,pixs_ud[0],1] ** 2 + \
                 fgr_map_dust_ud[0,:,pixs_ud[0],2] **2),
           ls = '', marker = 'd', color = 'g',alpha = 0.5, label = 'Dust')
ax[2].plot(nus220, np.sqrt(fgr_map_dust_ud[1,:,pixs_ud[0],1] ** 2 + \
                 fgr_map_dust_ud[1,:,pixs_ud[0],2] **2), 
           marker = 'd', ls = '', color = 'g', alpha = 0.5)
#Synch galactic center
ax[2].plot(nus150, np.sqrt(fgr_map_synch_ud[0,:,pixs_ud[0],1] ** 2 + \
                                    fgr_map_synch_ud[0,:,pixs_ud[0],2] ** 2), 
                 ls = '', marker = 's', color = 'g', alpha = 0.5, label = 'Synchrotron')
ax[2].plot(nus220, np.sqrt(fgr_map_synch_ud[1,:,pixs_ud[0],1] ** 2 + \
                                    fgr_map_synch_ud[1,:,pixs_ud[0],2] ** 2),
           marker = 's', ls = '', color = 'g', alpha = 0.5)

ax[2].plot(nus150, 
               np.sqrt(fgr_map_ud[0,:,pixs_ud[0],1] ** 2 + fgr_map_ud[0, :, pixs_ud[0], 2] ** 2),
               'ro', lw = 3)
ax[2].plot(nus220, 
               np.sqrt(fgr_map_ud[1, :, pixs_ud[1], 1] ** 2 + fgr_map_ud[1, :, pixs_ud[1], 2] ** 2),
               'bo', lw = 3)
ax[2].fill_between(xarr_mcmc[0], y1 = ySED_fit[0, :, 1] - Perr[0], 
                   y2 = ySED_fit[0, :, 1] + Perr[0], 
                   color = 'r', alpha = 0.3)
ax[2].fill_between(xarr_mcmc[1], y1 = ySED_fit[1, :, 1] - Perr[1], 
                   y2 = ySED_fit[1, :, 1] + Perr[1], 
                   color = 'b', alpha = 0.3)

# Setting
ax[0].set_title('GC patch - {} year'.format(dictionaries[0]['effective_duration']), fontsize = 14)
ax[0].set_ylabel(r'$P(\nu)~[\mu$K]', fontsize = 14)
ax[0].set_xlabel(r'$\nu~[GHz]$', fontsize = 14)
ax[0].legend(loc = 2, fontsize = 12)
ax[0].grid()
ax[2].set_xlabel(r'$\nu~[GHz]$', fontsize = 14)
ax[2].set_ylabel(r'$P(\nu)~[\mu$K]', fontsize = 14)
ax[2].set_title('QUBIC patch - {} years'.format(dictionaries[0]['effective_duration']),fontsize=14)
ax[2].grid()

xlim = ax[0].get_xlim()
ylim = ax[0].get_ylim()
xlim2 = ax[2].get_xlim()
ylim2 = ax[2].get_ylim()

ax[0].axvspan(nus_edge150[-1], nus_edge220[0], color = 'k', alpha = greyscale)
ax[0].axvspan(xlim2[0], nus_edge150[0], color = 'k', alpha = greyscale)
ax[0].axvspan(nus_edge220[-1], xlim2[-1], color = 'k', alpha = greyscale)
ax[2].axvspan(nus_edge150[-1], nus_edge220[0], color = 'k', alpha = greyscale)
ax[2].axvspan(xlim2[0], nus_edge150[0], color = 'k', alpha = greyscale)
ax[2].axvspan(nus_edge220[-1], xlim2[-1], color = 'k', alpha = greyscale)

ax[0].set_xlim(xlim)
ax[0].set_ylim(ylim)
ax[0].text(xlim[0]+(xlim[1]-xlim[0])*0.1, ylim[-1]*0.8, '150 GHz \n band', fontsize = 10)
ax[0].text(xlim[0]+(xlim[1]-xlim[0])*0.6, ylim[-1]*0.8, '220 GHz \n band', fontsize = 10)
ax[2].set_xlim(xlim2)
ax[2].set_ylim(ylim2)
ax[2].text(xlim2[0]+(xlim2[1]-xlim2[0])*0.1, ylim2[-1]*0.8, '150 GHz \n band', fontsize = 10)
ax[2].text(xlim2[0]+(xlim2[1]-xlim2[0])*0.6, ylim2[-1]*0.8, '220 GHz \n band', fontsize = 10)

# Displaying maps    
plt.axes(ax[1])
auxmapG = np.sqrt(maps_ud[2, 0, :, 1] ** 2 + maps_ud[2, 0, :, 2] ** 2)
auxmapG[~cov_ud[2]] = hp.UNSEEN
hp.gnomview(auxmapG,
            reso = 15, hold = True, notext = True, 
            title = ' ',
            min = 0,
            cbar = True,
            unit = r'$\mu$K',
            rot = centers[2])
hp.projscatter(hp.pix2ang(nside, pixs_ud[2]),marker = '*',color = 'r', s = 180)
dpar = 10
dmer = 20
#Watch out, the names are wrong (change it)
mer_coordsG = [centers[2][0] - dmer, centers[2][0], centers[2][0] + dmer]
long_coordsG = [centers[2][1] - 2*dpar, centers[2][1] - dpar, 
                centers[2][1], centers[2][1] + dpar, centers[2][1] + 2 * dpar]
#paralels
for ilong in long_coordsG:
    plt.text(np.deg2rad(mer_coordsG[0] - 12), 1.1*np.deg2rad(ilong), 
             r'{}$\degree$'.format(ilong))
#meridians
for imer in mer_coordsG:
    if imer < 0:
        jmer = imer + 360
        ip, dp = divmod(jmer/15,1)
    else:
        ip, dp = divmod(imer/15,1)
    if imer == 0:
        plt.text(-np.deg2rad(imer + 3), np.deg2rad(long_coordsG[-1] + 6), 
             r'{}$\degree$'.format(int(ip) ))
    else:
        plt.text(-np.deg2rad(imer + 3), np.deg2rad(long_coordsG[-1] + 6), 
             r'{}$\degree$'.format(imer))
             #r'{}h{}m'.format(int(ip), int(round(dp*60))))
hp.projtext(mer_coordsG[1] + 2, long_coordsG[0] - 6, '$l$',  color = 'k', lonlat=True)
hp.projtext(mer_coordsG[2] + 12.5, long_coordsG[2] - 1, '$b$', rotation = 90, color = 'k', lonlat=True)

plt.axes(ax[3])
auxmapQ = np.sqrt(maps_ud[0, 0, :, 1] ** 2 + maps_ud[0, 0, :, 2] ** 2)
auxmapQ[~cov_ud[0]] = hp.UNSEEN
hp.gnomview(auxmapQ,
            reso = 15, hold = True, notext = True, 
            max = 7,
            min = 0,
            title = ' ',
            cbar = True,
            unit = r'$\mu$K',
            rot = centers[0])
hp.projscatter(hp.pix2ang(nside, pixs_ud[0]), marker = '*', color = 'r', s = 180)
mer_coordsQ = [centers[0][0] - dmer, centers[0][0]+0, centers[0][0] + dmer]
long_coordsQ = [centers[0][1] - 2*dpar, centers[0][1] - dpar, 
                centers[0][1], centers[0][1] + dpar, centers[0][1] + 2 * dpar]
#paralels
for ilong in long_coordsQ:
    plt.text(np.deg2rad(mer_coordsQ[0]-360+31), 1.1*np.deg2rad(ilong+58), r'{:.0f}$\degree$'.format(ilong),)
#meridians
for imer in mer_coordsQ:
    ip, dp = divmod(imer/15,1)
    plt.text( - np.deg2rad(imer - 360 + 48), np.deg2rad(long_coordsQ[-1] + 58 + 7), 
         r'{:.1f}$\degree$'.format(imer))

hp.graticule(dpar = dpar, dmer = dmer, alpha = 0.6, verbose = False)
#l = ax[0].legend([(p1, p2), (e1, e2)], ['Input sky', '68% C.L.'], numpoints=1, loc = 4, fontsize = 12,
#               handler_map={tuple: HandlerTuple(ndivide=None)})
l = ax[0].legend([(t0,t1), (p1, p2), (e1, e2)], ["Dust - Synch", 'Input sky', '68% C.L.'], numpoints=1, 
                 loc = 2, fontsize = 12,
               handler_map={tuple: HandlerTuple(ndivide=None)})

plt.tight_layout()#plt.tight_layout()

if savefigs: 
    plt.savefig('Figs-FI-SED/March2021/NSIDE{}/{}_nrec{}_nside{}_pixQ{}_pixG{}_Polarization_grat.svg'.format(nside,
                                                                FuncModel.__name__,
                                                                d150Q['nf_recon'], nside,
                                                           pixQ_ud, pixG_ud), 
            format = 'svg', bbox_inches='tight')
    plt.savefig('Figs-FI-SED/March2021/NSIDE{}/{}_nrec{}_nside{}_pixQ{}_pixG{}_Polarization_grat.pdf'.format(nside,
                                                                                                             FuncModel.__name__,
                                                                d150Q['nf_recon'], nside,
                                                           pixQ_ud, pixG_ud), 
            format = 'pdf', bbox_inches='tight')
    plt.savefig('Figs-FI-SED/March2021/NSIDE{}/{}_nrec{}_nside{}_pixQ{}_pixG{}_Polarization_grat'.format(nside,
                                                                            FuncModel.__name__,
                                                                           d150Q['nf_recon'], 
                                                                           nside,pixQ_ud, pixG_ud),
           bbox_inches='tight')
else:
    plt.show()
```

```{python}

```

## Compare contours

```{python}
#
#                  Intensity
#
# NEW (17 feb 2021)
two_contours = False
RESO = 15
capsize = 3
plt.rc('font', size = 14)

fig,ax = plt.subplots(nrows = 1, ncols = 4,figsize = (19,4.5), gridspec_kw = {'wspace': 0.4})
ax = ax.ravel()
plt.subplots_adjust(wspace = 0.1)
# Plotting
# Dust galactic center
t0, = ax[0].plot(nus150, fgr_map_dust_ud[2,:,pixs_ud[2],0], ls = '', 
           marker = 'd', color = 'g',alpha = 0.5, label = 'Dust')
ax[0].plot(nus220, fgr_map_dust_ud[3,:,pixs_ud[2],0], marker = 'd', ls = '', color = 'g', alpha = 0.5)
#Synch galactic center
t1, = ax[0].plot(nus150, fgr_map_synch_ud[2,:,pixs_ud[2],0], ls = '', 
           marker = 's', color = 'g', alpha = 0.5, label = 'Synchrotron')
ax[0].plot(nus220, fgr_map_synch_ud[3,:,pixs_ud[2],0], marker = 's', ls = '', color = 'g', alpha = 0.5)
#Two components
p1, = ax[0].plot(nus150, fgr_map_ud[2, :, pixs_ud[2], 0], 'ro', label = 'Input sky')
p2, = ax[0].plot(nus220, fgr_map_ud[3, :, pixs_ud[2], 0], 'ro')


e1 = ax[0].fill_between(xarr_mcmc[2,:], y1 = ySED_fit[2,:,0] - Std_mcmc[2, :, 0], 
                                y2 = ySED_fit[2, :, 0] + Std_mcmc[2, :, 0], 
                 color = 'r', alpha = 0.3, label = '68% C.L.')
e2 = ax[0].fill_between(xarr_mcmc[3, :], y1 = ySED_fit[3, :, 0] - Std_mcmc[3, :, 0], 
                        y2 = ySED_fit[3, :, 0] + Std_mcmc[3, :, 0], 
                   color = 'r', alpha = 0.3)

if two_contours:
    e1 = ax[0].fill_between(xarr_mcmc[2,:], y1 = ySED_fit2[2,:,0] - Std_mcmc2[2, :, 0], 
                                y2 = ySED_fit2[2, :, 0] + Std_mcmc2[2, :, 0], 
                 color = 'b', alpha = 0.3, label = '68% C.L.')
    e2 = ax[0].fill_between(xarr_mcmc[3, :], y1 = ySED_fit2[3, :, 0] - Std_mcmc2[3, :, 0], 
                            y2 = ySED_fit2[3, :, 0] + Std_mcmc2[3, :, 0], 
                       color = 'b', alpha = 0.3)

# Dust galactic center
ax[2].plot(nus150, fgr_map_dust_ud[0,:,pixs_ud[0],0], ls = '', 
           marker = 'd', color = 'g',alpha = 0.5, label = 'Dust')
ax[2].plot(nus220, fgr_map_dust_ud[1,:,pixs_ud[0],0], marker = 'd', ls = '', color = 'g', alpha = 0.5)
#Synch galactic center
ax[2].plot(nus150, fgr_map_synch_ud[0,:,pixs_ud[0],0], ls = '', 
           marker = 's', color = 'g', alpha = 0.5, label = 'Synchrotron')
ax[2].plot(nus220, fgr_map_synch_ud[1,:,pixs_ud[0],0], marker = 's', ls = '', color = 'g', alpha = 0.5)

ax[2].plot(nus150, fgr_map_ud[0, :, pixs_ud[0], 0], 'ro')
ax[2].plot(nus220, fgr_map_ud[1, :, pixs_ud[0], 0], 'ro')
ax[2].fill_between(xarr_mcmc[0, :], y1 = ySED_fit[0, :, 0] - Std_mcmc[0, :, 0], 
                   y2 = ySED_fit[0, :, 0] + Std_mcmc[0, :, 0], 
                   color = 'r', alpha = 0.3)
ax[2].fill_between(xarr_mcmc[1, :], y1 = ySED_fit[1, :, 0] - Std_mcmc[1, :, 0], 
                   y2 = ySED_fit[1, :, 0] + Std_mcmc[1, :, 0], 
                   color = 'r', alpha = 0.3)

if two_contours:
    ax[2].fill_between(xarr_mcmc[0, :], y1 = ySED_fit2[0, :, 0] - Std_mcmc2[0, :, 0], 
                   y2 = ySED_fit2[0, :, 0] + Std_mcmc2[0, :, 0], 
                   color = 'r', alpha = 0.3)
    ax[2].fill_between(xarr_mcmc[1, :], y1 = ySED_fit2[1, :, 0] - Std_mcmc2[1, :, 0], 
                       y2 = ySED_fit2[1, :, 0] + Std_mcmc2[1, :, 0], 
                       color = 'r', alpha = 0.3)

# Settings
greyscale = 0.1
ax[2].axvspan(nus_edge150[-1], nus_edge220[0],color='k',alpha = greyscale)
ax[0].axvspan(nus_edge150[-1], nus_edge220[0],color='k',alpha = greyscale)
xlim = ax[0].get_xlim()
ylim = ax[0].get_ylim()
xlim2 = ax[2].get_xlim()
ylim2 = ax[2].get_ylim()
ax[0].axvspan(xlim[0], nus_edge150[0], color = 'k', alpha = greyscale)
ax[0].axvspan(nus_edge220[-1], xlim[-1], color = 'k', alpha = greyscale)

ax[2].axvspan(xlim2[0], nus_edge150[0], color = 'k', alpha = greyscale)
ax[2].axvspan(nus_edge220[-1], xlim2[-1], color = 'k', alpha = greyscale)

ax[0].set_xlim(xlim)
ax[0].set_ylim(ylim)
ax[2].set_xlim(xlim2)
ax[2].set_ylim(ylim2)

ax[2].grid(which='both')
l = ax[0].legend([(t0,t1), (p1, p2), (e1, e2)], ["Dust - Synch", 'Input sky ', '68% C.L.'], numpoints=1, 
                 loc = 2, fontsize = 12,
               handler_map={tuple: HandlerTuple(ndivide=None)})

ax[0].grid()
ax[0].set_title('GC patch - {} year'.format(dictionaries[0]['effective_duration']),fontsize=16)
ax[0].set_ylabel(r'$I(\nu)$ [$\mu$K]',fontsize=16)
ax[0].set_xlabel(r'$\nu$[GHz]',fontsize=16)

ax[2].set_title('QUBIC patch - {} years'.format(dictionaries[0]['effective_duration']),fontsize=16)
ax[2].set_ylabel(r'$I(\nu)$ [$\mu$K]',fontsize=16)
ax[2].set_xlabel(r'$\nu$[GHz]',fontsize=16)

# Displaying maps
ax[1].cla()
plt.axes(ax[1])
hp.gnomview(maps_ud[2, -1, :, 0], reso = 15,hold = True, 
            notext = True, title = ' ',
            min = 0,
            max = 0.4*np.max(maps_ud[2, -1, :, 0]), 
            unit = r'$\mu$K',
            rot = centers[2])
hp.projscatter(hp.pix2ang(nside, pixs_ud[2]), marker = '*', color = 'r', s = 180)
dpar = 10
dmer = 20
#Watch out, the names are wrong (change it)
mer_coordsG = [centers[2][0] - dmer, centers[2][0], centers[2][0] + dmer]
long_coordsG = [centers[2][1] - 2*dpar, centers[2][1] - dpar, 
                centers[2][1], centers[2][1] + dpar, centers[2][1] + 2 * dpar]
#paralels
for ilong in long_coordsG:
    plt.text(np.deg2rad(mer_coordsG[0] - 12), 1.1*np.deg2rad(ilong), 
             r'{}$\degree$'.format(ilong))
#meridians
for imer in mer_coordsG:
    if imer < 0:
        jmer = imer + 360
        ip, dp = divmod(jmer/15,1)
    else:
        ip, dp = divmod(imer/15,1)
    if imer == 0:
        plt.text(-np.deg2rad(imer + 3), np.deg2rad(long_coordsG[-1] + 6), 
             r'{}$\degree$'.format(int(ip) ))
    else:
        plt.text(-np.deg2rad(imer + 3), np.deg2rad(long_coordsG[-1] + 6), 
             r'{}$\degree$'.format(imer))
hp.projtext(mer_coordsG[1] + 2, long_coordsG[0] - 6, '$l$',  color = 'k', lonlat=True)
hp.projtext(mer_coordsG[2] + 12.5, long_coordsG[2] - 1, '$b$', rotation = 90, color = 'k', lonlat=True)

ax[3].cla()
plt.axes(ax[3])
hp.gnomview(maps_ud[1, -1, :, 0], reso = 15, hold = True, 
            notext = True, title = ' ',
            unit = r'$\mu$K',
            min = 0,
            max = 0.4*np.max(maps_ud[1, -1, :, 0]), 
            rot = centers[0])
hp.projscatter(hp.pix2ang(nside, pixQ_ud),marker = '*', color = 'r', s = 180)

mer_coordsQ = [centers[1][0] - dmer, centers[0][0]+0, centers[0][0] + dmer]
long_coordsQ = [centers[0][1] - 2*dpar, centers[0][1] - dpar, centers[0][1], 
                centers[0][1] + dpar, centers[0][1] + 2 * dpar]
#paralels
for ilong in long_coordsQ:
    plt.text(np.deg2rad(mer_coordsQ[0]-360+31), 1.1*np.deg2rad(ilong+58), r'{:.0f}$\degree$'.format(ilong),)
#meridians
for imer in mer_coordsQ:
    ip, dp = divmod(imer/15,1)
    plt.text(-np.deg2rad(imer-360+48), np.deg2rad(long_coordsQ[-1]+58+7), 
         r'{:.1f}$\degree$'.format(imer))

hp.graticule(dpar = dpar, dmer = dmer, alpha = 0.6, verbose = False)

plt.tight_layout()
plt.show()
#if savefigs:
#    plt.savefig('Figs-FI-SED/March2021/NSIDE{}/{}_nrec{}_nside{}_pixQ{}_pixG{}_Intensity_grat.svg'.format(nside,
#                                                                            FuncModel.__name__,
#                                                                            d150Q['nf_recon'],nside,
#                                                           pixQ_ud, pixG_ud), 
#            format = 'svg', bbox_inches='tight')
#    plt.savefig('Figs-FI-SED/March2021/NSIDE{}/{}_nrec{}_nside{}_pixQ{}_pixG{}_Intensity_grat.pdf'.format(nside,
#                                                                                FuncModel.__name__,
#                                                                               d150Q['nf_recon'],nside,
#                                                           pixQ_ud, pixG_ud), 
#            format = 'pdf', bbox_inches='tight')
#    plt.savefig('Figs-FI-SED/March2021/NSIDE{}/{}_nrec{}_nside{}_pixQ{}_pixG{}_Intensity'.format(nside,
#                                                                        FuncModel.__name__, 
#                                                                           d150Q['nf_recon'],
#                                                                           nside,pixQ_ud, pixG_ud),
#           bbox_inches='tight')
#else:
#    plt.show()
```

```{python}

```
