---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

#### Author: Mart√≠n Gamboa

Aim: analize the simulations rfor the study of the Point Spread Function (PSF) in frequency.

For each simulation: 
* read files (two different formats)
* plot raw data
* fit gaussian 
* compute SNR 

(this Martin's notebooks will replace plot.py, plot-raw.py, plot-results.py, plot-results2.py, plot-manyps.py, plot-MC-results.py

```{python}
import healpy as hp
import matplotlib.pyplot as plt
import matplotlib as mp
from qubicpack.utilities import Qubic_DataDir
import qubic
import os
import sys
import pickle as pk
import numpy as np
import glob
from astropy.io import fits
import gc

from scipy.optimize import curve_fit
from importlib import reload
import AnalysisPSF as anpsf
from scipy.interpolate import interp1d
from matplotlib.pyplot import cm
from matplotlib.patches import Ellipse
import AnalysisPSF as anpsf
from importlib import reload
from lmfit import Model
```

```{python}
def normalization(x,mapa):
    ef = np.trapz((np.trapz(mapa,x,axis=0)),x)
    return 1/ef

def gaussian2d(z, amp,x0, y0, varx, vary):
    x=z[0]
    y=z[1]
    gauss = amp*np.exp(-0.5*((x-x0)**2/varx**2+(y-y0)**2/vary**2))
    return gauss.ravel()
def get_maps(file):
    simu = fits.open(file)

    maps_recon = simu['MAPS_RECON'].data
    maps_convo = simu['MAPS_CONVOLVED'].data

    diff = maps_recon - maps_convo

    return maps_recon, maps_convo, diff

def get_maps_many_files(rep_simu, name, verbose=True):
    all_fits = glob.glob(rep_simu + name)
    nfiles = len(all_fits)
    if verbose:
        print('{} files have been found.'.format(nfiles))

    all_maps_recon = []
    all_maps_convo = []
    all_maps_diff = []

    for i, fits in enumerate(all_fits):
        map_recon, map_convo, map_diff = get_maps(fits)
        if i == 0:
            right_shape = map_recon.shape
        else:
            if map_recon.shape != right_shape:
                raise ValueError('You should take maps with identical shapes.')
        all_maps_recon.append(map_recon)
        all_maps_convo.append(map_convo)
        all_maps_diff.append(map_diff)

    return all_fits, np.asarray(all_maps_recon), \
           np.asarray(all_maps_convo), np.asarray(all_maps_diff)

def read_run(jobid, repo=None, fixpar=True):
    """
    Supose: dictionary inside directory
    
    =====================
    Parameters:
        jobid: number jobid from NERSC
        repo: directory where runs are
        fixpar: some parameters had have change from original dictionary values. These allows adapt it
    Return:
        
    """
    repo = os.environ['QUBIC_DATADIR']+'scripts/Spectroimagery_paper/output_paper/nersc/{}/'.format(jobid)
    repodict = glob.glob(repo+'*.dict')[0]

    d = qubic.qubicdict.qubicDict()
    d.read_from_file(repodict)
    center = qubic.equ2gal(d['RA_center'], d['DEC_center'])
    if fixpar:
        d['nf_sub']=48
        d['nf_recon'] = [6,]#6] 
    #nsub = d['nf_recon'][-1]
    
    _,_,nus_in,_,_,_=qubic.compute_freq(150,d['nf_sub'],0.25)
    sigma2fwhm = np.sqrt(8*np.log(2))
    # constant angular resolution using P = 19 and deltaX = 1.4cm
    CteConf = d['synthbeam_peak150_fwhm']*150#61.57622 #2.998e10/20/1.4/1e9/np.pi*180
    size=200
    reso = 3
    nside=d['nside']
    
    #if nsub not in d['nf_recon']: raise ValueError('Invalid number of sub-bands for {} nus_in'.format(d['nf_sub']))
    #_,_,nus_rec,_,_,_=qubic.compute_freq(150,nsub,0.25)
    print("Working with nf_sub = {} and nfrec = {}".format(d['nf_sub'], d['nf_recon']))
    mapsrec={}
    mapsconv={}
    nusfull = {}
    nusfulledge = {}
    for isub in d['nf_recon']:
        _, maprec, mapconv, mapdif = get_maps_many_files(repo,'*recon{}*.fits'.format(isub))
        _,inusedge,inus,_,_,_=qubic.compute_freq(150,isub,0.25)
        mapsrec.update({'{}'.format(isub): maprec})
        mapsconv.update({'{}'.format(isub): mapconv})
        nusfull.update({'{}'.format(isub):inus})    
        nusfulledge.update({'{}'.format(isub):inusedge})    
    

    return mapsrec, mapsconv,nusfull,nusfulledge, nus_in, center,d

```

```{python}
#jobids = ['32139830', '32140318','32139772', '32140658'] #[12,15,20,25]
#jobids= ['32759969','32759907',#'32574156','32574178', 
#          '32574170','32759934',]#'32574174','32759973'] #[48,48]|[1,2,3,4,6]
dictshift = {'33409471':-15,'33409418':-13,'33130322':-11,'33130175':-9,
             '32832344':-7, '33130311':-5, '32759969':-4,'32759907':-3, 
             '32574156':-2, '32574178':-1,'32574170':0, '32759934': 1,
             '32574174': 2, '32759973':3, '33130307':5, '32832346':7, 
             '33130149':9,'33130316':11,'33409459':13,'33409482':15}
jobids=list(dictshift.keys())
allrecon = []
allconv = []
jobid = np.zeros((len(jobids)))
for ijob in range(len(jobids)):
    print('Reading job {} ({}/{})'.format(jobids[ijob],ijob+1,len(jobids)))
    if ijob == 0:
        maprec, mapsconv, nusfull,nusfulledge,nus_in,center,d = read_run(jobids[ijob])
    else: 
        maprec, mapsconv, _, _, _, _, _ = read_run(jobids[ijob])
        
    allrecon.append(maprec)
    allconv.append(mapsconv)
allrecon = np.array(allrecon)
allconv = np.array(allconv)
#Index where the point source was placed
NU0=150

innu0 = min(range(len(nus_in)), key=lambda i: abs(nus_in[i]-NU0))
innu = []
for ishift in dictshift.values():
    innu.append(innu0+ishift)
```

Compute noise level at different angular distance to the source

```{python}
def ring4snr(center,d,lth=6,hth=8, doplot=False):
    pxvec = hp.ang2vec(center[0],center[1],lonlat=True)
    ip = np.arange(12*d['nside']**2)
    vpix = hp.pix2vec(d['nside'],ip)
    vecs = np.degrees(np.arccos(np.dot(pxvec,vpix)))
    seenring = np.zeros((12*d['nside']**2),dtype=bool)
    seenring[(vecs < hth) & (vecs > lth)]=int(1)
    if doplot: hp.mollview(seenring,rot=center)
    return seenring

pixel = hp.pixelfunc.ang2pix(d['nside'], np.deg2rad(90-center[1]), np.deg2rad(center[0]),)
pixel=pixel
nreal=0
```

See at the profile of the amplitude relative to amplitude in the input_maps (1e5)... okk


for INU in ['1','2','3','4',]:
    plt.figure(figsize=(14,4))
    for i in range(int(INU)):
        hp.gnomview(allrecon[2][INU][0,i,:,0], rot=center, reso=1.5, 
                    title = 'Rec. {:d}GHz'.format(int(nusfull[INU][i])), sub=(1,int(INU),i+1), 
                    min=-0.04,max=0.5e4)
        neigpix = hp.get_all_neighbours(d['nside'],pixel)
        hp.projscatter(hp.pix2ang(d['nside'],pixel),marker='+',color='r',)
    plt.show()

```{python}
pixel = hp.pixelfunc.ang2pix(d['nside'], np.deg2rad(90-center[1]), np.deg2rad(center[0]),)#
pixel=pixel

#fig,ax=plt.subplots(nrows=2,ncols=d['nf_recon'][-1]//2,
#                   figsize=(20,14))
fig,ax=plt.subplots(nrows=1,ncols=1,
                   figsize=(20,6))
#ax=ax.ravel()
ax = [ax,]
snr = {}
nreal=0
color=iter(cm.rainbow(np.linspace(0,1,len(dictshift)+1 )))
plt.rc('text',usetex=False)
plt.rc('font', size=15)

for j,isub in enumerate([6,]):
    idx='{}'.format(isub)
    ax[j].set_title(r'Rel. intensity nfrec={}'.format(isub))
    ax[j].set_xlabel(r'$\nu[GHz]$')
    ax[j].set_ylabel(r'$I_{\rm A0=1e5}$')

    for k in range(isub):
        NormFact = 1#48/isub
        
        markers = iter(['h','o','+','^','<','>','s','p','*','x','|','_','d','D','1','2','3','4','P','H','x'])
        c=next(color)
        #if k == 0: 
        #else:labelc=None;labelr_2=None;labelr_1=None;labelr00=None;labelr02=None;
        color2=iter(cm.jet(np.linspace(0,1,len(dictshift)+1)))
        #c2=next(color2)
        for inu,irecon in enumerate(allrecon):
            if len(irecon[idx])==0:
                c2=next(color2)
                pass
            else:
                m=next(markers)
                c2=next(color2)
                ax[j].plot(nusfull[idx][k], irecon[idx][nreal,k,pixel,0]*NormFact/1e5, 
                           marker=m, color=c2, ms=8 )
                if (j ==2)&(k+1==isub):
                    ax[j].axvline(nus_in[innu[inu]], color=c2,alpha=0.4,ls='--',lw=3,
                                          label='{:.2f}'.format(nus_in[innu[inu]]))
                    #ax[j].legend(bbox_to_anchor=(2.3, 0.5, 0.5, 0.5))
                    ax[j].legend(bbox_to_anchor=(1.6, 0.5, 0.5, 0.5))
                else:
                    ax[j].axvline(nus_in[innu[inu]], color=c2,alpha=0.4,ls='--',lw=3,)
        if len(irecon[idx])==0:
            pass
        else:
            ringmask=ring4snr(center,d,lth=2,hth=6,doplot=False)
            testmap = irecon[idx][0,k,:,0]
            temean = np.mean(testmap[ringmask])*NormFact/1e5
            #testd = np.sqrt(np.sum((testmap[ringmask])**2)/len(ringmask))*NormFact/1e5
            testd = np.std(testmap[ringmask])*NormFact/1e5
            deltanu = nusfulledge[idx][-1]-nusfulledge[idx][0]
            #print('{} {} {:.6f} {:.4f}'.format(idx, k, temean, testd))
            ax[j].axhspan(ymin=temean-3*testd,ymax=temean+3*testd, 
                          xmin=(nusfulledge[idx][k]-nusfulledge[idx][0])/deltanu,
                          xmax=(nusfulledge[idx][k+1]-nusfulledge[idx][0])/deltanu,
                          color='k', alpha=0.8)
            ax[j].axvspan(nusfulledge[idx][k],nusfulledge[idx][k+1], color=c, alpha=0.35)
    ax[j].grid()
    ax[j].set_xlim(132,168)

#ax[-1].spines['top'].set_visible(False)
#ax[-1].set_axis_off()
#ax[-1].axis("off")
#ax[j].autoscale(False)

```

See the profile of the reconstructed maps for each frequency....
See the distance to the edge (freq where was placed the ps - the edge closest to that frequency) vs. intensity 

```{python}
for NUS in ['6',]:#'6']:#NUS='6'
    #print('NUS = {}'.format(NUS))
    NormFact2=1#48/int(NUS)
    fig,ax=plt.subplots(nrows=1,ncols=2,figsize=(12,4))
    ax=ax.ravel()
    if NUS=='2':
        use = [0,1]
    elif NUS=='4':
        use = [1,2]
    elif NUS=='6':
        use = [2,3]
    #print(NUS)
    for j,ifrec in enumerate(use):
        #print(NUS, ifrec, nusfull[NUS][ifrec])
        yvals=[]
        color2=iter(cm.jet(np.linspace(0,1,len(dictshift)+1)))
        
        for jk,irec in enumerate(allrecon):
            if len(irec[NUS])==0:
                yvals.append(None)
            else:
                yvals.append(irec[NUS][nreal,ifrec,pixel,0]/1e5*NormFact2)

        ax[j].set_title(r'rec{} - I for px in band {:.0f}-{:.0f}GHz'.format(NUS,
                                                                            nusfulledge[NUS][ifrec],
                                                                           nusfulledge[NUS][ifrec+1]))
        ax[j].set_xlabel(r'$\nu$[GHz]')
        #secax.set_xlabel(r'$d_\nu$[GHz](dist to the $\nu_{c}$ of the band)')
        ax[j].set_ylabel(r'$I_\nu(px)$')
        ax[j].set_xlim(nus_in[innu][0]*0.98,nus_in[innu][-1]*1.02)
        
        xvals=nus_in[innu]-nusfull[NUS][ifrec]
        #secax = ax[j].twiny()
        
        for i in range(len(innu)):
            c2=next(color2)
            if yvals[i] == None:
                pass
            else:
                ax[j].plot(nus_in[innu][i],yvals[i],'o',c=c2,ms=12)
                #secax.plot(xvals[i],yvals[i],'o',c=c2,ms=6)
        xlim=ax[j].get_xlim()
        for iedge in nusfulledge[NUS]:
            if (iedge > np.array(xlim)[0]) and (iedge < np.array(xlim)[1]):
                ax[j].axvline(iedge, color='k', ls='--')
        ax[j].grid()
        ax[j].axvspan(nusfulledge[NUS][ifrec],nusfulledge[NUS][ifrec+1], color='k', alpha=0.20)
        print(NUS, ifrec, nusfull[NUS][ifrec])
        ax[j].axvline(nusfull[NUS][ifrec],ls='-.',c='k')
        
```

```{python}
sisi = np.array([1653,3343,2770,5085,8652])
sisi2=np.array([1604,3507,2723,4976,9036])
sisi3=np.array([1524,3384,2860,4575,8518])
sisi4=np.array([1536,3766,2737,5415,8993])
nsisi= sisi/np.sum(sisi)
nsisi2= sisi2/np.sum(sisi2)
nsisi3= sisi3/np.sum(sisi3)
nsisi4= sisi4/np.sum(sisi4)

t0,t2,t3,t4 = 2571.95*nsisi/60, 2794.24*nsisi2/60, 2495.46*nsisi3/60,2666.2*nsisi4/60
print(t0[1:-1])
print('average recon 2,3,4 sub-freqs {:.2f}hs'.format(np.sum(t0[1:-1])), 2571/60)
print('{:.2f}hs'.format(np.sum(t2[1:-1])), 2794/60)
print('{:.2f}hs'.format(np.sum(t3[1:-1])), 2495/60)
print('{:.2f}hs'.format(np.sum(t4[1:-1])), 2666/60)

```

```{python}
for NUS in ['3']:
    NormFact2=1#48/int(NUS)
    fig,ax=plt.subplots(nrows=1,ncols=1,figsize=(6,4))
    ax=[ax,]
    if NUS=='1':
        use = [0,]
    elif NUS=='3':
        use = [1,]
    for j,ifrec in enumerate(use):
        print('ifrec, {},{}'.format(NUS,ifrec))
        yvals=[]
        color2=iter(cm.jet(np.linspace(0,1,len(dictshift)+1 )))
        #secax = ax[j].twiny()
        
        for jk,irec in enumerate(allrecon):
            if len(irec[NUS])==0:
                yvals.append(None)
            else:
                yvals.append(irec[NUS][nreal,ifrec,pixel,0]/1e5*NormFact2)
                
        xvals=(nus_in[innu]-nusfull[NUS][ifrec])/np.diff(nusfulledge[NUS])[ifrec]
        ax[j].set_title(r'Nfrec={} - ps entering to band {:.0f}-{:.0f}GHz'.format(NUS,
                                                                            nusfulledge[NUS][ifrec],
                                                                           nusfulledge[NUS][ifrec+1]))
        ax[j].set_xlabel(r'$\nu$[GHz]')
        #secax.set_xlabel(r'$d_\nu$[GHz][distance to central freq in band]')
        ax[j].set_ylabel(r'$I_\nu$ of central px')
        #ax[j].axvline(nusfulledge[NUS][use[0]+1], color='k', ls='--')

        for i in range(len(innu)):
            c2=next(color2)
            if yvals[i] == None:
                pass
            else:
                ax[j].plot(nus_in[innu][i],yvals[i],'o',c=c2,ms=6)
                #secax.plot(xvals[i],yvals[i],'o',c=c2,ms=6)
        xlim=ax[j].get_xlim()
        for iedge in nusfulledge[NUS]:
            if (iedge > np.array(xlim)[0]) and (iedge < np.array(xlim)[1]):
                ax[j].axvline(iedge, color='k', ls='--')
        #ax[j].axvspan(nusfulledge[NUS][ifrec],nusfulledge[NUS][ifrec+1], color='k', alpha=0.20)
        #print(NUS, ifrec, nusfull[NUS][ifrec])
        ax[j].axvline(nusfull[NUS][ifrec],ls='-.',c='k')
        
        ax[j].grid()
```

NEWX=[all_toFitX[3][0],all_toFitX[3][1],all_toFitX[3][2],all_toFitX[3][3],all_toFitX[3][4],all_toFitX[3][5],all_toFitX[3][6],all_toFitX[3][7],all_toFitX[3][8],
      all_toFitX[3][9],all_toFitX[3][10],all_toFitX[3][11],all_toFitX[3][12],all_toFitX[3][13],#all_toFitX[2][1:4],
all_toFitX[2][4],all_toFitX[2][5], all_toFitX[2][6],all_toFitX[2][7],all_toFitX[2][8],
      all_toFitX[2][9], all_toFitX[2][10],all_toFitX[2][11],
      
all_toFitX[1][2],all_toFitX[1][3],all_toFitX[1][4], all_toFitX[1][5],all_toFitX[1][6],
all_toFitX[1][7],all_toFitX[1][8],all_toFitX[1][9],all_toFitX[1][10],all_toFitX[1][11],

      all_toFitX[0][2],all_toFitX[0][3],all_toFitX[0][4],all_toFitX[0][5],all_toFitX[0][6],all_toFitX[0][7],all_toFitX[0][8],all_toFitX[0][9], all_toFitX[0][10],
all_toFitX[0][11],all_toFitX[0][12],all_toFitX[0][13],all_toFitX[0][14],all_toFitX[0][15],all_toFitX[0][16],all_toFitX[0][17]
     ]

NEWY=[all_toFitY[3][0],all_toFitY[3][1],all_toFitY[3][2],all_toFitY[3][3],all_toFitY[3][4],all_toFitY[3][5],all_toFitY[3][6],all_toFitY[3][7],all_toFitY[3][8],
      np.mean([all_toFitY[3][9],all_toFitY[2][0]]),all_toFitY[3][10], np.mean([all_toFitY[3][11],all_toFitY[2][1]]),np.mean([all_toFitY[3][12],all_toFitY[2][2]]),np.mean([all_toFitY[3][13],all_toFitY[2][3]]),
      all_toFitY[2][4], 
np.mean([all_toFitY[2][5],all_toFitY[3][14]]), all_toFitY[2][6], np.mean([all_toFitY[2][7],all_toFitY[3][15]]),
all_toFitY[2][8],
      np.mean([all_toFitY[2][9],all_toFitY[3][16],all_toFitY[1][0]]),all_toFitY[2][10],np.mean([all_toFitY[2][11],all_toFitY[3][17],all_toFitY[1][1]]),

      np.mean([all_toFitY[1][2],all_toFitY[2][12]]),np.mean([all_toFitY[1][3],all_toFitY[2][13]]), all_toFitY[1][4],np.mean([all_toFitY[1][5],all_toFitY[2][14]]),all_toFitY[1][6],
np.mean([all_toFitY[1][7],all_toFitY[2][15]]), all_toFitY[1][8],np.mean([all_toFitY[2][16],all_toFitY[1][9],all_toFitY[0][0]]),all_toFitY[1][10], np.mean([all_toFitY[2][17],all_toFitY[1][11],all_toFitY[0][1]]),

      np.mean([all_toFitY[0][2],all_toFitY[1][12]]),np.mean([all_toFitY[0][3],all_toFitY[1][13]]),all_toFitY[0][4],np.mean([all_toFitY[0][5],all_toFitY[1][14]]),all_toFitY[0][6],np.mean([all_toFitY[0][7],all_toFitY[1][15]]),all_toFitY[0][8], np.mean([all_toFitY[0][9],all_toFitY[1][16]]),all_toFitY[0][10],np.mean([all_toFitY[0][11],all_toFitY[1][17]]),
all_toFitY[0][11],all_toFitY[0][12],all_toFitY[0][13],all_toFitY[0][14],all_toFitY[0][15],all_toFitY[0][16],all_toFitY[0][17]]
print(len(NEWX), len(NEWY))

```{python}
fig,ax=plt.subplots(nrows=1,ncols=1,figsize=(16,5),sharey=True,gridspec_kw={'wspace': 0.03})
#fig.subplots_adjust(hspace=0.1,wspace=0.4)
searchmin=[]
all_toFitX = []
all_toFitY = []
#all_toFit[:] = np.nan
#ax=ax.ravel()
ax=[ax]
Data=[]
newnewx=[]
for ifreq, NUS in enumerate(['6']):#NUS='6'
    if NUS == '1':
        freqdata = range(1)
    elif NUS == '2':
        freqdata = range(2)
    elif NUS == '3':
        freqdata = range(3)
    elif NUS == '4':
        freqdata = range(4)
    else:
        freqdata = range(6)
    #print('NUS = {}'.format(NUS))
    NormFact2=48/int(NUS)
    markers=iter(['o','*','+','^','d','p'])
    color2=iter(['b','r','g','m','c','k'])
    for ifreqdata in freqdata:
        imark=next(markers)
        yvals=[]
        yconv=[]
        for jk,irec in enumerate(allrecon):
            if len(irec[NUS])==0:
                yvals.append(None)
                yconv.append(None)
                searchmin.append(None)
            else:
                neig=False
                if neig:
                    pixs=hp.get_all_neighbours(d['nside'],pixel)
                    pixs=list(pixs)
                    pixs.append(pixel)
                    yvals.append(np.mean(irec[NUS][nreal,ifreqdata,pixs,0])/1e5*NormFact2)
                    searchmin.append(np.mean(irec[NUS][nreal,ifreqdata,pixs,0])/1e5*NormFact2)
                else:
                    auxval = irec[NUS][nreal,ifreqdata,pixel,0]/1e5*NormFact2
                    yvals.append(auxval)
                    yconv.append(allconv[jk][NUS][nreal,ifreqdata,pixel,0]/1e5*NormFact2)
                    searchmin.append(np.mean(auxval))
                    
        #ax[ifreq].set_title(r'rec{} - I(px) - band {:.0f}-{:.0f}GHz'.format(NUS,
        #                                                                    nusfulledge[NUS][ifreq],
        #                                                                   nusfulledge[NUS][ifreq+1]))
        ax[ifreq].set_xlabel(r'${\rm d}_{\nu_c}$ / $\Delta \nu$' ,fontsize=20)
        ax[ifreq].set_ylabel(r'${i_\nu}$[$\mu K$]' if ifreq ==0 else None, fontsize=20, labelpad=10)
        ax[ifreq].axhline(0,c='k')
        xvals=nus_in[innu]-nusfull[NUS][ifreq]

        xx,yy,yc=[],[],[]
        cenfreq=nusfull[NUS][ifreqdata]
        for i,yh in enumerate(yvals):
            if yh!=None:
                auxx=(nus_in[innu][i]-cenfreq)/(nusfulledge[NUS][ifreqdata+1]-nusfulledge[NUS][ifreqdata])
                xx.append(auxx)
                newnewx.append(auxx)
                yy.append(yh)
                yc.append(yconv[i])
        xx,yy,yc=np.array(xx), np.array(yy), np.array(yc)
        c2=next(color2)

        #Do plot points
        data=ax[ifreq].plot(xx,yy, 
                       marker='o',label='{}'.format(ifreqdata),#None,#imark,
                       ls='-',lw=3, c=c2,alpha=0.7,ms=6)
        
        Data.append(data[0].get_data())
        ax[ifreq].legend()
        if NUS == '4': 
            all_toFitX.append(xx)
            all_toFitY.append(yy)
        
        ax[ifreq].set_xlim(-3.2,3.2)
        xlim=ax[ifreq].get_xlim()
        for iedge in nusfulledge[NUS]:
            if (iedge > np.array(xlim)[0]) and (iedge < np.array(xlim)[1]):
                ax[ifreq].axvline(iedge-cenfreq, color='k', ls='--',alpha=0.9)

        ax[ifreq].axvspan((nusfulledge[NUS][ifreqdata]-cenfreq)/(nusfulledge[NUS][ifreqdata+1]-nusfulledge[NUS][ifreqdata]),
            (nusfulledge[NUS][ifreqdata+1]-cenfreq)/(nusfulledge[NUS][ifreqdata+1]-nusfulledge[NUS][ifreqdata]), 
                          color='k' , alpha=0.40) if ifreqdata == 0 else None
        
        ax[ifreq].axvline(nusfull[NUS][ifreqdata]-cenfreq,ls='-.',c='k' , alpha=0.2)
        
        ax[ifreq].tick_params(axis='both',bottom=True, top=True, left=True, right=True,direction='in')
    ax[ifreq].grid()
#ax[ifreq].plot(NEWX[:46],NEWY[:46],'k-')
#plt.savefig('BFR-unbinned-intensity.pdf',format='pdf')
```

```{python}
print(np.shape(Data))
xData = []#[Data[i][0] for i in range(4)]
yData = []
for i in range(np.shape(Data)[0]):
    for ielement in range(np.shape(Data)[2]):
        xData.append(Data[i][0][ielement])
        yData.append(Data[i][1][ielement])
#
xData, yData = np.array(xData),np.array(yData)
permutation = xData.argsort()
xData = xData[permutation]
yData = yData[permutation]
plt.plot(xData,yData,'bo')
```

Editing xaxis...It shopuld be ~47 values 

### Fit
$\fbox{} \quad \mathrm{Sinusoidal} \quad y_{sin}(x) = \frac{\sin{x}}{x}$ (Model 1)

$\fbox{} \quad \mathrm{Bessel} \quad y_{bes}(x) = 1 - \frac{x^2}{2^2} + \frac{x^4}{2^2~4^2} - \frac{x^6}{2^2~4^2 ~6^2}$ ... (Model 2)

$\fbox{} \quad \mathrm{Polyn} \quad y_{pol}(x) = a+b~x + c~x^2/2+e~x^3/3 +$ ... (Model 3)


#Data to use for model
xFPSF = NEWX[:47]#all_toFitX[2]
yFPSF = NEWY[:47]#all_toFitY[2]
plt.plot(xFPSF, yFPSF)


Generate models...

```{python}
from scipy.special import j0,j1,jn
#Model 1
def model_sin(x,a,b):#c,e,ph):
    return a*np.sin(b*x)/(b*x)#+ e*np.exp(-c*x-ph)

def model_bes(x,a,b):#,e):
    return a*j0(b*x)#+e*np.exp(-c*(x-x0))

def model_pol(x,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12):
    return a0+a1*x+a2*x**2/2+a3*x**3/3+a4*x**4/4+a5*x**5/5+a6*x**6/6 + \
            a7*x**7/7+a8*x**8/8+a9*x**9/9+a10*x**10/10+a11*x**11/11+a12*x**12/12
```

Preparing and fitting models...

```{python}
xFPSF = xData
yFPSF = yData

#sinusoidal
gmodel_sin = Model(model_sin, independent_vars=['x',], )
params_sin = gmodel_sin.make_params(a=0.3,b=1)#c=1, e=0.4,ph=0.4)
result_sin = gmodel_sin.fit(yFPSF, params_sin, x=xFPSF)
parssin = list(result_sin.best_values.values())
print('Sin. Chi2 {:.3f}'.format(result_sin.chisqr ))

#bessel
gmodel_bes = Model(model_bes, independent_vars=['x',], )
params_bes = gmodel_bes.make_params(a=0.3,b=0.1,)#c=0.3, e=0.5,x0=0.5 )
result_bes = gmodel_bes.fit(yFPSF, params_bes, x=xFPSF)
parsbes = list(result_bes.best_values.values())
print('Bes. Chi2 {:.3f}'.format(result_bes.chisqr) )

#polynomial
gmodel_pol = Model(model_pol, independent_vars=['x',], )
params_pol = gmodel_pol.make_params(a0=1,a1=1,a2=1,a3=1,a4=1,a5=1,a6=1,a7=1,a8=1,a9=1,a10=1,a11=1,a12=1 )
result_pol = gmodel_pol.fit(yFPSF, params_pol, x=xFPSF)
parspol = list(result_pol.best_values.values())
print('Pol. Chi2 {:.3f}'.format(result_pol.chisqr) )

```

See results...

```{python}
#fig,ax=plt.subplots(nrows=1,ncols=3)
result_pol.plot()
#result_sin.plot()
#result_bes.plot()
dely = result_pol.eval_uncertainty(sigma=3)
plt.axvspan(-0.5,0.5,color='k',alpha=0.4)
plt.axvspan(-1.5,-0.5,color='k',alpha=0.2)
plt.axvspan(0.5,1.5,color='k',alpha=0.2)

plt.fill_between(xData, result_pol.best_fit-dely, result_pol.best_fit+dely, color='cyan',#"#ABABAB",
                 alpha=0.6, label='3-$\sigma$ uncertainty band')

```

```{python}
xfake=np.linspace(-2,2.5)
plt.xlabel(r'${\rm d}_{\nu_c}$ / $\Delta \nu$')
plt.ylabel(r'${i_\nu}$[$\mu K$]')
plt.plot(xFPSF, yFPSF, 'bo', label='Data')
plt.plot(xfake,model_sin(xfake, *parssin),'r-',label='Sinusoidal')
plt.plot(xfake,model_bes(xfake, *parsbes),'g-',label='Bessel')
plt.plot(xfake,model_pol(xfake, *parspol),'c-',label='Polynom')
plt.legend(fontsize=10)
```

Save model...

```{python}
from lmfit.model import save_modelresult
save_modelresult(result_pol, 'polynomial_modelresult_nrec{}.sav'.format(np.shape(Data)[0]))
```

Fit gaussian to profiles.

I will fit the FWHM in the maps where the point source is cleary located in the band. For that I can plot manually and see the SNR level in the edge between band and take those maps where SNR are high and almost constant in the value

```{python}
def gaussian2d_b(x, amp,x0, y0, varx, vary):
    gauss = np.zeros((len(x),len(x)))
    #amp=1 / (2 * np.pi * varx * vary)
    for i in range(200):
        for j in range(200):
            gauss[i,j] = amp*np.exp(-0.5*( (x[i]-x0)**2/varx**2+(x[j]-y0)**2/vary**2) )
            
    return gauss.ravel()
def fixnside(ns):
    if ns == 1024:
        return 900
    elif ns==256:
        return 250
    elif ns==512:
        return 700
```

```{python}
for NUS in [2,3,4]:#NUS=4
    print('============================')
    print(' NUS ', NUS)
    NUSt=str(NUS)
    if NUS==2:
        coso2=np.zeros((NUS,len(allrecon)))
    elif NUS==3:
        coso3=np.zeros((NUS,len(allrecon)))
    elif NUS==4:
        coso4=np.zeros((NUS,len(allrecon)))
    coso=np.zeros((NUS,len(allrecon)))
    size=200
    reso=2.5
    xscale=np.linspace(-size/2,size/2,size)*reso/60
    xgrid,ygrid = np.meshgrid(xscale,xscale)[0].ravel(),np.meshgrid(xscale,xscale)[1].ravel()
    best_fit_full=np.zeros((NUS,20,3))
    indx=[]
    for isub in range(NUS):
        best_fit_res=np.zeros((20,3))
        Fact=48/NUS
        print("Band | pos-nu-array | FWHMmeasured  | FWHM6134 | FWHMdictionary | Error sqrt(varx**2+vary**2) ")
        print("============================================================================================")
        for ipos in range(len(allrecon)):
            if len(allrecon[ipos][NUSt])==0:
                pass
            else:
                newnside=1024
                
                cut=800
                if NUS==3:
                    if ipos==1:
                        cut = 900 #if NUS==2 else 280
                
                if newnside!=d['nside']:
                    print('udgrading map')
                    newmap=hp.ud_grade(allrecon[ipos][NUSt][nreal,isub].T, newnside).T
                else:
                    print('no udgrading map')
                    newmap=allrecon[ipos][NUSt][nreal,isub]

                fitmap=hp.gnomview(newmap[:,0]/1e5*Fact,rot=center, reso=reso,
                                   return_projected_map=True,xsize=200,
                                   no_plot=True)

                snr=anpsf.computeSNR_maps(newmap/1e5*Fact,d,center,nside=newnside,threshold=4)
                coso[isub,ipos] = snr
                if snr > cut:
                    gmodel = Model(gaussian2d_b, independent_vars=['x',], )
                    #Set initial guess 
                    fwhmTemplate=d['synthbeam_peak150_fwhm']*150/nusfull[NUSt][isub]
                    #fwhmTemplate=d['synthbeam_peak150_fwhm']*150/nus_in[innu[ipos]]*np.sqrt(8*np.log(2))
                    #fwhmTemplate=61.3474/nusfull[NUSt][isub]*np.sqrt(8*np.log(2))
                    params = gmodel.make_params(amp=1.,x0=0, y0=0, varx=fwhmTemplate*np.sqrt(8*np.log(2)), 
                                                vary=fwhmTemplate*np.sqrt(8*np.log(2)))

                    result = gmodel.fit(fitmap.ravel(), params, x=xscale)
                    #print(result.fit_report())
                    fwhm=np.sqrt(result.best_values['varx']*result.best_values['vary'])*np.sqrt(8*np.log(2))
                    print("{}    |     {:.2f} \t   |   {:.3f} \t| {:.3f}\t|{:.3f}\t|{:.5f}".format(isub+1, 
                                                            snr, fwhm, 
                                                            61.34/nus_in[innu[ipos]], 
                                                            d['synthbeam_peak150_fwhm']*150/nus_in[innu[ipos]],
                                                            np.sqrt(result.covar[-1,-1]+result.covar[-2,-2])))
                    best_fit_res[ipos] = np.array([fwhm, 61.34/nusfull[NUSt][isub], 
                                        d['synthbeam_peak150_fwhm']*150/nusfull[NUSt][isub]] )
                else:
                    fwhm=np.NaN
                    best_fit_res[ipos] = np.array([fwhm, 61.34/nusfull[NUSt][isub], 
                                        d['synthbeam_peak150_fwhm']*150/nusfull[NUSt][isub]] )
        best_fit_full[isub] = best_fit_res
        #np.nanmean(each,axis=0)[0]-
    if NUS==2:
        results_2 = best_fit_full
        coso2=coso
    elif NUS==3:
        results_3 = best_fit_full
        coso3=coso
    elif NUS==4:
        results_4 = best_fit_full
        coso4=coso
#allTodo.append[best_fit_full]
```

```{python}
best_fit_full
```

```{python}
from scipy.stats import median_abs_deviation as mad
import scipy.stats as sc
```

```{python}
print('NUS \t NU    Mean FWHMthAv FWHMth Std MAD')
for j,each in enumerate(results_2):
    print('NUS = 2 {:.2f} {:.3f} {:.3f} {:.3f} {:.3f} {:.3f}'.format(nusfull['2'][j], np.nanmean(each,axis=0)[0],
                                                    np.nanmean(each,axis=0)[2],
                                                   61.34/nusfull['2'][j],
                                                 np.nanstd(each ,axis=0)[0],
                                                mad(each,axis=0,nan_policy='omit') ) )
#
print('========')
for j,each in enumerate(results_3):
    print('NUS = 3 \t {:.2f} {:.3f} {:.3f} {:.3f} {:.3f}'.format(nusfull['3'][j], np.nanmean(each,axis=0)[0],
                                                   61.34/nusfull['3'][j],
                                                 np.nanstd(each ,axis=0)[0],
                                                         mad(each,axis=0,nan_policy='omit') ))
#
print('========')
for j,each in enumerate(results_4[1:]):
    j+=1
    print('NUS = 4 \t {:.2f} {:.3f} {:.3f} {:.3f} {:.3f}'.format(nusfull['4'][j], np.nanmean(each[2:],axis=0)[0],
                                                   61.34/nusfull['4'][j],
                                                                 np.nanstd(each[2:] ,axis=0)[0],
                                                mad(each[2:],axis=0,nan_policy='omit'),
                                                                  ))
    
```

```{python}
fig,ax=plt.subplots(nrows=1,ncols=3,figsize=(15,5),sharey=True, gridspec_kw={'hspace': 0.03})
ax=ax.ravel()
#fwhmTh = lambda nu: 61.3474/nu
fwhmTh = lambda nu: d['synthbeam_peak150_fwhm']*150/nu
fig.suptitle(r'FWHM for maps with high SNR in each sub-band. ud={} -cut$_{{SNR}}$={}'.format(newnside,cut))
ax[0].set_xlabel(r'$\nu~$[GHz]')
ax[1].set_xlabel(r'$\nu~$[GHz]')
ax[2].set_xlabel(r'$\nu~$[GHz]')
ax[0].set_ylabel(r'$FWHM~$[deg]')
for j,each in enumerate(results_2):
    ax[0].errorbar(nusfull['2'][j],np.nanmean(each,axis=0)[0],
                   yerr=np.nanstd(each ,axis=0)[0],
                   fmt='o',c='b')
    #ax[0].errorbar(nusfull['2'][j]*1.001,np.nanmean(each,axis=0)[0],
    #               yerr=mad(each,axis=0,nan_policy='omit'),
    #               fmt='o',c='r')
    ax[0].text(nusfull['2'][j], (np.nanmean(each,axis=0)[0]+fwhmTh(nusfull['2'][j]) )/2 , 
               '{:.3f}'.format((np.nanmean(each,axis=0)[0]-fwhmTh(nusfull['2'][j]) )) )
    ax[0].plot(nusfull['2'][j],fwhmTh(nusfull['2'][j]), 'ko')
for j,each in enumerate(results_3):
    
    ax[1].errorbar(nusfull['3'][j],np.nanmean(each,axis=0)[0],
                   yerr=np.nanstd(each ,axis=0)[0],
                   fmt='o',c='b', label='Averaged FWHM' if j==0 else None)
    #ax[1].errorbar(nusfull['3'][j]*1.001,np.nanmean(each,axis=0)[0],
    #               yerr=mad(each,axis=0,nan_policy='omit'),
    #               fmt='o',c='r', label='MAD' if j==0 else None)
    ax[1].text(nusfull['3'][j], (np.nanmean(each,axis=0)[0]+fwhmTh(nusfull['3'][j]) )/2 , 
               '{:.3f}'.format((np.nanmean(each,axis=0)[0]-fwhmTh(nusfull['3'][j]) )) )
    ax[1].plot(nusfull['3'][j],fwhmTh(nusfull['3'][j]), 'ko', label='Theoretical FWHM' if j==0 else None)
for j,each in enumerate(results_4[1:]):
    j+=1
    ax[2].errorbar(nusfull['4'][j],np.nanmean(each[2:],axis=0)[0],
                   yerr=np.nanstd(each[2:] ,axis=0)[0],
                   fmt='o',c='b')
    #ax[2].errorbar(nusfull['4'][j]*1.001,np.nanmean(each[2:],axis=0)[0],
    #               yerr=mad(each[2:],axis=0,nan_policy='omit'),
    #               fmt='o',c='r')
    ax[2].text(nusfull['4'][j], (np.nanmean(each[2:],axis=0)[0] + fwhmTh(nusfull['4'][j]) )/2 , 
               '{:.3f}'.format((np.nanmean(each[2:],axis=0)[0]-fwhmTh(nusfull['4'][j]) )) )
    ax[2].plot(nusfull['4'][j], fwhmTh(nusfull['4'][j]), 'ko')
#
ax[1].legend(bbox_to_anchor=(0., 1.08), fontsize=10,loc='upper left',ncol=3)
for i in range(3):
    ax[i].tick_params(axis='both',bottom=True, top=True, left=True, right=True,direction='in')
    ax[i].grid()
#
plt.tight_layout() #makes subplots nicely fit in the figure.
```

```{python}
fig,ax=plt.subplots(nrows=1,ncols=3,figsize=(14,6), sharey=True, gridspec_kw={'hspace': 0.03})
ax[0].set_ylabel(r'SNR in rec maps for each simulation')
color=iter(cm.jet_r(np.linspace(0,1,5)))
for i in range(2):
    ax[0].plot(coso2[i],'o-',c=next(color), label='sub-band {}'.format(i+1))
    ax[0].axhline(cut, ls='--',c='k')#
    ax[0].legend(fontsize=12)
#

color=iter(cm.jet_r(np.linspace(0,1,5)))
for i in range(3):
    c=next(color)
    ax[1].plot(coso3[i],'o-',c=c, label='sub-band {}'.format(i+1))
    ax[1].axhline(cut, ls='--',c='k')
    #if i ==1:
    #    ax[1].axhline(900, ls='--',c=c)
    ax[1].set_xlabel('simulation')
    ax[1].legend(fontsize=12)
#
color=iter(cm.jet_r(np.linspace(0,1,5)))
for i in range(4):
    ax[2].plot(coso4[i],'o-',c=next(color),label='sub-band {}'.format(i+1))
    ax[2].axhline(cut, ls='--',c='k')
    ax[2].legend(fontsize=12)
#
```

```{python}
plt.imshow(fitmap.reshape(200,200),extent=[xscale[0],xscale[-1],xscale[0],xscale[-1],])
#plt.axvline(0,ls='--', c='w',alpha=0.4)
plt.axvline(-0.4,ls='--', c='w',alpha=0.4)
plt.axvline(0.4,ls='--', c='w',alpha=0.4)
#plt.axhline(0,ls='--', c='w',alpha=0.4)
plt.axhline(-0.4,ls='--', c='w',alpha=0.4)
plt.axhline(0.4,ls='--', c='w',alpha=0.4)

```

```{python}
np.max(fitmap)
```

```{python}
from lmfit import Model
def gaussian2d_b(x, amp,x0, y0, varx, vary):
    gauss = np.zeros((len(x),len(x)))
    #amp=1 / (2 * np.pi * varx * vary)
    for i in range(200):
        for j in range(200):
            gauss[i,j] = amp*np.exp(-0.5*( (x[i]-x0)**2/varx**2+(x[j]-y0)**2/vary**2) )
            
    return gauss.ravel()


gmodel = Model(gaussian2d_b, independent_vars=['x',])
print('parameter names: {}'.format(gmodel.param_names))
print('independent variables: {}'.format(gmodel.independent_vars))

#Set initial guess 
params = gmodel.make_params(amp=4e3,x0=0, y0=0, varx=0.4/2.35, vary=0.35/2.35)
#testeval=gmodel.eval(params, x=xscale).reshape(200,200)
#plt.imshow(testeval)
#plt.show()
result = gmodel.fit(fitmap.ravel(), params, x=xscale)
fwhm=np.sqrt(result.best_values['varx']*result.best_values['vary'])*np.sqrt(8*np.log(2))
```

```{python}
plt.imshow(result.best_fit.reshape(200,200))
print(result.fit_report())
```

### Old way... not use


Choose the maps with higher SNR to fit point sources reconstruction


np.shape(allrecon[0]['2'][1:])

```{python}

```

```{python}
if len(irec[NUS])==0:
            yvals.append(None)
```

```{python}
reload(anpsf)
infofit={}
for NUS in ['1','2','3','4','6']:
    if NUS == '1':
        ifreqdata=0
    elif NUS == '2' or NUS == '3':
        ifreqdata = 1
    else:
        ifreqdata=2
    data =[ifreqdata]
    snraux=[]
    for irec in range(len(allrecon)):
        if len(allrecon[irec][NUS])==0:
            pass
        else:
            snraux.append(anpsf.computeSNR_maps(allrecon[irec][NUS][nreal,ifreqdata], 
                                                d, center, threshold =5))
    data.append(np.argmax(snraux))
    infofit.update({NUS:data})
```

```{python}
infofit
```

Look at the amplitude of the point sources for reconstructed maps...


### Fit angular resolution


Make the fit calibration

```{python}
CteConf=d['synthbeam_peak150_fwhm'] * 150
nuscal = np.linspace(128,172,20)
fwhmcal = CteConf/nuscal
sample = 20
amplitude = 1#e5 #initial amplitude

reso=5
size=200
vec_pix = hp.pix2vec(d['nside'], pixel)
vec_pixeles = hp.pix2vec(d['nside'], np.arange(12*d['nside']**2))
ang_pixeles = np.arccos(np.dot(vec_pix,vec_pixeles))
angmask = d['dtheta']
mask = np.rad2deg(ang_pixeles) < angmask

x_map = np.linspace(-size/2,size/2,size)*reso/60
y_map = x_map
x_map, y_map = np.meshgrid(x_map, y_map)

x0data_map = x_map.ravel()
x1data_map = y_map.ravel()

"""
ellip:  (NOT IMPLEMENTED)ellipticity of the fitted gaussian. 
        Following BICEP2/keck definition (arXiv:0906.4069)
       e = (sigma_a - sigma_b) / (sigma_a + sigma_b)
"""

deltaFwhm_cal = np.zeros( (len(fwhmcal), 1) )
#position_center_fit = np.zeros((n_subpop,1))
```

```{python}
f0 = np.zeros((sample, 12*d['nside']**2,))
f0[:,pixel] = 1
f0 = [hp.smoothing(f0[i], fwhm = np.radians(fwhmcal[i]), verbose=False) for i in range(len(f0))]
```

```{python}
# Fit Method
fwhmmeasured = np.empty((sample,))
diffwhm = np.zeros_like(fwhmmeasured)
maparray=np.zeros((sample, size,size))
sigma2fwhm=2.35
for i,mi in enumerate(f0):
    maparray[i] = hp.gnomview(mi, rot=center, reso=reso, xsize=size, 
                              return_projected_map=True, no_plot=True)
    norm_fit = normalization(x_map[0],maparray[i])
    ydata_map = (norm_fit * maparray[i]).ravel()
    
    popt_map, pcov_map = curve_fit(gaussian2d, np.array([x0data_map,x1data_map]), ydata_map, method='trf')
    fwhmmeasured[i] = (abs(popt_map[3])+abs(popt_map[4]))/2*sigma2fwhm
    diffwhm[i] = (fwhmmeasured-fwhmcal)[i]
#Save interpolation 
FuncInt = interp1d(nuscal, diffwhm)
```

```{python}
#for i in range(len(fwhm)):
#    print('{:.2f} \t {:.2f} \n'.format(input_fwhm_fit[i], fwhm[i] ))
plt.figure(figsize=(8,6))
plt.ylim(0.35,0.63)
plt.plot(nuscal, fwhmcal, 'ko', label='real')
plt.plot(nuscal, fwhmmeasured, 'rs', label='measured')
plt.vlines(x=nuscal,ymin=fwhmcal, ymax=fwhmmeasured, colors='r', alpha= 0.2, ls='--' )
plt.grid()
#plt.text(132,0.58,r'$\Delta$FWHM', fontsize=16)
plt.xlabel(r'$\nu$[GHz]', fontsize=15)
plt.ylabel(r'FWHM[deg]', fontsize=15)
plt.legend(loc='best', fontsize=14)
```

# Calibration DONE.- 

Start fitting maps...

```{python}
infofit
```

```{python}
plt.figure(figsize=(12,4))
for i,NUS in enumerate(['1','2','3','4','6']):
    dt=infofit[NUS]
    print(dt, i, np.shape(allrecon[dt[1]][NUS]))#,dt[0],:,0])
    hp.gnomview(allrecon[dt[1]][NUS][nreal,dt[0],:,0],sub=(1,5,i+1), rot=center,reso=2)
```

```{python}
fwhm_maps = {}
ellp_maps = {}
#diffwhm2=np.zeros((nsub,))
mpy=np.zeros((,size,size))
for i,ikey in enumerate(map4fit.keys()):
    for ireal in range(3):
        mpy[i,ireal] = hp.gnomview(map4fit[ikey][ireal], rot=center, reso=reso, xsize=size, 
                                  return_projected_map=True, no_plot=True)
        plt.clf()
        norm_fit = normalization(x_map[0],mpy[i,ireal])
        ydata_map = (norm_fit * mpy[i,ireal]).ravel()

        popt_map, pcov_map = curve_fit(gaussian2d, np.array([x0data_map,x1data_map]), 
                                       ydata_map, method='trf')
        ellp_maps.update({ikey:popt_map[3]/popt_map[4]})
        fwhm_maps.update({ikey:(abs(popt_map[3])+abs(popt_map[4]))/2*sigma2fwhm})
        #diffwhm2[i] = (input_fwhm_fit2-fwhm2)[i]

#npsf.plotting(dirc = 'nersc', simu = ['32091820'], 
#               date = '20200620', reso = 2, savefig=False, 
#               filename='../psf_20-25nus-smFOV-Fix', setlim=False)
```

```{python}
print('== Covariance matrix ==')
[print(pcov_map[i]) for i in range(len(pcov_map))]
print('== Ellipticity ==')
print(ellp_maps)
print('== FWHM(nu) / hp.resolution ==')
print(np.array(list(fwhm_maps.values()))*60/hp.nside2resol(d['nside'],arcmin=True))
```

concon=gaussian2d(np.array([x_map.ravel(),y_map.ravel()]),
                  *popt_map  ).reshape((200,200))
plt.xlabel(r'x')
plt.xlabel(r'y')
plt.contourf(concon, extent=[x_map.min(),x_map.max(),y_map.min(),y_map.max()] )  

```{python}

```

```{python}

```

Plot resulting measure vs real values. (compare against freq edges too)...

```{python}
#nreals, nrec,4
#allfwhm=[]
FWHMs = {}#np.zeros((4,6,4))
difff = []
for j,ikey in enumerate(nus4fit.keys()):
    if j==0: labelm = 'measured'; labelr='real'; labelu='unbised';labele='edge freq(shifted)'
    else: labelm=None; labelr=None; labelu=None; labele=None
    plt.title(r'N_s = {}'.format(d['nf_sub']))
    plt.plot(nus4fit[ikey],fwhm_maps[ikey], 'rs',label=labelm)
    plt.plot(nus4fit[ikey],CteConf/nus4fit[ikey],'ks',label=labelr)
    plt.plot(nus4fit[ikey],fwhm_maps[ikey]-FuncInt(nus4fit[ikey]), 'gs', label=labelu)
    plt.plot(nus4fit[ikey],CteConf/nusedge4fit[ikey],'bo', label=labele)
    FWHMs.update({ikey:[CteConf/nus4fit[ikey],
                                      fwhm_maps[ikey]-FuncInt(nus4fit[ikey]),
    plt.legend(loc='best')
    difff.append(fwhm_maps[ikey]-FuncInt(nus4fit[ikey]) - CteConf/nus4fit[ikey])
plt.grid()
print('diff = real - unbiased {}'.format(difff))
```

The green dots, at which frequency corresponds? Is it to the worst resolution within the band where it belongs?...


```{python}
nuspsf = []
valpsf = []
for i in range(len(NUSPSF)):
    nuspsf.extend(NUSPSF[i][:])
    valpsf.extend(VALPSF[i][:])
nuspsf=np.array(nuspsf)
valpsf=np.array(valpsf)
iindice=nuspsf.argsort()
nuspsf = nuspsf[iindice]
valpsf = valpsf[iindice]
jd=np.where(nuspsf==150.0)

def fgauss(x,amp,nu0,var0):
    return amp*np.exp(-0.5*(x-nu0)**2/var0**2 )

pgauss,vgauss=curve_fit(fgauss, np.delete(nuspsf, jd), np.delete(valpsf, jd),p0=[0.2,150,10])
#pgauss,vgauss=curve_fit(fgauss, nuspsf, valpsf,p0=[0.2,150,10])
print(vgauss[-1,-1])
plt.title(r'$N_s$ = {}, $\nu_0$ = {:d}'.format(d['nf_sub'],int(nus_in[10])))
plt.plot(nuspsf, valpsf,'ko')
plt.plot(nuspsf[jd], valpsf[jd],'rx',ms=12)
x=np.linspace(nuspsf[0],nuspsf[-1],200)
plt.plot(x, fgauss(x, *pgauss),'g-', label=r'$\nu = ${:.2f}, $\sigma = ${:.2f}'.format(pgauss[1],pgauss[2]))
plt.legend()
plt.grid()
print('fWhm {:.1f}'.format(pgauss[2]*sigma2fwhm))
```

```{python}

```

```{python}
c1,c2,c3,c4,c5,c6 = [],[],[],[],[],[]
print('nu \t real \t unbiased \t unbised-real')
for each in [f12,f15,f20,f25]:
    
```

```{python}
#search the border of the band
print(ind)
bind=[]#np.zeros((len(ind)))
for ikey in nus4fit.keys():
    bind.append = nusfulledge[ikey][i]
        print('{} \t {} \n'.format(bind[j], ind[j]))

```

```{python}
optcf,covcf=anpsf.fitGauss_one(dirc = 'nersc', simu =['31901895','31901911', '31982984','31983445'],
                   plotraw=False, plotfit=True)
```
