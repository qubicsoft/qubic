---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

#### Author: Mart√≠n Gamboa

Aim: analize the simulations rfor the study of the Point Spread Function (PSF) in frequency.

For each simulation: 
* read files (two different formats)
* plot raw data
* fit gaussian 
* compute SNR 

(this Martin's notebooks will replace plot.py, plot-raw.py, plot-results.py, plot-results2.py, plot-manyps.py, plot-MC-results.py

```{python}
import healpy as hp
import matplotlib.pyplot as plt
import matplotlib as mp
from qubicpack.utilities import Qubic_DataDir
import qubic
import os
import sys
import pickle as pk
import numpy as np
import glob
from astropy.io import fits

from scipy.optimize import curve_fit
from importlib import reload
import AnalysisPSF as anpsf
from scipy.interpolate import interp1d
from matplotlib.pyplot import cm
from matplotlib.patches import Ellipse
```

```{python}
def normalization(x,mapa):
    ef = np.trapz((np.trapz(mapa,x,axis=0)),x)
    return 1/ef

def gaussian2d(z, amp,x0, y0, varx, vary):
    x=z[0]
    y=z[1]
    gauss = amp*np.exp(-0.5*((x-x0)**2/varx**2+(y-y0)**2/vary**2))
    return gauss.ravel()
def get_maps(file):
    simu = fits.open(file)

    maps_recon = simu['MAPS_RECON'].data
    maps_convo = simu['MAPS_CONVOLVED'].data

    diff = maps_recon - maps_convo

    return maps_recon, maps_convo, diff

def get_maps_many_files(rep_simu, name, verbose=True):
    all_fits = glob.glob(rep_simu + name)
    nfiles = len(all_fits)
    if verbose:
        print('{} files have been found.'.format(nfiles))

    all_maps_recon = []
    all_maps_convo = []
    all_maps_diff = []

    for i, fits in enumerate(all_fits):
        map_recon, map_convo, map_diff = get_maps(fits)
        if i == 0:
            right_shape = map_recon.shape
        else:
            if map_recon.shape != right_shape:
                raise ValueError('You should take maps with identical shapes.')
        all_maps_recon.append(map_recon)
        all_maps_convo.append(map_convo)
        all_maps_diff.append(map_diff)

    return all_fits, np.asarray(all_maps_recon), \
           np.asarray(all_maps_convo), np.asarray(all_maps_diff)

def read_run(jobid, repo=None, fixpar=True):
    """
    Supose: dictionary inside directory
    
    =====================
    Parameters:
        jobid: number jobid from NERSC
        repo: directory where runs are
        fixpar: some parameters had have change from original dictionary values. These allows adapt it
    Return:
        
    """
    repo = os.environ['QUBIC_DATADIR']+'scripts/Spectroimagery_paper/output_paper/nersc/{}/'.format(jobid)
    repodict = glob.glob(repo+'*.dict')[0]

    d = qubic.qubicdict.qubicDict()
    d.read_from_file(repodict)
    center = qubic.equ2gal(d['RA_center'], d['DEC_center'])
    if fixpar:
        d['nf_sub']=48
        d['nf_recon'] = [1,2,3,4,6] 
    #nsub = d['nf_recon'][-1]
    
    _,_,nus_in,_,_,_=qubic.compute_freq(150,d['nf_sub'],0.25)
    sigma2fwhm = np.sqrt(8*np.log(2))
    # constant angular resolution using P = 19 and deltaX = 1.4cm
    CteConf = 61.57622 #2.998e10/20/1.4/1e9/np.pi*180
    size=200
    reso = 3
    nside=d['nside']
    
    #if nsub not in d['nf_recon']: raise ValueError('Invalid number of sub-bands for {} nus_in'.format(d['nf_sub']))
    #_,_,nus_rec,_,_,_=qubic.compute_freq(150,nsub,0.25)
    print("Working with nf_sub = {} and nfrec = {}".format(d['nf_sub'], d['nf_recon']))
    mapsrec={}
    mapsconv={}
    nusfull = {}
    nusfulledge = {}
    for isub in d['nf_recon']:
        _, maprec, mapconv, mapdif = get_maps_many_files(repo,'*recon{}*.fits'.format(isub))
        _,inusedge,inus,_,_,_=qubic.compute_freq(150,isub,0.25)
        mapsrec.update({'{}'.format(isub): maprec})
        mapsconv.update({'{}'.format(isub): mapconv})
        nusfull.update({'{}'.format(isub):inus})    
        nusfulledge.update({'{}'.format(isub):inusedge})    
    

    return mapsrec, mapsconv,nusfull,nusfulledge, nus_in, center,d

```

```{python}
#jobids = ['32139830', '32140318','32139772', '32140658'] #[12,15,20,25]
#jobids= ['32759969','32759907',#'32574156','32574178', 
#          '32574170','32759934',]#'32574174','32759973'] #[48,48]|[1,2,3,4,6]
dictshift = {'32832344':-7, '32759969':-4,'32759907':-3, '32574156':-2, '32574178':-1, 
             '32574170':0, '32759934': 1, '32574174': 2, '32759973':3, '32832346':7 }
jobids=list(dictshift.keys())
allrecon = []
jobid = np.zeros((len(jobids)))
for ijob in range(len(jobids)):
    print('Reading job {} ({}/{})'.format(jobids[ijob],ijob+1,len(jobids)))
    if ijob == 0:
        maprec, mapsconv, nusfull,nusfulledge,nus_in,center,d = read_run(jobids[ijob])
    else: 
        maprec,_,_,_,_,_,_ = read_run(jobids[ijob])
        
    allrecon.append(maprec)
allrecon = np.array(allrecon)

#Index where the point source was placed
NU0=150

innu0 = min(range(len(nus_in)), key=lambda i: abs(nus_in[i]-NU0))
innu = []
for ishift in dictshift.values():
    innu.append(innu0+ishift)
```

Compute noise level at different angular distance to the source

```{python}
def ring4snr(center,d,lth=6,hth=8, doplot=False):
    pxvec = hp.ang2vec(center[0],center[1],lonlat=True)
    ip = np.arange(12*d['nside']**2)
    vpix = hp.pix2vec(d['nside'],ip)
    vecs = np.degrees(np.arccos(np.dot(pxvec,vpix)))
    seenring = np.zeros((12*d['nside']**2),dtype=bool)
    seenring[(vecs < hth) & (vecs > lth)]=int(1)
    if doplot: hp.mollview(seenring,rot=center)
    return seenring

#def multiring(center,d,minth,maxth,step=0.5):
#    
#    for i in np.arange(minth,maxth,0.5):
#        ringmask.append(ring4snr(center,d,lth=i,hth=i+1,doplot=False))
#    
#testmap = allrecon[0]['2'][0,0,:,0]
#print(3*np.sqrt(np.sum((testmap[ringmask])**2))*48/int(inu))

```

See at the profile of the amplitude relative to amplitude in the input_maps (1e5)... okk

```{python}
pixel = hp.pixelfunc.ang2pix(d['nside'], np.deg2rad(90-center[1]), np.deg2rad(center[0]),)
pixel=pixel
nreal=0
#INU='4'
for INU in ['1','2','3','4','6']:
    plt.figure(figsize=(14,4))
    for i in range(int(INU)):
        hp.gnomview(allrecon[1][INU][0,i,:,0], rot=center, reso=1.5, 
                    title = 'Rec. {:d}GHz'.format(int(nusfull[INU][i])), sub=(1,int(INU),i+1), 
                    min=-0.04,max=0.5e4)
        neigpix = hp.get_all_neighbours(d['nside'],pixel)
        hp.projscatter(hp.pix2ang(d['nside'],pixel),marker='+',color='r',)
    plt.show()
```

```{python}
pixel = hp.pixelfunc.ang2pix(d['nside'], np.deg2rad(90-center[1]), np.deg2rad(center[0]),)#
pixel=pixel
lbr = iter(['recon-4','recon-3','recon-2','recon-1',
            'recon0','recon+1','recon+2','recon+3'])
fig,ax=plt.subplots(nrows=2,ncols=d['nf_recon'][-1]//2,
                   figsize=(20,14))
ax=ax.ravel()
snr = {}
nreal=0
color=iter(cm.rainbow(np.linspace(0,1,16)))
plt.rc('text',usetex=False)
plt.rc('font', size=15)

for j,isub in enumerate(d['nf_recon']):
    idx='{}'.format(isub)
    ax[j].set_title(r'Rel. intensity nfrec={}'.format(isub))
    ax[j].set_xlabel(r'$\nu[GHz]$')
    ax[j].set_ylabel(r'$I_{\rm A0=1e5}$')

    for k in range(isub):
        NormFact = 1#48/isub
        
        markers = iter(['h','o','+','^','<','>','s','p','*','x'])
        c=next(color)
        #if k == 0: 
        #else:labelc=None;labelr_2=None;labelr_1=None;labelr00=None;labelr02=None;
        color2=iter(cm.jet(np.linspace(0,1,10)))
        #c2=next(color2)
        for inu,irecon in enumerate(allrecon):
            if len(irecon[idx])==0:
                c2=next(color2)
                pass
            else:
                m=next(markers)
                c2=next(color2)
                ax[j].plot(nusfull[idx][k], irecon[idx][nreal,k,pixel,0]*NormFact/1e5, 
                           marker=m, color=c2, ms=8 )
                if (j ==3)&(k+1==isub):
                    ax[j].axvline(nus_in[innu[inu]], color=c2,alpha=0.4,ls='--',lw=3,
                                          label='{:.2f}'.format(nus_in[innu[inu]]))
                    ax[j].legend(bbox_to_anchor=(2.3, 0.5, 0.5, 0.5))
                else:
                    ax[j].axvline(nus_in[innu[inu]], color=c2,alpha=0.4,ls='--',lw=3,)
        
        ringmask=ring4snr(center,d,lth=2,hth=6,doplot=False)
        testmap = irecon[idx][0,k,:,0]
        temean = np.mean(testmap[ringmask])*NormFact/1e5
        #testd = np.sqrt(np.sum((testmap[ringmask])**2)/len(ringmask))*NormFact/1e5
        testd = np.std(testmap[ringmask])*NormFact/1e5
        deltanu = nusfulledge[idx][-1]-nusfulledge[idx][0]
        #print('{} {} {:.6f} {:.4f}'.format(idx, k, temean, testd))
        ax[j].axhspan(ymin=temean-3*testd,ymax=temean+3*testd, 
                      xmin=(nusfulledge[idx][k]-nusfulledge[idx][0])/deltanu,
                      xmax=(nusfulledge[idx][k+1]-nusfulledge[idx][0])/deltanu,
                      color='k', alpha=0.8)
        ax[j].axvspan(nusfulledge[idx][k],nusfulledge[idx][k+1], color=c, alpha=0.35)
    ax[j].grid()
    ax[j].set_xlim(132,168)

ax[5].spines['top'].set_visible(False)
ax[5].set_axis_off()
ax[5].axis("off")
#ax[j].autoscale(False)

```

See the profile of the reconstructed maps for each frequency....
See the distance to the edge (freq where was placed the ps - the edge closest to that frequency) vs. intensity 

```{python}
for NUS in ['2','4','6']:#NUS='6'
    #print('NUS = {}'.format(NUS))
    NormFact2=1#48/int(NUS)
    fig,ax=plt.subplots(nrows=1,ncols=2,figsize=(12,4))
    ax=ax.ravel()
    if NUS=='2':
        use = [0,1]
    elif NUS=='4':
        use = [1,2]
    elif NUS=='6':
        use = [2,3]
    #print(NUS)
    for j,ifrec in enumerate(use):
        #print(NUS, ifrec, nusfull[NUS][ifrec])
        yvals=[]
        color2=iter(cm.jet(np.linspace(0,1,10)))
        
        for jk,irec in enumerate(allrecon):
            if len(irec[NUS])==0:
                yvals.append(None)
            else:
                yvals.append(irec[NUS][nreal,ifrec,pixel,0]/1e5*NormFact2)

        ax[j].set_title(r'rec{} - I for px in band {:.0f}-{:.0f}GHz'.format(NUS,
                                                                            nusfulledge[NUS][ifrec],
                                                                           nusfulledge[NUS][ifrec+1]))
        ax[j].set_xlabel(r'$\nu$[GHz]')
        #secax.set_xlabel(r'$d_\nu$[GHz](dist to the $\nu_{c}$ of the band)')
        ax[j].set_ylabel(r'$I_\nu(px)$')
        ax[j].set_xlim(nus_in[innu][0]*0.98,nus_in[innu][-1]*1.02)
        
        xvals=nus_in[innu]-nusfull[NUS][ifrec]
        #secax = ax[j].twiny()
        
        for i in range(len(innu)):
            c2=next(color2)
            if yvals[i] == None:
                pass
            else:
                ax[j].plot(nus_in[innu][i],yvals[i],'o',c=c2,ms=12)
                #secax.plot(xvals[i],yvals[i],'o',c=c2,ms=6)
        xlim=ax[j].get_xlim()
        for iedge in nusfulledge[NUS]:
            if (iedge > np.array(xlim)[0]) and (iedge < np.array(xlim)[1]):
                ax[j].axvline(iedge, color='k', ls='--')
        ax[j].grid()
        ax[j].axvspan(nusfulledge[NUS][ifrec],nusfulledge[NUS][ifrec+1], color='k', alpha=0.20)
        print(NUS, ifrec, nusfull[NUS][ifrec])
        ax[j].axvline(nusfull[NUS][ifrec],ls='-.',c='k')
        
```

```{python}
for NUS in ['1','3']:
    NormFact2=1#48/int(NUS)
    fig,ax=plt.subplots(nrows=1,ncols=1,figsize=(6,4))
    ax=[ax,]
    if NUS=='1':
        use = [0,]
    elif NUS=='3':
        use = [1,]
    for j,ifrec in enumerate(use):
        #print('ifrec, {}'.format(ifrec))
        yvals=[]
        color2=iter(cm.jet(np.linspace(0,1,10)))
        #secax = ax[j].twiny()
        
        for jk,irec in enumerate(allrecon):
            if len(irec[NUS])==0:
                yvals.append(None)
            else:
                yvals.append(irec[NUS][nreal,ifrec,pixel,0]/1e5*NormFact2)
        xvals=nus_in[innu]-nusfull[NUS][ifrec]
        ax[j].set_title(r'Nfrec={} - ps entering to band {:.0f}-{:.0f}GHz'.format(NUS,
                                                                            nusfulledge[NUS][ifrec],
                                                                           nusfulledge[NUS][ifrec+1]))
        ax[j].set_xlabel(r'$\nu$[GHz]')
        #secax.set_xlabel(r'$d_\nu$[GHz][distance to central freq in band]')
        ax[j].set_ylabel(r'$I_\nu$ of central px')
        #ax[j].axvline(nusfulledge[NUS][use[0]+1], color='k', ls='--')

        for i in range(len(innu)):
            c2=next(color2)
            if yvals[i] == None:
                pass
            else:
                ax[j].plot(nus_in[innu][i],yvals[i],'o',c=c2,ms=6)
                #secax.plot(xvals[i],yvals[i],'o',c=c2,ms=6)
        xlim=ax[j].get_xlim()
        for iedge in nusfulledge[NUS]:
            if (iedge > np.array(xlim)[0]) and (iedge < np.array(xlim)[1]):
                ax[j].axvline(iedge, color='k', ls='--')
        #ax[j].axvspan(nusfulledge[NUS][ifrec],nusfulledge[NUS][ifrec+1], color='k', alpha=0.20)
        #print(NUS, ifrec, nusfull[NUS][ifrec])
        ax[j].axvline(nusfull[NUS][ifrec],ls='-.',c='k')
        
        ax[j].grid()
```

Fit gaussian to profiles

```{python}
def fgauss(x,amp,nu0,var0):
    return amp*np.exp(-0.5*(x-nu0)**2/var0**2 )
nunu=nus_in[innu]
fig,ax=plt.subplots(nrows=2,ncols=2,figsize=(16,12))
ax=ax.ravel()
for jj,NUS in enumerate(['2','3','4','6']):
    if NUS=='2':
        usefreq=[0,1]
    elif NUS=='3':
        usefreq=[1,]
    elif NUS=='4':
        usefreq=[1,2]
    elif NUS=='6':
        usefreq=[2,3]
    for inu in usefreq:
        nunu=nus_in[innu]
        psfvals=[]
        idx=[]
        for ii,i in enumerate(allrecon):
            if len(i[NUS])==0:
                psfvals.append(None)
                idx.append(ii)
            else:
                psfvals.append(i[NUS][nreal,inu,pixel,0]/1e5)
        psfvals=np.array(psfvals)
        nunu=np.delete(nunu,idx)
        psfvals=np.delete(psfvals,idx)
        pgauss,vgauss=curve_fit(fgauss, nunu, psfvals,p0=[0.2,nusfull[NUS][inu],8])

        ax[jj].set_title(fr'$N_r$ = {int(NUS)}, $\nu_0$ = {nusfull[NUS][usefreq]} ')
        color2=iter(cm.jet(np.linspace(0,1,10)))
        for j in range(len(nunu)):
            c2=next(color2)
            ax[jj].plot(nunu[j], psfvals[j],'o', color=c2)
        x=np.linspace(nunu[0],nunu[-1],200)
        ax[jj].plot(x, fgauss(x, *pgauss),'g-', 
                    label=r'$\nu = ${:.2f}, $\sigma = ${:.2f}'.format(pgauss[1],pgauss[2]))
        ax[jj].legend(loc='best')
        
        xlim=ax[jj].get_xlim()
        for iedge in nusfulledge[NUS]:
            if (iedge > np.array(xlim)[0]) and (iedge < np.array(xlim)[1]):
                ax[jj].axvline(iedge, color='k', ls='--')
        print(NUS,'fWhm {:.1f}'.format(pgauss[2]*2.35))            
    ax[jj].grid()

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

### Old way... not use


Choose the maps with higher SNR to fit point sources reconstruction

```{python}
d1=d.copy()
d1['nf_sub']=48
d1['nf_recon'] = 4
p = qubic.get_pointing(d1)
s =qubic.QubicScene(d1)
q = qubic.QubicMultibandInstrument(d1)
a = qubic.QubicMultibandAcquisition(q,p,s,d1,nusfulledge['4'])
```

```{python}
map4fit = {}#np.zeros((len(d['nf_recon']),3,12*d['nside']**2))
nus4fit = {}
nusedge4fit = {}
ind=[]
for i,ikey in enumerate(snr.keys()):
    ind.append(np.argmax(snr[ikey]))
    map4fit.update({ikey: mapsrec[ikey][:,ind[-1],:,0] })
    nus4fit.update({ikey: nusfull[ikey][ind[-1]]})
    nusedge4fit.update({ikey: nusfulledge[ikey][ind[-1]]})
print(nus4fit,'\n',nusedge4fit)
```

Look at the amplitude of the point sources for reconstructed maps...

```{python}
nreal=2
fig,ax=plt.subplots(nrows=1,ncols=2, figsize=(14,4))
ax=ax.ravel()
NUSPSF = []
VALPSF=[]
ax[0].set_title('Reconstructed map')
ax[1].set_title('Convolved map')
for i in range(len(ax)):
    ax[i].set_xlabel(r'$\nu[GHz]$')
    ax[i].set_ylabel(r'$A_{\rm A0=1e5}$')
    ax[i].grid()
    ax[i].axvline(nus_in[10], color='k',alpha=0.4,ls='--')
    ax[i].set_xlim(134,166)
    
for j,isub in enumerate(d['nf_recon']):
    idx='{}'.format(isub)
    elrec = Ellipse((nusfull[idx][ind[j]], mapsrec[idx][nreal,:,pixel,0][ind[j]]/1e5), 
                    2, 0.01, color='b', fill=False)
    NUSPSF.append(nusfull[idx][:])
    VALPSF.append(mapsrec[idx][nreal,:,pixel,0]/1e5)
    ax[0].plot(nusfull[idx][:], mapsrec[idx][nreal,:,pixel,0]/1e5, 'o', label='{:d}'.format(isub))
    ax[0].add_artist(elrec)
    elconv = Ellipse((nusfull[idx][ind[j]], mapsconv[idx][nreal,:,pixel,0][ind[j]]/1e5), 
                    2, 0.01, color='b', fill=False)
    ax[1].plot(nusfull[idx][:], mapsconv[idx][nreal,:,pixel,0]/1e5, 'o', label='{:d}'.format(isub))
    ax[1].add_artist(elconv)
ax[0].legend(loc='best')
```

```{python}
nuspsf = []
valpsf = []
for i in range(len(NUSPSF)):
    nuspsf.extend(NUSPSF[i][:])
    valpsf.extend(VALPSF[i][:])
nuspsf=np.array(nuspsf)
valpsf=np.array(valpsf)
iindice=nuspsf.argsort()
nuspsf = nuspsf[iindice]
valpsf = valpsf[iindice]
jd=np.where(nuspsf==150.0)

def fgauss(x,amp,nu0,var0):
    return amp*np.exp(-0.5*(x-nu0)**2/var0**2 )

pgauss,vgauss=curve_fit(fgauss, np.delete(nuspsf, jd), np.delete(valpsf, jd),p0=[0.2,150,10])
#pgauss,vgauss=curve_fit(fgauss, nuspsf, valpsf,p0=[0.2,150,10])
print(vgauss[-1,-1])
plt.title(r'$N_s$ = {}, $\nu_0$ = {:d}'.format(d['nf_sub'],int(nus_in[10])))
plt.plot(nuspsf, valpsf,'ko')
plt.plot(nuspsf[jd], valpsf[jd],'rx',ms=12)
x=np.linspace(nuspsf[0],nuspsf[-1],200)
plt.plot(x, fgauss(x, *pgauss),'g-', label=r'$\nu = ${:.2f}, $\sigma = ${:.2f}'.format(pgauss[1],pgauss[2]))
plt.legend()
plt.grid()
print('fWhm {:.1f}'.format(pgauss[2]*sigma2fwhm))
```

```{python}

```

### Fit angular resolution


Make the fit calibration

```{python}
nuscal = np.linspace(128,172,20)
fwhmcal = CteConf/nuscal
sample = 20
amplitude = 1e5 #initial amplitude

vec_pix = hp.pix2vec(nside, pixel)
vec_pixeles = hp.pix2vec(nside, np.arange(12*nside**2))
ang_pixeles = np.arccos(np.dot(vec_pix,vec_pixeles))
angmask = 10
mask = np.rad2deg(ang_pixeles) < angmask

x_map = np.linspace(-size/2,size/2,size)*reso/60
y_map = x_map
x_map, y_map = np.meshgrid(x_map, y_map)

x0data_map = x_map.ravel()
x1data_map = y_map.ravel()

"""
ellip:  (NOT IMPLEMENTED)ellipticity of the fitted gaussian. 
        Following BICEP2/keck definition (arXiv:0906.4069)
       e = (sigma_a - sigma_b) / (sigma_a + sigma_b)
"""

deltaFwhm_cal = np.zeros( (len(fwhmcal), 1) )
#position_center_fit = np.zeros((n_subpop,1))
```

```{python}
f0 = np.zeros((sample, 12*nside**2,))
f0[:,pixel] = 1
f0 = [hp.smoothing(f0[i], fwhm = np.radians(fwhmcal[i]), verbose=False) for i in range(len(f0))]

#Mannually guassian
#for i,each in enumerate(ang_pixeles):
#    if mask[i] == True:
#        for jfreq in range(sample):
#            f0[jfreq,i] = f(each, fwhm = fwhm[jfreq]) 

```

```{python}
# Fit Method
fwhmmeasured = np.empty((sample,))
diffwhm = np.zeros_like(fwhmmeasured)
maparray=np.zeros((sample, size,size))

for i,mi in enumerate(f0):
    maparray[i] = hp.gnomview(mi, rot=center, reso=reso, xsize=size, 
                              return_projected_map=True, no_plot=True)
    norm_fit = normalization(x_map[0],maparray[i])
    ydata_map = (norm_fit * maparray[i]).ravel()
    
    popt_map, pcov_map = curve_fit(gaussian2d, np.array([x0data_map,x1data_map]), ydata_map, method='trf')
    fwhmmeasured[i] = (abs(popt_map[3])+abs(popt_map[4]))/2*sigma2fwhm
    diffwhm[i] = (fwhmmeasured-fwhmcal)[i]
#Save interpolation 
FuncInt = interp1d(nuscal, diffwhm)
```

```{python}
#for i in range(len(fwhm)):
#    print('{:.2f} \t {:.2f} \n'.format(input_fwhm_fit[i], fwhm[i] ))
plt.figure(figsize=(8,6))
plt.ylim(0.35,0.63)
plt.plot(nuscal, fwhmcal, 'ko', label='real')
plt.plot(nuscal, fwhmmeasured, 'rs', label='measured')
plt.vlines(x=nuscal,ymin=fwhmcal, ymax=fwhmmeasured, colors='r', alpha= 0.2, ls='--' )
plt.grid()
#plt.text(132,0.58,r'$\Delta$FWHM', fontsize=16)
plt.xlabel(r'$\nu$[GHz]', fontsize=15)
plt.ylabel(r'FWHM[deg]', fontsize=15)
plt.legend(loc='best', fontsize=14)
```

# Calibration DONE.- 

Start fitting maps...

```{python}
fwhm_maps = {}
ellp_maps = {}
#diffwhm2=np.zeros((nsub,))
mpy=np.zeros((len(d['nf_recon']),3,size,size))
for i,ikey in enumerate(map4fit.keys()):
    for ireal in range(3):
        mpy[i,ireal] = hp.gnomview(map4fit[ikey][ireal], rot=center, reso=reso, xsize=size, 
                                  return_projected_map=True, no_plot=True)
        plt.clf()
        norm_fit = normalization(x_map[0],mpy[i,ireal])
        ydata_map = (norm_fit * mpy[i,ireal]).ravel()

        popt_map, pcov_map = curve_fit(gaussian2d, np.array([x0data_map,x1data_map]), 
                                       ydata_map, method='trf')
        ellp_maps.update({ikey:popt_map[3]/popt_map[4]})
        fwhm_maps.update({ikey:(abs(popt_map[3])+abs(popt_map[4]))/2*sigma2fwhm})
        #diffwhm2[i] = (input_fwhm_fit2-fwhm2)[i]

#npsf.plotting(dirc = 'nersc', simu = ['32091820'], 
#               date = '20200620', reso = 2, savefig=False, 
#               filename='../psf_20-25nus-smFOV-Fix', setlim=False)
```

```{python}
print('== Covariance matrix ==')
[print(pcov_map[i]) for i in range(len(pcov_map))]
print('== Ellipticity ==')
print(ellp_maps)
print('== FWHM(nu) / hp.resolution ==')
print(np.array(list(fwhm_maps.values()))*60/hp.nside2resol(d['nside'],arcmin=True))
```

concon=gaussian2d(np.array([x_map.ravel(),y_map.ravel()]),
                  *popt_map  ).reshape((200,200))
plt.xlabel(r'x')
plt.xlabel(r'y')
plt.contourf(concon, extent=[x_map.min(),x_map.max(),y_map.min(),y_map.max()] )  


Plot resulting measure vs real values. (compare against freq edges too)...

```{python}
#nreals, nrec,4
#allfwhm=[]
FWHMs = {}#np.zeros((4,6,4))
difff = []
for j,ikey in enumerate(nus4fit.keys()):
    if j==0: labelm = 'measured'; labelr='real'; labelu='unbised';labele='edge freq(shifted)'
    else: labelm=None; labelr=None; labelu=None; labele=None
    plt.title(r'N_s = {}'.format(d['nf_sub']))
    plt.plot(nus4fit[ikey],fwhm_maps[ikey], 'rs',label=labelm)
    plt.plot(nus4fit[ikey],CteConf/nus4fit[ikey],'ks',label=labelr)
    plt.plot(nus4fit[ikey],fwhm_maps[ikey]-FuncInt(nus4fit[ikey]), 'gs', label=labelu)
    plt.plot(nus4fit[ikey],CteConf/nusedge4fit[ikey],'bo', label=labele)
    FWHMs.update({ikey:[CteConf/nus4fit[ikey],
                                      fwhm_maps[ikey]-FuncInt(nus4fit[ikey]),
   http://localhost:8888/notebooks/output_paper/psf_analysis.Rmd#                                   fwhm_maps[ikey]-FuncInt(nus4fit[ikey]) - CteConf/nus4fit[ikey]]}) 
    plt.legend(loc='best')
    difff.append(fwhm_maps[ikey]-FuncInt(nus4fit[ikey]) - CteConf/nus4fit[ikey])
plt.grid()
print('diff = real - unbiased {}'.format(difff))
```

The green dots, at which frequency corresponds? Is it to the worst resolution within the band where it belongs?...


```{python}
for each in f12.keys():
    print(each, np.array(f12[each])*60)
#f12
#f20
#f25
```

```{python}

```

```{python}
c1,c2,c3,c4,c5,c6 = [],[],[],[],[],[]
print('nu \t real \t unbiased \t unbised-real')
for each in [f12,f15,f20,f25]:
    
```

```{python}
#search the border of the band
print(ind)
bind=[]#np.zeros((len(ind)))
for ikey in nus4fit.keys():
    bind.append = nusfulledge[ikey][i]
        print('{} \t {} \n'.format(bind[j], ind[j]))

```

```{python}
optcf,covcf=anpsf.fitGauss_one(dirc = 'nersc', simu =['31901895','31901911', '31982984','31983445'],
                   plotraw=False, plotfit=True)
```

```{python}
reload(anpsf)
bestvals=anpsf.lmfitGauss(dirc = 'nersc', simu =['31901895','31901911', '31982984','31983445'],
                          doplot=True) #'31901895', 
```

```{python}
bestvals
```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}
jobids = ['32139830', '32140318','32139772', '32140658'] #[12,15,20,25]
jobids2= ['32574170', '32574156'] #[48,48]|[1,2,3,4,6]
indxjob=0
jobid = jobids2[indxjob]
repo = os.environ['QUBIC_DATADIR']+'scripts/Spectroimagery_paper/output_paper/nersc/{}/'.format(jobid)
repodict = glob.glob(repo+'*.dict')[0]

d = qubic.qubicdict.qubicDict()
d.read_from_file(repodict)
center = qubic.equ2gal(d['RA_center'], d['DEC_center'])
d['nf_sub']=48
d['nf_recon'] = [1,2,3,4,6] 
nsub = d['nf_recon'][-1]

_,_,nus_in,_,_,_=qubic.compute_freq(150,d['nf_sub'],0.25)
sigma2fwhm = np.sqrt(8*np.log(2))
# constant angular resolution using P = 19 and deltaX = 1.4cm
CteConf = 61.57622 #2.998e10/20/1.4/1e9/np.pi*180
size=200
reso = 3
nside=d['nside']

#Look at the maps...ok...

if nsub not in d['nf_recon']: raise ValueError('Invalid number of sub-bands for {} nus_in'.format(d['nf_sub']))
_,_,nus_rec,_,_,_=qubic.compute_freq(150,nsub,0.25)
print("Working with nf_sub = {} and nfrec = {}".format(d['nf_sub'], d['nf_recon']))
mapsrec={}
mapsconv={}
nusfull = {}
nusfulledge = {}
for isub in d['nf_recon']:
    _, maprec, mapconv, mapdif = get_maps_many_files(repo,'*recon{}*.fits'.format(isub))
    _,inusedge,inus,_,_,_=qubic.compute_freq(150,isub,0.25)
    mapsrec.update({'{}'.format(isub): maprec})
    mapsconv.update({'{}'.format(isub): mapconv})
    nusfull.update({'{}'.format(isub):inus})    
    nusfulledge.update({'{}'.format(isub):inusedge})    
#print(np.shape(maprec))

mapsrec,mapsconv,nusfull,nusfulledge = read_run(jobid)
plt.figure(figsize=(8,6))
nreal=0
for i in range(nsub):
    hp.gnomview(mapsrec['4'][0,i,:,0], rot=center, reso=reso, 
                title = 'Rec. {:d}GHz'.format(int(nus_rec[i])), sub=(2,nsub,i+1), 
                min=-0.04,max=1e5)
    hp.gnomview(mapsconv['4'][0,i,:,0], rot=center, reso=reso,
                title = 'Conv. {:d}GHz'.format(int(nus_rec[i])), sub=(2,nsub,i+nsub+1), 
                min=-0.04,max=1e5)

```

```{python}

```
