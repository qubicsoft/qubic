---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
import glob
import os
import healpy as hp
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rc

import ReadMC as rmc
import AnalysisMC as amc

import qubic
from qubic import equ2gal

from qubicpack.utilities import Qubic_DataDir

# %matplotlib inline
rc({'cmap', 'viridis'})

```

# Get the simulation files

```{python}
# Simulation date and name
date_name = '20190815_QU10'

# Get the repository where the simulation is
rep_simu = Qubic_DataDir(datafile=date_name + '.dict') + '/'
print(rep_simu)

# Dictionary saved during the simulation
d = qubic.qubicdict.qubicDict()
d.read_from_file(rep_simu + date_name + '.dict')
```

### Number of subbands used during the simulation


## Get full maps

```{python}
# Remember: get_patch_many_file do seen_map + read each map
nfrec=5
files, maps_recon, maps_conv, maps_diff = \
rmc.get_maps_many_files(rep_simu+ date_name, '*nfrecon{}*False*'.format(nfrec))

nreals=len(files)
```

```{python}
print(maps_recon.shape)
```

## Get patchs

```{python}
_, maps_recon_patch, maps_conv_patch, maps_diff_patch = \
rmc.get_patch_many_files(rep_simu+date_name, '*nfrecon{}*False*'.format(nfrec))

```

```{python}
maps_recon_patch.shape
```

### Look at the noise maps

```{python}
npix_patch = maps_recon_patch.shape[2]
print(npix_patch, nreals, nfrec)
```

### Compute the covariance matrix

```{python}
covariance, _ = amc.get_covcorr_patch(maps_recon_patch, stokesjoint=True)
```

```{python}
covariance.shape
```

### Cut the cov matrix for each Stokes parameter

```{python}
Icov = covariance[0:nfrec, 0:nfrec, :]
Qcov = covariance[nfrec:2*nfrec, nfrec:2*nfrec, :]
Ucov = covariance[2*nfrec:3*nfrec, 2*nfrec:3*nfrec, :]
Icov.shape
```

```{python}
maps_recon_patch.shape
```

```{python}
if nfrec!=1:
    #generate arrays of stokes parameters to save weight average over sub-bands
    Ipr = np.zeros((npix_patch,nreals))
    Qpr = np.zeros((npix_patch,nreals))
    Upr = np.zeros((npix_patch,nreals))
    #generate arrays of sigma2 for each pixel but equal for each realization
    sig2Ipr = np.zeros((npix_patch,))
    sig2Qpr = np.zeros((npix_patch,))
    sig2Upr = np.zeros((npix_patch,))

    for ireal in range(nreals):
        for ipix in range(npix_patch):
            xI = np.array(maps_recon_patch[ireal, :, ipix, 0])
            xQ = np.array(maps_recon_patch[ireal, :, ipix, 1])
            xU = np.array(maps_recon_patch[ireal, :, ipix, 2])
    #         if ipix==0: print(xI)
            Ipr[ipix,ireal], sig2Ipr[ipix] = amc.get_weighted_correlation_average(xI, Icov[:, :, ipix])
            Qpr[ipix,ireal], sig2Qpr[ipix] = amc.get_weighted_correlation_average(xQ, Qcov[:, :, ipix])        
            Upr[ipix,ireal], sig2Upr[ipix] = amc.get_weighted_correlation_average(xU, Ucov[:, :, ipix]) 
```

### Average over pix and realizations

```{python}
if nfrec!=1:
    Iav = np.mean(Ipr)
    Qav = np.mean(Qpr)
    Uav = np.mean(Upr)
else:
    Iav = np.mean(maps_recon_patch[:,:,:,0])
    Qav = np.mean(maps_recon_patch[:,:,:,1])
    Uav = np.mean(maps_recon_patch[:,:,:,2])
    
Iav
```

```{python}
if nfrec!=1:
    Isig = 1. / (np.sqrt(nreals) * npix_patch) * np.sqrt(np.sum(sig2Ipr)) 
    Qsig = 1. / (np.sqrt(nreals) * npix_patch) * np.sqrt(np.sum(sig2Qpr))
    Usig = 1. / (np.sqrt(nreals) * npix_patch) * np.sqrt(np.sum(sig2Upr))
else:
    Isig = 1./(np.sqrt(npix_patch * nreals) * np.std(maps_recon_patch[:,:,:,0]))
    Qsig = 1./(np.sqrt(npix_patch * nreals) * np.std(maps_recon_patch[:,:,:,1]))
    Usig = 1./(np.sqrt(npix_patch * nreals) * np.std(maps_recon_patch[:,:,:,2]))
print(Isig, Qsig, Usig)
```

```{python}
if nfrec==1:
    Isig1, Qsig1, Usig1 = Isig, Qsig, Usig
if nfrec==3:
    Isig3, Qsig3, Usig3 = Isig, Qsig, Usig
if nfrec==5:
    Isig5, Qsig5, Usig5 = Isig, Qsig, Usig

print(Isig3, Qsig3, Usig3)
print(Isig5, Qsig5, Usig5)
```

```{python}
# # Average betwen pixels
# Ir = np.zeros((nreals,))
# Qr = np.zeros((nreals,))
# Ur = np.zeros((nreals,))

# for ireal in range(nreals):
#     Ir[ireal] = np.mean(Ipr[:,ireal])
#     sigIr = np.sqrt(np.sum(sig2Ipr))/npix_patch
    
#     Qr[ireal] = np.mean(Qpr[:,ireal])
#     sigQr = np.sqrt(np.sum(sig2Qpr))/npix_patch

#     Ur[ireal] = np.mean(Upr[:,ireal])
#     sigUr = np.sqrt(np.sum(sig2Upr))/npix_patch
```

```{python}
# #average over realizations
# Iend, Qend, Uend = np.mean(Ir), np.mean(Qr), np.mean(Ur)
# sigI, sigQ, sigU = sigIr/np.sqrt(nreals), sigQr/np.sqrt(nreals), sigUr/np.sqrt(nreals)
```

```{python}
arrx = np.array(['1 sb','3 sb','5 sb'])

arrI = np.array([Isig1,Isig3,Isig5])
arrQ = np.array([Qsig1,Qsig3,Qsig5])
arrU = np.array([Usig1,Usig3,Usig5])

plt.figure(figsize=(12,4))

plt.subplot(131)
plt.ylabel(r'\sigma')
plt.title('I Variance')
plt.plot(arrx,arrI, 'ro')
plt.xlabel('Subbands')
plt.subplot(132)
plt.title('Q Variance')
plt.plot(arrx,arrQ, 'bo')
plt.xlabel('Subbands')
plt.subplot(133)
plt.title('U Variance')
plt.plot(arrx,arrU, 'go')
plt.xlabel('Subbands')


```

```{python}

print(arrI,arrQ,arrU)
```

```{python}

```
