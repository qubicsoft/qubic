---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
import glob
import os
import healpy as hp
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rc

import ReadMC as rmc
import AnalysisMC as amc

import qubic
from qubic import equ2gal

from qubicpack.utilities import Qubic_DataDir

# %matplotlib inline
rc({'cmap', 'viridis'})
plt.rcParams['figure.figsize'] = (8, 8)

```

# Get the simulation files

```{python}
# Simulation date and name
date_name = '20190815_QU10'
# date_name = 'TEST/runs/20190816/20190816_low_nep'

# Get the repository where the simulation is
rep_simu = Qubic_DataDir(datafile=date_name + '.dict') + '/'
print('rep_simu : ', rep_simu)

# Dictionary saved during the simulation
d = qubic.qubicdict.qubicDict()
d.read_from_file(rep_simu + date_name + '.dict')
```

### Number of subbands used during the simulation

```{python}
nf_recon = d['nf_recon']
print('nf_recon', nf_recon)

# This array will contain the sigma2 average over pixels
sigma2mean = np.empty((len(nf_recon), 3))
sigma2mean_bis = np.empty((len(nf_recon), 3))
```

## Choose a number of reconstructed subbands

```{python}
nfrec = 5
index_frec = nf_recon.index(nfrec)
print('index_frec = ', index_frec)
```

## Get full maps

```{python}
# Remember: get_patch_many_file do seen_map + read each map
files, maps_recon, maps_conv, maps_diff = \
rmc.get_maps_many_files(rep_simu+ date_name, '*nfrecon{}*False*'.format(nfrec))

nreals=len(files)
```

```{python}
print(maps_recon.shape)
```

## Get patchs

```{python}
_, maps_recon_patch, maps_conv_patch, maps_diff_patch = \
rmc.get_patch_many_files(rep_simu+date_name, '*nfrecon{}*False*'.format(nfrec))

print(maps_recon_patch.shape)

npix_patch = maps_recon_patch.shape[2]
print('npix_patch = ', npix_patch)
```

## Without spectroim case

```{python}
if nfrec==1:
    maps_recon_patch = np.reshape(maps_recon_patch, (nreals, npix_patch, 3))
    print(maps_recon_patch.shape)
    
    # Variance over real
    sig2MC_1band = np.var(maps_recon_patch, axis=0)
    print(sig2MC_1band.shape)
    
    # Average the variance over pixels
    for istokes in range(3):
        sigma2mean[index_frec, istokes] = np.sqrt(np.sum(sig2MC_1band[:, istokes])) / npix_patch     
    print(sigma2mean)
    sigma2mean_bis[index_frec, :] = sigma2mean[index_frec, :]
    
    # Covariance matrix npix x npix
    cov_pix_1band = np.empty((npix_patch, npix_patch, 3))
    for istokes in range(3):
        cov_pix_1band[:, :, istokes] = np.cov(maps_recon_patch[:, :, istokes], rowvar=False)
        plt.subplot(1, 3, istokes+1)
        plt.imshow(cov_pix_1band[:, :, istokes])
```

## Compute the covariance matrix $C_p$

```{python}
# The full one
covariance, _ = amc.get_covcorr_patch(maps_recon_patch, stokesjoint=True)

print(covariance.shape)

# Cut the covariance matrix for each Stokes parameter
Cp = np.empty((nfrec, nfrec, 3, npix_patch))
for istokes in range(3):
    Cp[:, :, istokes, :] = covariance[istokes*nfrec:(istokes+1)*nfrec, istokes*nfrec:(istokes+1)*nfrec, :]
print(Cp.shape)
```

### Average $C_p$ over pixels to get $C^{'}_p$

```{python}
# Normalize each matrix by the first element
Np = np.empty_like(Cp)
Cp00 = np.empty((3, npix_patch))
for istokes in range(3):
    for ipix in range(npix_patch):
        Cp00[istokes, ipix] = Cp[0, 0, istokes, ipix]
        Np[:, :, istokes, ipix] = Cp[:, :, istokes, ipix] / Cp00[istokes, ipix]

# We can now average the matrices over the pixels
N = np.mean(Np, axis=3)  
print(N.shape)

# We re-multiply N by the first term
Cp_bis = np.empty_like(Cp)
for istokes in range(3):
    for ipix in range(npix_patch):
        Cp_bis[:, :, istokes, ipix] = Cp00[istokes, ipix] * N[:, :, istokes]
print(Cp_bis.shape)

```

## Weighted average over subbands


```{python}
# Set this True if you want to use Cp average over pixels in the weighted average
Cp_2_Cpbis = True
```

### Using $C_p$

```{python}
pr = np.empty((nreals, npix_patch, 3))
sig2pr = np.empty((npix_patch, 3))

for ireal in range(nreals):
    for ipix in range(npix_patch):
        for istokes in range(3):
            x = maps_recon_patch[ireal, :, ipix, istokes]
            pr[ireal, ipix, istokes], sig2pr[ipix, istokes] = amc.get_weighted_correlation_average(x, Cp[:, :, istokes, ipix])

print(pr.shape)

sig2MC = np.var(pr, axis=0)
sig2MC.shape

cov_pix = np.empty((npix_patch, npix_patch, 3))
for istokes in range(3):
    sigma2mean[index_frec, istokes] = np.sqrt(np.sum(sig2MC[:, istokes])) / npix_patch

    cov_pix[:, :, istokes] = np.cov(pr[:, :, istokes], rowvar=False)
    plt.subplot(1, 3, istokes+1)
    plt.imshow(cov_pix[:, :, istokes])
#     plt.colorbar()
```

### Using $C^{'}_p$

```{python}
pr_bis = np.empty((nreals, npix_patch, 3))
sig2pr_bis = np.empty((npix_patch, 3))

for ireal in range(nreals):
    for ipix in range(npix_patch):
        for istokes in range(3):
            x = maps_recon_patch[ireal, :, ipix, istokes]
            pr_bis[ireal, ipix, istokes], sig2pr_bis[ipix, istokes] = amc.get_weighted_correlation_average(x, Cp_bis[:, :, istokes, ipix])

print(pr_bis.shape)

sig2MC_bis = np.var(pr_bis, axis=0)
sig2MC_bis.shape

cov_pix_bis = np.empty((npix_patch, npix_patch, 3))
for istokes in range(3):
    sigma2mean_bis[index_frec, istokes] = np.sqrt(np.sum(sig2MC_bis[:, istokes])) / npix_patch

    cov_pix_bis[:, :, istokes] = np.cov(pr_bis[:, :, istokes], rowvar=False)
    plt.subplot(1, 3, istokes+1)
    plt.imshow(cov_pix_bis[:, :, istokes])
#     plt.colorbar()
```

## Plots

```{python}
print(sigma2mean)
print(sigma2mean_bis)
```

```{python}
arrx = np.array(['1 sb','3 sb','5 sb'])
stokes = ['I', 'Q', 'U']
for istokes in range(3):
    plt.subplot(1, 3, istokes+1)
    plt.subplots_adjust(right=2)
    plt.title(stokes[istokes] + ' using Cp av over pix')
    plt.xlabel('nf_recon')
    plt.ylabel('$\sigma^2$ average over pix')
    plt.plot(arrx, sigma2mean[:, istokes], label='using Cp')
    plt.plot(arrx, sigma2mean_bis[:, istokes], label='using Cp av over pix')
    plt.legend(loc='best')
```

```{python}

```
