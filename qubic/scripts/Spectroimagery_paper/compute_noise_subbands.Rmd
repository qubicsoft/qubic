---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
from __future__ import division, print_function
import glob
import os
import healpy as hp
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rc
from scipy import interpolate

import ReadMC as rmc
import AnalysisMC as amc

import qubic
from qubic import equ2gal

from qubicpack.utilities import Qubic_DataDir

# %matplotlib inline
rc({'cmap', 'viridis'})
plt.rcParams['figure.figsize'] = (8, 8)

```

# Functions

should go in AnalysisMC once it is working

```{python}
def get_Cp(patch, nfrecon, verbose=True, doplot=True):
    
    irec = np.shape(patch)[1]
    npix_patch = np.shape(patch)[2]
    if irec == 1:
        raise ValueError('If you already have 1 band, you do not need Cp which is computed to average subbands')
        
    if irec not in nfrecon:
        raise ValueError('Invalid number of freq. {0} not in {1}'.format(irec, nfrecon))
    
    # Prepare to save
    index_frec = nfrecon.index(irec)
    if verbose: 
        print('==== Computing Cp matrix ====')
        print('irec = ', irec)
        print('nfrecon = ', nfrecon)
        print('index_frec = ', index_frec)
        print('patch.shape = ', patch.shape)
        print('npix_patch = ', npix_patch)
        
    ### The full one
    covariance, _ = amc.get_covcorr_patch(patch, stokesjoint=True, doplot=doplot)

    if verbose: print('covariance.shape =', covariance.shape)

    # Cut the covariance matrix for each Stokes parameter
    Cp = np.empty((irec, irec, 3, npix_patch))
    for istokes in range(3):
        Cp[:, :, istokes, :] = covariance[istokes*irec:(istokes+1)*irec, istokes*irec:(istokes+1)*irec, :]
    if verbose: print('Cp.shape = ', Cp.shape)

    # Look at the value in Cp and the determinant
    for ipix in range(10):
        for istokes in range(3):
            det = np.linalg.det(Cp[:, :, istokes, ipix])
            print('det = ', det)

    if verbose: print('==== Done. Cp matrix computed ====')
    
    return Cp

def make_weighted_av(patch, Cp, ang, ang_threshold, verbose=False, doplot=False):
   
    nreals = np.shape(patch)[0]
    npix_patch = np.shape(Cp)[-1]
    if verbose:
        print('Cp.shape =', Cp.shape)
        print('# realizations =', nreals)
        print('npix_patch =', npix_patch)
    
    weighted_av = np.empty((nreals, npix_patch, 3))
    sig2 = np.empty((npix_patch, 3))
    
    nsing = 0
    for ireal in range(nreals):
        for ipix in range(npix_patch):
            for istokes in range(3):
                x = patch[ireal, :, ipix, istokes]
                # Only do it if the matrix is not singular...
                if np.linalg.det(Cp[:, :, istokes, ipix])!=0.:
                    weighted_av[ireal, ipix, istokes], sig2[ipix, istokes] = \
                    amc.get_weighted_correlation_average(x, Cp[:, :, istokes, ipix])
                else:
                    nsing += 1
    if verbose:
        print('# singular matrices:', nsing)
        print('Weigthed mean matrix per pixel, shape:', weighted_av.shape)
        print('Variance in MC simulation, shape: ', sig2.shape)

    
    # Average sig2 over pixels 
    sigmean = average_pix_sig2(sig2, ang, ang_threshold)
                    
    return weighted_av, sig2, sigmean


def average_pix_sig2(sig2, ang, ang_threshold):
    sigmean = np.empty((3,))
    npix = np.shape(ang[ang < ang_threshold])
    print('npix =', npix)
    for istokes in range(3):
        sigmean[istokes] = np.sqrt(np.sum(sig2[:, istokes][ang < ang_threshold]) / npix)
    return sigmean


def get_sig2MC(map_monoband, ang, ang_threshold):
    # Compute a new sigma by Monte-Carlo over realizations
    sig2MC = np.var(map_monoband, axis=0)

    # Average sig2MC over pixels
    sigMCmean = average_pix_sig2(sig2MC, ang, ang_threshold)
    
    return sig2MC, sigMCmean

def Cp2Cp_prime(Cp, verbose=True):
    
    npix_patch = np.shape(Cp)[-1]
    if verbose: print('npix_patch =', npix_patch)
    
    # Normalize each matrix by the first element
    Np = np.empty_like(Cp)
    Cp00 = np.empty((3, npix_patch))
    for istokes in range(3):
        for ipix in range(npix_patch):
            Cp00[istokes, ipix] = Cp[0, 0, istokes, ipix]
            Np[:, :, istokes, ipix] = Cp[:, :, istokes, ipix] / Cp00[istokes, ipix]
    
    # We can now average the matrices over the pixels
    N = np.mean(Np, axis=3)  
    
    if verbose: print('N shape:', N.shape)

    # We re-multiply N by the first term
    Cp_prime = np.empty_like(Cp)
    for istokes in range(3):
        for ipix in range(npix_patch):
            Cp_prime[:, :, istokes, ipix] = Cp00[istokes, ipix] * N[:, :, istokes]
            
    if verbose: print('Cp_prime.shape =', Cp_prime.shape)
    
    return Cp_prime
```

***
# Get the simulation files

```{python}
# Simulation date and name
date_name = '20190926_low_nep'
# date_name = 'NERSC_runs/24334789/20190903_low_nep'

# Get the repository where the simulation is
rep_simu = Qubic_DataDir(datafile=date_name + '.dict') + '/'
print('rep_simu : ', rep_simu)

# Dictionary saved during the simulation
d = qubic.qubicdict.qubicDict()
d.read_from_file(rep_simu + date_name + '.dict')

files = glob.glob(rep_simu + '*')

print(d['detector_nep'])
```

```{python}
# Coordinates of the zone observed in the sky
center = equ2gal(d['RA_center'], d['DEC_center'])

seenmap = rmc.get_seenmap(files[0])

# Angle for each pixel in the patch
ang = rmc.pix2ang(d['nside'], center, seenmap)
ang
```

## Get full maps or patchs

```{python}
irec = 2

files, maps_recon, maps_conv, maps_diff = \
rmc.get_maps_many_files(rep_simu + date_name, '*nfrecon{}*False*'.format(irec))

nreals=len(files)

print(maps_recon.shape)
```

```{python}
_, maps_recon_patch, maps_conv_patch, maps_diff_patch = \
rmc.get_patch_many_files(rep_simu + date_name, '*nfrecon{}*False*'.format(irec))

npix_patch = maps_recon_patch.shape[2]
print('npix_patch = ', npix_patch)
```

***
# Test the functions

***
### Check if works get_Cp
looks like yes ;) ...

```{python}
Cp = get_Cp(maps_recon_patch, nfrecon=d['nf_recon'])
```

***
### Test if Cp2Cp_prime works
looooook like that works fine

```{python}
Cp_prime = Cp2Cp_prime(Cp, verbose=True)
```

***
### Check if make_weighted_av works
looks like yes....

```{python}
# Using Cp
weighted_av, sig2, sigmean = make_weighted_av(maps_recon_patch, Cp, ang, ang_threshold=d['dtheta'], 
                                               verbose=True, doplot=True)
print(sig2, sigmean)

# Using Cp_prime
weighted_av_prime, sig2_prime, sigmean_prime = make_weighted_av(maps_recon_patch, Cp_prime, 
                                                                 ang, ang_threshold=d['dtheta'],
                                                                 verbose=True, doplot=True)
print(sig2_prime, sigmean_prime)
```

***
### Check if get_sig2MC works
looks like yes....

```{python}
# Using a map that has been averaged over subbands
sig2MC, sigMCmean = get_sig2MC(weighted_av_prime, ang, ang_threshold=d['dtheta'])
print(weighted_av.shape)

# Using a map with only one subband
_, patch_recon_monofreq, _, _ = \
rmc.get_patch_many_files(rep_simu + date_name, '*nfrecon1*False*')
print(patch_recon_monofreq.shape)
# Remove the single dimension  
patch_recon_monofreq = np.squeeze(patch_recon_monofreq)
print(patch_recon_monofreq.shape)

sig2MC_monofreq, sigMCmean_monofreq = get_sig2MC(patch_recon_monofreq, ang, ang_threshold=d['dtheta'])
sigMCmean_monofreq
```

# Compute all sigma

```{python}
print(d['dtheta'])
```

```{python}
# Make a loop over irec and fill dictionnaries
dict_sig2MC = {}
dict_sig2MC_prime = {}
dict_sig2 = {}
dict_sig2_prime = {}
d['dtheta'] = 10

for irec in d['nf_recon']:
    print('irec =', irec)   
    _, recon_patch, _, _ = rmc.get_patch_many_files(rep_simu + date_name, '*nfrecon{}*False*'.format(irec))
    
    if irec == 1:
        # Remove the single dimension  
        recon_patch = np.squeeze(recon_patch)
        print(recon_patch.shape)

        sig2MC_monofreq, sigMCmean_monofreq = get_sig2MC(recon_patch, ang, ang_threshold=d['dtheta'])
        dict_sig2MC.update({'{}'.format(irec): sig2MC_monofreq})
        dict_sig2MC.update({'{}mean'.format(irec): sigMCmean_monofreq})
       
    else:
        Cp = get_Cp(recon_patch, nfrecon=d['nf_recon'])
        Cp_prime = Cp2Cp_prime(Cp, verbose=True)
        
        # Compute sig2 and sig2MC 
        # Using Cp
        weighted_av, sig2, sigmean = make_weighted_av(recon_patch, Cp, ang, ang_threshold=d['dtheta'],
                                                       verbose=True, doplot=True)
        dict_sig2.update({'{}'.format(irec): sig2})
        dict_sig2.update({'{}mean'.format(irec): sigmean})
        
        sig2MC, sigMCmean = get_sig2MC(weighted_av, ang, ang_threshold=d['dtheta'])
        dict_sig2MC.update({'{}'.format(irec): sig2MC})
        dict_sig2MC.update({'{}mean'.format(irec): sigMCmean})

        # Using Cp_prime
        weighted_av_prime, sig2_prime, sigmean_prime = make_weighted_av(recon_patch, Cp_prime, 
                                                                         ang, ang_threshold=d['dtheta'],
                                                                         verbose=True, doplot=True)
        dict_sig2_prime.update({'{}'.format(irec): sig2_prime})
        dict_sig2_prime.update({'{}mean'.format(irec): sigmean_prime})
        
        sig2MC_prime, sigMCmean_prime = get_sig2MC(weighted_av_prime, ang, ang_threshold=d['dtheta'])
        dict_sig2MC_prime.update({'{}'.format(irec): sig2MC_prime})
        dict_sig2MC_prime.update({'{}mean'.format(irec): sigMCmean_prime})

```

```{python}
dict_sig2
```

***
# Plots

```{python}
Stokes = ['I', 'Q', 'U']
nbins = 6

def make_fit(x, y, nbins):
    bin_edges = np.linspace(0, np.max(x), nbins + 1)
    bin_centers = 0.5 * (bin_edges[0:nbins] + bin_edges[1:])

    mean_bin = np.zeros(nbins)
    for b in range(nbins):
        ok = (x > bin_edges[b]) & (x < bin_edges[b + 1])
        mean_bin[b] = np.mean(y[ok], axis=0)
    fit = interpolate.interp1d(bin_centers, mean_bin, axis=0, kind='linear', fill_value='extrapolate')
    return bin_centers, mean_bin, fit

def plot_sigma2profile(ang, thedict, nbins, nf_recon):
    for irec in nf_recon:
        for s in range(3):

            # Interpolation to get a profile
            bin_centers, mean_bin, fit = make_fit(ang, thedict['{}'.format(irec)][:, s], nbins)

            plt.subplot(1, 3, s+1)
            plt.subplots_adjust(right=1.6)

            p = plt.plot(bin_centers, mean_bin, 'o', label='irec ={}'.format(irec))
            plt.plot(ang, fit(ang), label='irec ={}'.format(irec), color=p[0].get_color())
            plt.title(Stokes[s])
            plt.xlabel('angle (°)')
            plt.ylabel('sig2')
    #         plt.ylim(0, 5)
            plt.legend()
    return p

```

```{python}
p = plot_sigma2profile(ang, dict_sig2MC, nbins, nf_recon=d['nf_recon'])
plt.title('sig2 MC')
```

```{python}
plt.figure()
p = plot_sigma2profile(ang, dict_sig2MC_prime, nbins, nf_recon=d['nf_recon'][1:])
plt.title('sig2 MC prime')
```

```{python}
plt.figure()
p = plot_sigma2profile(ang, dict_sig2, nbins, nf_recon=d['nf_recon'][1:])
plt.title('sig2')
```

```{python}
plt.figure()
p = plot_sigma2profile(ang, dict_sig2_prime, nbins, nf_recon=d['nf_recon'][1:])
plt.title('sig2 prime')
```

```{python}
def plot_sig_mean(thedict, nf_recon):
    for s in range(3):
        for irec in nf_recon: 

            plt.subplot(1, 3, s+1)
            plt.subplots_adjust(right=1.6)
            
            if irec == 1: 
                sig_monofreq = dict_sig2MC['{}mean'.format(irec)][s]    
            else:
                sig = thedict['{}mean'.format(irec)][s] / sig_monofreq
                p = plt.plot(irec, sig, 'o', label='irec ={}'.format(irec))
                
            plt.plot(nf_recon, np.sqrt(nf_recon), 'k')
            
            plt.title(Stokes[s])
            plt.xlabel('irec')
            plt.ylabel('sig')
        #         plt.ylim(0, 5)
            plt.legend()
    return p
```

```{python}
p = plot_sig_mean(dict_sig2MC, d['nf_recon'])
```

```{python}
p = plot_sig_mean(dict_sig2MC_prime, d['nf_recon'])
```

```{python}
p = plot_sig_mean(dict_sig2, d['nf_recon'])
```

```{python}
p = plot_sig_mean(dict_sig2_prime, d['nf_recon'])

```

```{python}

```

```{python}

```
