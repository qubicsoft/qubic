---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# QUBIC spectroimaging

#### Louise Mousset, 2020/06/05


```{python}
# %matplotlib inline
from pylab import *
import os
import sys
import glob

# Specific science modules
import healpy as hp
import numpy as np
from astropy.io import fits

# Specific qubic modules
from qubicpack.utilities import Qubic_DataDir
from pysimulators import FitsArray
import pysm
import pysm.units as u

import qubic
from qubic import SpectroImLib as si
from qubic import QubicSkySim as qss
from qubic import NamasterLib as nam
from qubic.polyacquisition import compute_freq

from qubic import fibtools as ft

import ReadMC as rmc
import AnalysisMC as amc

rc('figure', figsize=(13, 10))
rc('font', size=15)
```

# Look at one MC simulation

```{python}
# Get the files
# rep = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/galaxy_center_d1/test_residuals/31613089/'
# rep = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/29712494/'
rep = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/galaxy_center_d1/nfsub15/'
dictionary = glob.glob(rep + '/*.dict')[0]
print(dictionary)

# Dictionary saved during the simulation
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictionary)

# Coordinates of the zone observed in the sky
center = qubic.equ2gal(d['RA_center'], d['DEC_center'])

# Number of subbands used during the simulation
nf_sub_rec = 3
nf_sub = d['nf_sub']
print('nf_sub = {}, nf_recon = {}'.format(nf_sub, nf_sub_rec))

# Get fits files names in a list
fits_noise = np.sort(glob.glob(rep + '*_nfsub{}_nfrecon{}_noiselessFalse*.fits'.format(nf_sub, nf_sub_rec), 
                              recursive=True))
fits_noiseless = np.sort(glob.glob(rep + '*_nfsub{}_nfrecon{}_noiselessTrue*.fits'.format(nf_sub, nf_sub_rec), 
                              recursive=True))

print(fits_noiseless)
```

```{python}
# Frequencies of the reconstructed subbands
Nfreq_edges, nus_edge, nus, deltas, Delta, Nbbands = compute_freq(150, nf_sub_rec)
print(nus)
```

```{python}
# Number of noise realisations
nreals = len(fits_noise)
print('nreals = ', nreals)

# Get seen map (observed pixels)
seenmap = rmc.get_seenmap(fits_noiseless[0])
print(seenmap.shape)

# Number of pixels and nside
npix = len(seenmap)
ns = d['nside']

```

## Coverage

```{python}
fitsfile = fits.open(fits_noise[0])
coverage = fitsfile['COVERAGE'].data
hp.mollview(coverage)

coverage_patch = coverage[seenmap]
coverage_patch.shape
```

```{python}
ang = rmc.pix2ang(d['nside'], center, seenmap)
coverage_norm = coverage_patch / np.max(coverage_patch)
inverse_coverage = 1. / (np.sqrt(coverage_norm))

plt.plot(ang, coverage_norm, '.', label='coverage')
plt.plot(ang, np.sqrt(coverage_norm), '.', label='$\sqrt{coverage}$')
plt.xlabel('Angle [deg]')
# plt.ylabel('Coverage normalized')
plt.title('Coverage normalized to the maximum as function of the angle in the patch.')
plt.legend()
```

## Correlations between bands

```{python}
residuals = amc.get_residuals(rep, 'noiseless', nf_sub_rec)
cov, corr = amc.get_covcorr_patch(residuals, stokesjoint=True, doplot=True)

```

```{python}
# For one pixel
for pix in range(2000, 2001):
    plt.figure(figsize=(6, 6))
    plt.imshow(cov[:, :, pix])#, vmin=-50, vmax=50)
    plt.title(pix)
    plt.colorbar()
```

```{python}
# Make a loop over irec and fill dictionnaries
dict_sig2MC = {}
dict_sig2 = {}
ang_th = 15
ang = rmc.pix2ang(d['nside'], center, seenmap)

for irec in [5]:
    print('irec =', irec)   
#     _, recon_patch, _, _ = rmc.get_patch_many_files(rep_simu + date_name, '*nfrecon{}*False*'.format(irec))
    residuals = amc.get_residuals(rep, 'mean_recon', irec)
    
    if irec == 1:
        # Remove the single dimension  
        residuals = np.squeeze(residuals)
        print('Residuals shape:', residuals.shape)

        sig2MC_monofreq = np.var(residuals, axis=0) # Variance over realizations
        sig2MCmean_monofreq = amc.average_pix_sig2(sig2MC_monofreq, ang, ang_threshold=ang_th) # Mean over pixels
        dict_sig2MC.update({'{}'.format(irec): sig2MC_monofreq})
        dict_sig2MC.update({'{}mean'.format(irec): sig2MCmean_monofreq})
        
        print('\n')
       
    else:
        if irec == 2:
            doplot = True
        else :
            doplot = False
        Cp = amc.get_Cp(residuals, nfrecon=d['nf_recon'], verbose=False, doplot=doplot)
        N, Cp_prime = amc.Cp2Cp_prime_viaCorr(Cp, verbose=True) # Average Cp over pixels
#         N, Cp_prime = amc.Cp2Cp_prime(Cp, verbose=True)
        
        # Compute sig2 and sig2MC 
        # Using Cp or Cp_prime
        weighted_av, sig2 = amc.make_weighted_av(residuals, Cp_prime, verbose=False)
        
        sig2mean = amc.average_pix_sig2(sig2, ang, ang_threshold=ang_th)
        dict_sig2.update({'{}'.format(irec): sig2})
        dict_sig2.update({'{}mean'.format(irec): sig2mean})
        
        sig2MC = np.var(weighted_av, axis=0) # Variance over realisations
        sig2MCmean = amc.average_pix_sig2(sig2MC, ang, ang_threshold=ang_th) # Mean over pixels
        dict_sig2MC.update({'{}'.format(irec): sig2MC})
        dict_sig2MC.update({'{}mean'.format(irec): sig2MCmean})
        
        print('\n')
```

```{python}
stokes = ['I', 'Q', 'U']

plt.figure()
plt.subplots_adjust(wspace=1)
for i in range(3):
    plt.subplot(1, 3, i+1)
    plt.imshow(N[:, :, i])
    plt.title(stokes[i])
    plt.colorbar(fraction=0.05)
    print(stokes[i] + ':')
    print(N[:, :, i])
    print('\n')
```

```{python}
dict_sig2
```

```{python}
print(Cp_prime.shape)
plt.imshow(Cp_prime[:, :, 0, 10])
plt.colorbar()
```

```{python}
plt.plot(np.sqrt(coverage_norm), dict_sig2MC['5'][:, 0], '.')
plt.xlabel('$\sqrt{coverage}$')
plt.ylabel('$\sigma^2$')
limit = (coverage_patch / np.max(coverage_patch)) > 0.6
# plt.plot(dict_sig2['3'][limit, 0], dict_sig2MC['3'][limit, 0], '.')

plt.title('Variance for each pixel (I component)')
```

```{python}
import qubic.fibtools as ft

x = 1 / np.sqrt(coverage_norm)

xc, yc, dx, dy, _ = ft.profile(x, dict_sig2['5'][:, 0], 
                               nbins=30, 
                               plot=False,
                               clip=True)


xcMC, ycMC, dxMC, dyMC, _ = ft.profile(x, dict_sig2MC['5'][:, 0], 
                                       nbins=30, 
                                       plot=False,
                                       clip=True)

plt.errorbar(xc, yc, xerr=dx, yerr=dy, fmt='bo', label='$\sigma^2$')
plt.errorbar(xcMC, ycMC, xerr=dxMC, yerr=dyMC, fmt='ro', label='$\sigma^2 MC$')
# plt.plot(x, dict_sig2['3'][:, 1] , 'b,')
# plt.plot(x, dict_sig2MC['3'][:, 1] , 'r,')
plt.ylim(0, 100)

plt.xlabel('$1 / \sqrt{coverage}$', fontsize=15)
plt.ylabel('$\sigma^2$', fontsize=15)
plt.legend()
```

```{python}
plt.plot(xc, yc / ycMC)
plt.xlabel('$1 / \sqrt{coverage}$', fontsize=15)
plt.ylabel('$\sigma^2 / \sigma_{MC}^2$', fontsize=15)
```

### Matrix Cp_prime in coverage bins

```{python}
nf_sub_rec = 5
residuals = amc.get_residuals(rep, 'noiseless', nf_sub_rec)
Cp = amc.get_Cp(residuals, nfrecon=d['nf_recon'], verbose=True, doplot=True)
```

```{python}
npix_patch = coverage_norm.shape[0]

step = 0.100001
for b in np.arange(0.1, 1, step):
    print(b, b + step)
    mybin = (coverage_norm > b) & (coverage_norm < b+step)
    npix_bin = np.sum(mybin)
    print('Npix in the bin:', npix_bin)

    Nbin, Cp_primebin = amc.Cp2Cp_prime_viaCorr(Cp[:, :, :, mybin])
    
    plt.figure()
    plt.imshow(np.mean(Cp_primebin[:, :, 0, :], axis=2))
    plt.colorbar()
    plt.title('Cp_prime I bin coverage {} to {}'.format(b, b+step))

    weighted_avbin, sig2 = amc.make_weighted_av(residuals[:, :, mybin, :], Cp_primebin, verbose=False)
    print('sig2', sig2.shape)
    sig2MC = np.var(weighted_avbin, axis=0)
    if b == 0.1:
        sig2_bin = sig2
        sig2MC_bin = sig2MC
    else:
        sig2_bin = np.concatenate((sig2_bin, sig2))
        sig2MC_bin = np.concatenate((sig2MC_bin, sig2MC))

```

```{python}
sig2_bin.shape
```

```{python}
x = 1 / np.sqrt(coverage_norm)
Stokes = ['I', 'Q', 'U']
istk = 0
xc_bin, yc_bin, dx_bin, dy_bin, _ = ft.profile(x, sig2_bin[:, istk], 
                               nbins=30, 
                               plot=False,
                               clip=True,
                                dispersion=False)


xcMC_bin, ycMC_bin, dxMC_bin, dyMC_bin, _ = ft.profile(x, sig2MC_bin[:, istk], 
                                       nbins=30, 
                                       plot=False,
                                       clip=True,
                                        dispersion=False)

plt.errorbar(xc_bin, yc_bin, xerr=dx_bin, yerr=dy_bin, fmt='bo', label='$\sigma^2$')
plt.errorbar(xcMC_bin, ycMC_bin, xerr=dxMC_bin, yerr=dyMC_bin, fmt='ro', label='$\sigma^2 MC$')
# plt.plot(x, sig2_bin[:, istk] , 'b,')
# plt.plot(x, sig2MC_bin[:, istk] , 'r,')
plt.ylim(0, 50)

plt.xlabel('$1 / \sqrt{coverage}$', fontsize=15)
plt.ylabel('$\sigma^2$', fontsize=15)
plt.legend()
plt.title('{} component'.format(Stokes[istk]))
```

```{python}
plt.plot(xc_bin, yc_bin / ycMC_bin)
plt.xlabel('$1 / \sqrt{coverage}$', fontsize=15)
plt.ylabel('$\sigma^2 / \sigma_{MC}^2$', fontsize=15)
plt.title('Ratio, Weighted average done in 9 coverage bins')
```

```{python}
np.mean(yc_bin / ycMC_bin)
```

# STD as function of the number of bands

```{python}
mylist_coverage_norm = []
mylist_N, mylist_Cp, mylist_Cp_prime = [], [], []
mylist_N00, mylist_Cp_prime_00 = [], []

mylist_covI, mylist_covQ, mylist_covU = [], [], []
mylist_covI_brut, mylist_covQ_brut, mylist_covU_brut = [], [], []
mylist_fitcov = []
mylist_std_residual = []
mylist_seenmap = []

for nfrec in [0, 1, 2, 3, 4, 5, 8]:

    rep = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/galaxy_center_d1/nfrecon{}/'.format(nfrec)
    
    # Dictionary saved during the simulation
    dictionary = glob.glob(rep + '/*.dict')[0]
    d = qubic.qubicdict.qubicDict()
    d.read_from_file(dictionary)
    
    if nfrec == 0:
        nfrec += 1
    nfsub = d['nf_sub'] 
    print('\n nfsub = {}, nfrec = {}'.format(nfsub, nfrec))

    # Get files
    fits_noise = np.sort(glob.glob(rep + '*noiselessFalse*.fits'))
    fits_noiseless = np.sort(glob.glob(rep + '*noiselessTrue*.fits'))
    
    nreals = len(fits_noise)
    print('Nreals', nreals)

    # Seen map
    seenmap = rmc.get_seenmap(fits_noiseless[0])
    with open(rep_save + 'seenmap_nfsub{}_nfrecon{}.pkl'.format(nfsub, nfrec), 'wb') as f:
        pickle.dump(seenmap, f)

    mylist_seenmap.append(seenmap)
    print('# pixel in the patch:', seenmap.sum())

    # Coverage
    fitsfile = fits.open(fits_noise[0])
    coverage = fitsfile['COVERAGE'].data 
#     with open(rep_save + 'coverage_nfsub{}_nfrecon{}.pkl'.format(nfsub, nfrec), 'wb') as f:
#         pickle.dump(coverage, f)


    coverage_norm = coverage[seenmap] / np.max(coverage[seenmap])
    mylist_coverage_norm.append(coverage_norm)

    # Residuals
    residuals = amc.get_residuals(fits_noise, fits_noiseless[0], 'mean_recon')
    residuals = np.asarray(residuals)
    
    residuals_fullmap = np.zeros((nreals, nfrec, 12*d['nside']**2, 3))
    residuals_fullmap[:, :, seenmap, :] = residuals
    
    print('Residual shape:', residuals.shape)
    print('Residual full map shape:', residuals_fullmap.shape)

    with open(rep_save + 'residualspatch_nfsub{}_nfrecon{}.pkl'.format(nfsub, nfrec), 'wb') as f:
        pickle.dump(residuals[0], f)

    # Std of the residuals
    std_residual = np.std(residuals, axis=(0, 2))
    print(std_residual)
    mylist_std_residual.append(std_residual)
    
#     # JC function: covariance over pixels after normalizing the map by np.sqrt(coverage)
#     covI = np.zeros((nreals, nfrec, nfrec))
#     covQ = np.zeros((nreals, nfrec, nfrec))
#     covU = np.zeros((nreals, nfrec, nfrec))
#     for i in range(nreals):
#         covI[i], covQ[i], covU[i],  fitcov = qss.get_cov_nunu(residuals[i], coverage_norm)
#     mylist_covI.append(covI)
#     mylist_covQ.append(covQ)
#     mylist_covU.append(covU)
#     mylist_fitcov.append(fitcov)
    
    # Same as JC function but without the correction for the normalization
#     residual_norm = np.zeros_like(residuals[0])
    
#     print(residual_norm.shape)
#     for istk in range(3):
#         for b in range(nfrec):
#             residual_norm[b, :, istk] = residuals[0, b, :, istk] * np.sqrt(coverage_norm)
    
#     covI_brut = np.cov(residual_norm[:, :, 0])
#     covQ_brut = np.cov(residual_norm[:, :, 1])
#     covU_brut = np.cov(residual_norm[:, :, 2])

#     print(covI_brut.shape)
#     mylist_covI_brut.append(covI_brut)
#     mylist_covQ_brut.append(covQ_brut)
#     mylist_covU_brut.append(covU_brut)
        
#     # Get Cp
#     Cp = amc.get_Cp(residuals, nfrecon=d['nf_recon'], verbose=False, doplot=True)
#     mylist_Cp.append(Cp)
    
#     # Average Cp over pixels to get Cp_prime
#     # 1st method - Factorizing by the term 00 
#     N00, Cp_prime00 = amc.Cp2Cp_prime(Cp)
#     mylist_N00.append(N00)
#     mylist_Cp_prime_00.append(Cp_prime00)

#     # 2nd method - Averaging correlation matrices 
#     N, Cp_prime = amc.Cp2Cp_prime_viaCorr(Cp) 
#     mylist_N.append(N)
#     mylist_Cp_prime.append(Cp_prime)

```

```{python}
mylist_covI[4].shape
```

```{python}
# Save some matrices
import pickle
rep_save = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/corr_matrices/'
with open(rep_save + 'coverage_norm.pkl', 'wb') as f:
    pickle.dump(mylist_coverage_norm, f)

```

```{python}
with open(rep_save + 'Cp.pkl', 'rb') as f:
    mynewlist = pickle.load(f)
```

#### Plot the different matrices

```{python}
# Covariance over pixels (JC method)
Stokes = ['I', 'Q', 'U']
nbands = [1, 1, 2, 3, 4, 5, 8]

plt.figure()
plt.subplots_adjust(wspace=0.5)
for i in range(len(mylist_covI)):
    plt.subplot(3, 7, i+1)
    plt.imshow(mylist_covI[i][0, :, :])
    plt.colorbar(fraction=0.05, orientation='horizontal')
    plt.title('I')
    
    plt.subplot(3, 7, 7+i+1)
    plt.imshow(mylist_covQ[i][0, :, :])
    plt.colorbar(fraction=0.05, orientation='horizontal')
    plt.title('Q')
    
    plt.subplot(3, 7, 14+i+1)
    plt.imshow(mylist_covU[i][0, :, :])
    plt.colorbar(fraction=0.05, orientation='horizontal')
    plt.title('U')
    
#     if istk == 0:
#         print('\n Cov I - {} bands:'.format(nbands[i]))
            
#     print('\n {}:\n'.format(Stokes[istk]), mylist_covI[i][0, :, :])
```

```{python}
# Covariance over pixels brut
Stokes = ['I', 'Q', 'U']
nbands = [1, 1, 2, 3, 4, 5, 8]

plt.figure()
plt.subplots_adjust(wspace=0.5)
for i in range(2, 7):
    plt.subplot(3, 7, i+1)
    plt.imshow(mylist_covI_brut[i])
    plt.colorbar(fraction=0.05, orientation='horizontal')
    plt.title('I')
    
    plt.subplot(3, 7, 7+i+1)
    plt.imshow(mylist_covQ_brut[i])
    plt.colorbar(fraction=0.05, orientation='horizontal')
    plt.title('Q')
    
    plt.subplot(3, 7, 14+i+1)
    plt.imshow(mylist_covU_brut[i])
    plt.colorbar(fraction=0.05, orientation='horizontal')
    plt.title('U')
plt.show()
    
#     if istk == 0:
#         print('\n Cov I - {} bands:'.format(nbands[i]))
            
#     print('\n {}:\n'.format(Stokes[istk]), mylist_covI[i][0, :, :])
```

```{python}
# Correlation matrices N averaged over pixels
Stokes = ['I', 'Q', 'U']

plt.figure()
plt.subplots_adjust(wspace=0.5)
for i in range(7):
    for istk in range(3):
        plt.subplot(3, 7, 7*istk+i+1)
        plt.imshow(mylist_N[i][:, :, istk])
        plt.title(Stokes[istk])
        if istk == 0:
            print('\n Correlation Matrices N - {} bands:'.format(nbands[i]))
            
        print('\n {}:\n'.format(Stokes[istk]), mylist_N[i][:, :, istk])
        plt.colorbar(fraction=0.05, orientation='horizontal')
```

```{python}
# Matrices N00 averaged over pixels
Stokes = ['I', 'Q', 'U']

plt.figure()
plt.subplots_adjust(wspace=0.5)
for i in range(7):
    for istk in range(3):
        plt.subplot(3, 7, 7*istk+i+1)
        plt.imshow(mylist_N00[i][:, :, istk])
        plt.title(Stokes[istk])
        if istk == 0:
            print('\n Matrices N00 - {} bands:'.format(nbands[i]))
            
        print('\n {}:\n'.format(Stokes[istk]), mylist_N00[i][:, :, istk])
        plt.colorbar(fraction=0.05, orientation='horizontal')
```

```{python}
mylist_Cpnorm[0].shape
```

```{python}
# Correlation matrices Cp averaged over pixels

# Normalize by the coverage
mylist_Cpnorm = [mylist_Cp[i] * mylist_coverage_norm[i] for i in range(7)]

# Average over pixels
mylist_Cpnorm_avg = [np.mean(mylist_Cpnorm[i], axis=3) for i in range(7)]

Stokes = ['I', 'Q', 'U']

plt.figure(figsize=(20, 15))
plt.subplots_adjust(wspace=0.6)
for i in range(7):
    for istk in range(3):
        plt.subplot(3, 7, 7*istk+i+1)
        plt.imshow(mylist_Cpnorm_avg[i][:, :, istk])
        plt.title(Stokes[istk])
        if istk == 0:
            print('\n Correlation Matrices Cp - {} bands:'.format(nbands[i]))
            
        print('\n {}:\n'.format(Stokes[istk]), mylist_Cpnorm_avg[i][:, :, istk])
        plt.colorbar(fraction=0.05, orientation='horizontal')
```

```{python}
# Check the normalization by the coverage on some pixels
for i in [100, 2000, 5000, 10000, 20000]:
    plt.figure()
    plt.subplot(121)
    plt.imshow(mylist_Cp[4][:, :, 0, i])
    plt.title('Cp_prime for pixel {} - I'.format(i), fontsize=12)
    plt.colorbar(orientation='horizontal', fraction=0.4)
    
    plt.subplot(122)
    plt.imshow(mylist_Cpnorm[4][:, :, 0, i])
    plt.title('Cp_prime normalized for pixel {} - I'.format(i), fontsize=12)
    plt.colorbar(orientation='horizontal', fraction=0.4)
```

```{python}
# Plot one term of Cp as function of the coverage
iband = 5
istk = 1
diag_term = 3
plt.figure()
plt.title('{} bands - {}'.format(nbands[iband], Stokes[istk]))
plt.plot(1 / mylist_coverage_norm[iband], mylist_Cp[iband][diag_term, diag_term, istk, :], 
         '.', label='Not normalized')
plt.plot(1/ mylist_coverage_norm[iband], mylist_Cpnorm[iband][diag_term, diag_term, istk, :], 
         '.', label='Normalized')

plt.legend()
plt.xlabel('1 / Coverage')
plt.ylabel('Cp_{}{}'.format(diag_term, diag_term))
```

```{python}
# Correlation matrices Cp prime averaged over pixels

# Normalize by the coverage
mylist_Cp_primenorm = [mylist_Cp_prime[i] * mylist_coverage_norm[i] for i in range(7)]

# Average over pixels
mylist_Cp_primenorm_avg = [np.mean(mylist_Cp_primenorm[i], axis=3) for i in range(7)]

Stokes = ['I', 'Q', 'U']

plt.figure(figsize=(20, 15))
plt.subplots_adjust(wspace=0.6)
for i in range(7):
    for istk in range(3):
        plt.subplot(3, 7, 7*istk+i+1)
        plt.imshow(mylist_Cp_primenorm_avg[i][:, :, istk])
        plt.title(Stokes[istk])
        if istk == 0:
            print('\n Correlation Matrices Cp_prime - {} bands:'.format(nbands[i]))
            
        print('\n {}:\n'.format(Stokes[istk]), mylist_Cpnorm_avg[i][:, :, istk])
        plt.colorbar(fraction=0.05, orientation='horizontal')
```

#### Try to find a model for the evolution of sigma2

```{python}
import matplotlib.colors as mcolors
mcolors.TABLEAU_COLORS.keys()

colorlist = list(mcolors.TABLEAU_COLORS.keys())
```

```{python}
diag_term = 0

plt.figure()
for istk in range(3):
    myterms = [mylist_Cpnorm_avg[i][diag_term, diag_term, istk] for i in range(7)]
#     var_1band = np.mean(mylist_sig2MC[0], axis=0)[istk]
#     myterms.insert(0, var_1band)
    plt.plot(nbands, myterms, 'o', color=colorlist[istk])

    a, b, c = np.polyfit(nbands, myterms, deg=2, rcond=None, full=False, w=None, cov=False)
    x = np.arange(1, 9, 0.1)
    plt.plot(x, a*x**2 + b*x + c, color=colorlist[istk], 
             label='{}: ${:2.3}x^2 {:2.3}x + {:2.3}$'.format(Stokes[istk], a, b, c))

plt.xlabel('# Bands')
plt.ylabel('$(Cp)_{00}$')
plt.legend()
```

```{python}
diag_term = 0

plt.figure()
for istk in range(3):
    myterms = [mylist_Cp_primenorm_avg[i][diag_term, diag_term, istk] for i in range(7)]
    plt.plot(nbands, myterms, 'o', color=colorlist[istk])

    a, b, c = np.polyfit(nbands, myterms, deg=2, rcond=None, full=False, w=None, cov=False)
    x = np.arange(1, 9, 0.1)
    plt.plot(x, a*x**2 + b*x + c, color=colorlist[istk], 
             label='{}: ${:2.3}x^2 {:2.3}x + {:2.3}$'.format(Stokes[istk], a, b, c))

plt.xlabel('# Bands')
plt.ylabel('$(Cp)^\prime_{00}$')
plt.legend()
```

## Recombined map

```{python}
def Cp2Cp_prime_percoveragebin(Cp, coverage, nbins=10, method='viacorr'):
    cov_max = 1.
    cov_min = 0.1
    step = (cov_max - cov_min) / nbins + 0.0001
    print('Step in coverage:', step)
    
    nbands = Cp.shape[0]
    Cp_prime = np.zeros_like(Cp)
    Nbins = np.zeros((nbins, nbands, nbands, 3))
    for i, b in enumerate(np.arange(cov_min, cov_max, step)):
        mybin = (coverage > b) & (coverage < b+step)
        npix_bin = np.sum(mybin)
        print('Npix in the bin:', npix_bin)
        
        if method == 'viacorr':
            Nbins[i], Cp_prime[:, :, :, mybin] = amc.Cp2Cp_prime_viaCorr(Cp[:, :, :, mybin])
        else:
            Nbins[i], Cp_prime[:, :, :, mybin] = amc.Cp2Cp_prime(Cp[:, :, :, mybin])
    N = np.mean(Nbins, axis=0)
    return N, Cp_prime
```

```{python}
    
    if nfrec == 1:
        sig2MC = np.var(residuals[:, 0, :, :], axis=0) # Variance over realisations
        sig2 = sig2MC * 0.

#         # Recombined the band
#         # Using Cp_prime
#         weighted_av, sig2 = amc.make_weighted_av(residuals, Cp_prime, verbose=False)
#         sig2MC = np.var(weighted_av, axis=0)
#         mylist_weighted_av.append(weighted_av)
#         mylist_sig2.append(sig2)
#         mulist_sig2MC.append(sig2MC)

# #     Per coverage bins
#         else:
# #             N, Cp_prime = Cp2Cp_prime_percoveragebin(Cp, coverage_norm, nbins=9)
# #             weighted_av, sig2 = amc.make_weighted_av(residuals, Cp_prime, verbose=False)
# #             print('sig2', sig2.shape)
# #             sig2MC = np.var(weighted_av, axis=0)
# #             allN.append(N)
# #             allCp_prime.append(Cp_prime)
# #             allCp_primenorm.append(Cp_primenorm)
# #             all_weighted_av.append(weighted_av)

#             for b in np.arange(0.1, 1, step):
#                 print(b, b + step)
#                 mybin = (coverage_norm > b) & (coverage_norm < b+step)
#                 npix_bin = np.sum(mybin)
#                 print('Npix in the bin:', npix_bin)

#                 if nfrec == 1:
#                     sig2MCbin = np.var(residuals[:, 0, mybin, :], axis=0)
#                     sig2bin = sig2MCbin * 0.
#                 else:
#                     # Cp_prime and weighted average per coverage bin
#                     Nbin, Cp_primebin = amc.Cp2Cp_prime_viaCorr(Cp[:, :, :, mybin])

#                     plt.figure()
#                     plt.imshow(np.mean(Cp_primebin[:, :, 0, :], axis=2))
#                     plt.colorbar()
#                     plt.title('Cp_prime I bin coverage {} to {}'.format(b, b+step))

#                     weighted_avbin, sig2bin = amc.make_weighted_av(residuals[:, :, mybin, :], Cp_primebin, verbose=False)
#                     print('sig2', sig2bin.shape)
#                     sig2MCbin = np.var(weighted_avbin, axis=0)
#                 if b == 0.1:
#                     sig2 = sig2bin
#                     sig2MC = sig2MCbin
#                 else:
#                     sig2 = np.concatenate((sig2, sig2bin))
#                     print('gg', sig2.shape)
#                     sig2MC = np.concatenate((sig2MC, sig2MCbin))
```

```{python}
Stokes = ['I', 'Q', 'U']

nbins = 20
x = np.zeros((len(all_sig2), nbins, 3))
y = np.zeros_like(x)
dx = np.zeros_like(x)
dy = np.zeros_like(x)
xMC = np.zeros_like(x)
yMC = np.zeros_like(x)
dxMC = np.zeros_like(x)
dyMC = np.zeros_like(x)

plt.figure()
for i in range(7):
    inv_cov = 1 / np.sqrt(allcoverage_norm[i])
    print(inv_cov.shape)
    for istk in range(3):
        x[i, :, istk], y[i, :, istk], dx[i, :, istk], dy[i, :, istk], _ = ft.profile(inv_cov, 
                                                                                     all_sig2[i][:, istk], 
                                                                                     nbins=nbins, 
                                                                                     dispersion=False,
                                                                                     plot=False,
                                                                                     clip=True)


        xMC[i, :, istk], yMC[i, :, istk], dxMC[i, :, istk], dyMC[i, :, istk], _ = ft.profile(inv_cov, 
                                                                                             all_sig2MC[i][:, istk],
                                                                                             nbins=nbins, 
                                                                                             dispersion=False,
                                                                                             plot=False,
                                                                                             clip=True)


```

```{python}
# Plot
nbands = [1, 3, 5, 1, 2, 4, 8]

istk = 0
for i in range(7):
#     plt.errorbar(x[i, :, istk], y[i, :, istk], xerr=dx[i, :, istk], yerr=dy[i, :, istk], 
#                  fmt='o', color=colorlist[i], label='nfrecon = {}'.format(nbands[i]))
    plt.errorbar(xMC[i, :, istk], yMC[i, :, istk] / yMC[1, :, istk], xerr=dxMC[i, :, istk], yerr=dyMC[i, :, istk], 
                 fmt='o', color=colorlist[i], label='nfrecon = {}'.format(nbands[i]))
# #     # plt.plot(x, sig2_bin[:, istk] , 'b,')
    # plt.plot(x, sig2MC_bin[:, istk] , 'r,')
    # plt.ylim(0, 100)
# plt.ylim(-10, 10)
plt.xlabel('Coverage', fontsize=15)
plt.ylabel('$\sigma $ ', fontsize=15)
plt.legend()
plt.title('{} component'.format(Stokes[istk]))
```

```{python}
# all_sig2MC[0].shape
# yMC.shape
coverage_norm
```

```{python}
nbands = [1, 2, 3, 4, 5, 8]

# ss = np.zeros((7, 3))
# for i in range(7):
#     ss[i, :] = np.mean(all_sig2MC[i], axis=0)
mean_sig2MC = np.mean(yMC, axis=1) # Mean over the bins
std_sig2MC = np.sqrt(np.sum(dyMC**2, axis=1)) / nbins
# std_sig2MC = np.std(yMC, axis=1) / np.sqrt(nbins)


for i in range(3):
    mean_norm = mean_sig2MC[1:, i]/mean_sig2MC[1, i]
    plt.errorbar(nbands, mean_norm, yerr=std_sig2MC[1:, i], fmt='o', label=Stokes[i])
plt.plot(np.arange(1, 9), np.ones(8), 'k--', label='$y = 1$')
# plt.plot(np.arange(1, 9), np.sqrt(np.arange(1, 9)), 'r', label='$y=\sqrt{x}$')
plt.legend()
plt.xlabel('Number of bands')
plt.ylabel('$\sigma$ in the recombined redidual map')
```

```{python}
# Get seen map (observed pixels)
seenmap = rmc.get_seenmap(fits_noiseless[0])
print(seenmap.shape)

recon, recon_nl, conv, conv_nl = [], [], [], []
for i in range(7):
    r, c, d = rmc.get_maps(fits_noise[i])
    r_nl, c_nl, d_nl = rmc.get_maps(fits_noiseless[i])
    recon.append(r)
    recon_nl.append(r_nl)
    conv.append(c)
    conv_nl.append(c_nl)
    
```

```{python}
nband = [1, 3, 5, 1, 2, 4, 8]
istk = 0
isub = 0

plt.figure(figsize=(20, 5))
for i in range(7):
    hp.gnomview(conv[i][isub, :, istk], rot=center, reso=15, notext=True,
                sub=(1, 7, i+1), title=None)
    plt.text(-0.2, 0.6, '# bands = ' + str(nband[i]))
```

```{python}
nband = [1, 3, 5, 1, 2, 4, 8]
istk = 0
isub = 0

plt.figure(figsize=(15, 20))
for i in range(7):
    hp.gnomview(recon[i][isub, :, istk], rot=center, reso=15, notext=True,
                sub=(7, 3, i*3 +1), title='Recon')
    plt.text(-1.5, 0, 'nf_recon = ' + str(nband[i]))
    hp.gnomview(recon_nl[i][isub, :, istk], rot=center, reso=15, notext=True,
                sub=(7, 3, i*3 +2), title='Recon nl')
    res = recon[i][isub, :, istk] - recon_nl[i][isub, :, istk]
    hp.gnomview(res, notext=True, rot=center, reso=15, min=-50, max=50, 
                sub=(7, 3, i*3 +3), title='Residuals')
    
```

```{python}
recon_nl[0].shape
```

```{python}
npix_patch = coverage_norm.shape[0]
color = ['b', 'r', 'g']
Stokes = ['I', 'Q', 'U']
step = 0.100001

std = np.zeros((7, 3))

nbands = [1, 3, 5, 1, 2, 4, 8]
for i in range(2):
    residuals = recon[i] - recon_nl[i]
    Cp = amc.get_Cp(residuals, nfrecon=nbands[i], verbose=True, doplot=True)

    for b in np.arange(0.1, 1, step):
        print(b, b + step)
        mybin = (coverage_norm > b) & (coverage_norm < b+step)
        npix_bin = np.sum(mybin)
        print('Npix in the bin:', npix_bin)

        Cp_primebin = amc.Cp2Cp_prime_viaCorr(Cp[:, :, :, mybin])

        plt.figure()
        plt.imshow(np.mean(Cp_primebin[:, :, 0, :], axis=2))
        plt.colorbar()
        plt.title('Cp_prime I bin coverage {} to {}'.format(b, b+step))

        weighted_avbin, sig2 = amc.make_weighted_av(residuals[:, :, mybin, :], Cp_primebin, verbose=False)
        print('weighted', weighted_avbin.shape)
        print('sig2', sig2.shape)
        sig2MC = np.var(weighted_avbin, axis=0)
        if b == 0.1:
            sig2_bin = sig2
            sig2MC_bin = sig2MC
        else:
            sig2_bin = np.concatenate((sig2_bin, sig2))
            sig2MC_bin = np.concatenate((sig2MC_bin, sig2MC))

        
#     std[i, :] = np.std(res[seenmap, :], axis=0)

# for istk in range(3):
#     plt.plot(nband, std[:, istk]/(std[0, istk]), 'o', color=color[istk], label=Stokes[istk])
# plt.legend()
# plt.xlabel('# reconstructed bands')
```

```{python}

```
