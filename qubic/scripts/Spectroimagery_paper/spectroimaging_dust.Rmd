---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# QUBIC spectroimaging

#### Editing by Martin Gamboa, Louise Mousset, 2019/09/02

This notebook is part of a set of notebooks with the idea to show spectroimaging capabilities of qubicsoft. There are 2 notebooks:
* spectroimaging_pointsource.Rmd: Test map-making for two point source emmiting in monochromatic frecuency and superimpose two signals in different frecuency and see how the reconstruction works
* spectroimaging_dust.Rmd: test map-making using cmb+dust signal

```{python}
# %matplotlib inline
from pylab import *
import os
import sys

# Specific science modules
import healpy as hp
import numpy as np

# Specific qubic modules
from qubicpack.utilities import Qubic_DataDir
from pysimulators import FitsArray
import pysm
import pysm.units as u

import qubic
from qubic import SpectroImLib as si
from qubic import QubicSkySim as qss
from qubic import NamasterLib as nam

import ReadMC as rmc

rc('figure', figsize=(13, 10))
rc('font', size=15)
```

```{python}
# Repository for dictionary 
dictfilename = os.environ['QUBIC_DICT']+'spectroimaging_article.dict'

# Read dictionary chosen
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictfilename)

d['nf_sub'] = 15

# d['nside'] = 16

# Center of the patch observed in galactic coordinates
l_center = 0.
b_center = 0. 
center = np.array([l_center, b_center])

# RA DEC coordinates for the center of the patch
d['RA_center'], d['DEC_center'] = qubic.gal2equ(l_center, b_center)
print(d['RA_center'], d['DEC_center'])

# d['noiseless'] = True
print(d['detector_nep'])
```

# Input sky
* cmb+dust+synchrotron

I would like to make a sky with a very particular spectra (a V centered at 150GHz).

```{python}
maps_dir = '/home/lmousset/QUBIC/MyGitQUBIC/qubic/qubic/scripts/Spectroimagery_paper/maps/'
x0cmb = FitsArray(maps_dir + 'CMB_r=0_nside128_nfsub15.fits')
x0dust = FitsArray(maps_dir + 'Dust_d1_nside128_nfsub15.fits')
x0synch = FitsArray(maps_dir + 'Synchrotron_s1_nside128_nfsub15.fits')

print('Input Map with shape (nf_sub, #pixels, #stokes) : ', np.shape(x0dust))
```

```{python}
allx0 = [x0synch, x0cmb, x0dust]
title = ['Synchrotron', 'CMB', 'Dust']
isub = 10
for i in range(3):
    hp.gnomview(allx0[i][isub, :, 0], sub=(1, 3, i+1), rot=center, reso=15, title=title[i])
```

```{python}
# Remember that we can always retrieve the input CMB maps and spectra

ell, totDL, unlensedDL = qss.get_camb_Dl(r=0., lmax=3*d['nside']-1)
cmb_dict = {'CAMBSpectra':totDL, 'ell':ell, 'seed':None}
sky_config = {'cmb': cmb_dict}
Qubic_skycmb = qss.Qubic_sky(sky_config, d)

### Input Maps
input_maps = Qubic_skycmb.input_cmb_maps
rng = (np.std(input_maps, axis=(1))*3).astype(int)
rng[1:] = np.max(rng[1:])

plt.figure()
hp.mollview(input_maps[0,:], title="I input map used", min=-rng[0], max=rng[0], sub=(1,3,1))
hp.mollview(input_maps[1,:], title="Q input map used", min=-rng[1], max=rng[1], sub=(1,3,2))
hp.mollview(input_maps[2,:], title="U input map used", min=-rng[2], max=rng[2], sub=(1,3,3))

### Input Cls
input_Dl = Qubic_skycmb.input_cmb_spectra
if input_Dl is not None:
    input_ell = np.arange(np.shape(input_Dl)[0])
    plt.figure()
    order = ['TT', 'EE', 'BB', 'TE']
    for i in range(4):
        subplot(2, 2, i+1)
        plot(input_ell, input_Dl[:, i], color='k')
        plt.title(order[i])
        xlabel('$\\ell$')
        ylabel('$D_\\ell$')
    tight_layout()
```

# Get the coverage

```{python}
p = qubic.get_pointing(d)
q = qubic.QubicMultibandInstrument(d)
s = qubic.QubicScene(d)

_, nus_edge, _, _, _, _ = qubic.compute_freq(150, d['nf_sub'])

a = qubic.QubicMultibandAcquisition(q, p, s, d, nus_edge)
cov = a.get_coverage()
```

```{python}
# Look at the coverage of the sky
print(cov.shape)
covsum = np.sum(cov, axis=0)
hp.mollview(covsum)
```

```{python}
seenmap = covsum > 0.1 * np.max(covsum)
cov[:, np.invert(seenmap)] = hp.UNSEEN
hp.mollview(cov[1])
```

# STD in the patch

```{python}
std_x0cmb = np.std(x0cmb[:, seenmap, 0], axis=(1))
std_x0dust = np.std(x0dust[:, seenmap, 0], axis=(1))
std_x0synch = np.std(x0synch[:, seenmap, 0], axis=(1))
```

```{python}
# Sum the maps
x0 = x0cmb + x0dust + x0synch*800
print(x0.shape)
std_x0 = np.std(x0[:, seenmap, 0], axis=(1))

stn = ['I', 'Q', 'U']
isub = 0
plt.figure()
for istokes in range(3):
    hp.mollview(x0[isub, :, istokes], title="{} full map".format(stn[istokes]), sub=(1, 3, istokes+1))
```

```{python}
_, _, nus_x0, deltas, _, _ = qubic.compute_freq(150, d['nf_sub'])
print(deltas)
_, nus_edges_rec, nus_rec, _, _, _ = qubic.compute_freq(150, 3)
print(nus_edges_rec)

plt.figure()
for n in nus_edges_rec:
    plt.axvline(n, color='k')
for c in nus_rec:
    plt.axvline(c, color='r')
    
plt.plot(nus_x0, std_x0*deltas, label='Full sky x0')

# plt.plot(nus, std_x0cmb, label='cmb')
# plt.plot(nus, std_x0dust, label='dust')
# plt.plot(nus, std_x0synch, label='synch')
plt.xlabel('Frequency [GHz]')
plt.ylabel('STD x $\delta$')

plt.legend()
```

# TOD simulation

```{python}
# ==== TOD making ====
TOD, maps_convolvedx0 = si.create_TOD(d, p, x0)
print('--------- Noiseless TOD with shape: {} - Done ---------'.format(np.shape(TOD)))
```

```{python}
# This function doesn't work !
# rot_beams = si.get_hitmap(q[0], s, p)
# print(rot_beams.shape)
# hp.mollview(np.sum(rot_beams, axis=0) + x0[0, :, 0])
```

```{python}
maps_convolvedx0 = np.array(maps_convolvedx0)
print(maps_convolvedx0.shape)

std_maps_convx0 = np.std(maps_convolvedx0[:, seenmap, 0], axis=(1))
plt.plot(nus_x0, std_maps_convx0*deltas)

plt.plot(nus_x0, std_x0*deltas, label='x0 full')
```

# Map-Making

```{python}
d['tol'] = 1e-4
nf_sub_rec = 5

maps_recon, cov, nus, nus_edge, maps_convolved = si.reconstruct_maps(TOD, d, p,
                                                                    nf_sub_rec, x0)
print(maps_recon.shape)
```

```{python}
# Save the simulation
save_dir = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/'
simu_name = 'nfsub15_rec5_galaxycenter.fits'
# rmc.save_simu_fits(maps_recon, cov, nus, nus_edge, maps_convolved, save_dir=save_dir, simu_name=simu_name)
```

# Map making noiseless

```{python}
d['noiseless'] = True
TOD_noiseless, maps_convolved_noiseless = si.create_TOD(d, p, x0)
print('--------- Noiseless TOD with shape: {} - Done ---------'.format(np.shape(TOD_noiseless)))

# Reconstruction noiseless
print('************* Map-Making on {} sub-map(s) (noiseless) *************'.format(nf_sub_rec))

maps_recon_noiseless, cov_noiseless, nus, nus_edge, maps_convolved_noiseless = si.reconstruct_maps(TOD_noiseless, 
                                                                                                   d, 
                                                                                                   p,
                                                                                                   nf_sub_rec, 
                                                                                                   x0=x0)
if nf_sub_rec == 1:
    print(maps_recon_noiseless.shape, maps_convolved_noiseless.shape)
    maps_recon_noiseless = np.reshape(maps_recon_noiseless, np.shape(maps_convolved_noiseless))
# Look at the coverage of the sky
cov_noiseless = np.sum(cov_noiseless, axis=0)
maxcov_noiseless = np.max(cov_noiseless)
unseen = cov_noiseless < maxcov_noiseless * 0.1
maps_convolved_noiseless[:, unseen, :] = hp.UNSEEN
maps_recon_noiseless[:, unseen, :] = hp.UNSEEN
print('************* Map-Making on {} sub-map(s) (noiseless). Done *************'.format(nf_sub_rec))

rmc.save_simu_fits(maps_recon_noiseless, cov_noiseless, nus, nus_edge, maps_convolved_noiseless,
                  save_dir=save_dir, simu_name='noiseless' + simu_name)

```

# Compute residuals

```{python}
maps_recon, maps_convolved, maps_diff = rmc.get_maps(save_dir + simu_name)
maps_recon_noiseless, maps_convo_noiseless, maps_diff_noiseless = rmc.get_maps(save_dir + 'noiseless_' + simu_name)

maps_convolved[:, np.invert(seenmap), :] = 0.
maps_recon[:, np.invert(seenmap), :] = 0.
maps_diff[:, np.invert(seenmap), :] = 0.
maps_recon_noiseless[:, np.invert(seenmap), :] = 0.

residuals = maps_recon - maps_recon_noiseless
```

```{python}
hp.mollview(residuals[0, :, 0])
```

```{python}
# Look at IQU in one band
band = 0
plt.figure(figsize=(12, 10))
plt.subplots_adjust(wspace=0.4, hspace=0.7)
rr = 15
for istk in range(3):
    plt.subplots_adjust(wspace=0.9)
    hp.gnomview(maps_recon[band,:,istk], cmap ='jet', sub = (nf_sub_rec, 4, 4*istk+1), rot=center, reso=rr, 
                title = '{0} rec {1}'.format(d['kind'][istk], band))
    hp.gnomview(maps_convolved[band,:,istk], cmap ='jet', sub = (nf_sub_rec, 4, 4*istk+2), rot=center, reso=rr, 
                title = '{0} conv {1}'.format(d['kind'][istk], band))
    hp.gnomview(maps_diff[band,:,istk], cmap ='jet', sub = (nf_sub_rec, 4, 4*istk+3), rot=center, reso=rr, 
                title = '{0} diff {1}'.format(d['kind'][istk], band))
    hp.gnomview(residuals[band,:,istk], cmap ='jet', sub = (nf_sub_rec, 4, 4*istk+4), rot=center, reso=rr, 
                title = '{0} Residuals {1}'.format(d['kind'][istk], band))

```

```{python}
istk = 0
plt.figure(figsize=(12,10))
plt.subplots_adjust(wspace=0.4, hspace=0.7)
rr = 15
min = -200
max = 4000

for band in range(nf_sub_rec):
    plt.subplots_adjust(wspace=0.9)
    hp.gnomview(maps_recon[band,:,istk], cmap ='jet', sub = (nf_sub_rec, 4, 4*band+1), rot=center, reso=rr, 
                title = '{0} rec {1}'.format(d['kind'][istk], band))#, min=min, max=max)
    hp.gnomview(maps_convolved[band,:,istk], cmap ='jet', sub = (nf_sub_rec, 4, 4*band+2), rot=center, reso=rr, 
                title = '{0} conv {1}'.format(d['kind'][istk], band))#, min=min, max=max)
    hp.gnomview(maps_diff[band,:,istk], cmap ='jet', sub = (nf_sub_rec, 4, 4*band+3), rot=center, reso=rr, 
                title = '{0} diff {1}'.format(d['kind'][istk], band))
    hp.gnomview(residuals[band,:,istk], cmap ='jet', sub = (nf_sub_rec, 4, 4*band+4), rot=center, reso=rr, 
                title = '{0} Residuals {1}'.format(d['kind'][istk], band))


```

# Analysis

```{python}
_, nus_edges_rec, nus_rec, deltas_rec, _, _ = qubic.compute_freq(150, nf_sub_rec)

# seenmap = rmc.get_seenmap(save_dir + simu_name)
std_maps_recon_noiseless = np.std(maps_recon_noiseless[:, seenmap, 0], axis=(1))
plt.plot(nus_rec, std_maps_recon_noiseless * deltas_rec, label='recon noiseless')

std_maps_recon = np.std(maps_recon[:, seenmap, 0], axis=(1))
plt.plot(nus_rec, std_maps_recon * deltas_rec, label='recon')

std_maps_conv = np.std(maps_convolved[:, seenmap, 0], axis=(1))
plt.plot(nus_rec, std_maps_conv * deltas_rec, label='conv')

# plt.plot(nus_rec, np.sqrt(std_maps_recon**2 - std_maps_diff**2))

# plt.plot(nus_x0, std_maps_convx0 * deltas, label='x0 conv')

# plt.plot(nus_x0, std_x0*deltas, label='x0 full')
plt.legend()
plt.xlabel('Frequency [GHz]')
plt.ylabel('STD x $\delta$')
```

# Power spectrum

```{python}
# Create a Namaster object
lmin = 20
lmax = 3 * d['nside'] - 1
delta_ell = 16

Namaster = nam.Namaster(seenmap, lmin=lmin, lmax=lmax, delta_ell=delta_ell)

# Make a mask
mask_apo = Namaster.get_apodized_mask()

hp.mollview(mask_apo)
```

```{python}
seed = None
sky_config = {'cmb': seed}
Qubic_sky = qss.Qubic_sky(sky_config, d)
Qubic_sky.instrument['beams'] #= Qubic_sky.instrument['beams'][0]
```

```{python}
# Make an 2D array containing IQU maps, the shape must be (3, #pixels)
isub = 1

w = None
# Get spectra
leff, cells_recon, w = Namaster.get_spectra(maps_recon[isub, :, :].T, d, mask_apo, w=w,
                                      purify_e=False, 
                                      purify_b=True, 
                                      beam_correction=True,
                                      pixwin_correction=None)

leff, cells_conv, w = Namaster.get_spectra(maps_convolved[isub, :, :].T, d, mask_apo, w=w, 
                                      purify_e=False, 
                                      purify_b=True, 
                                      beam_correction=True,
                                      pixwin_correction=None)

leff, cells_x0, w = Namaster.get_spectra(x0[isub+10, :, :].T, d, mask_apo, w=w, 
                                      purify_e=False, 
                                      purify_b=True, 
                                      beam_correction=None,
                                      pixwin_correction=True)


```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']
# with plt.xkcd():
rc('figure', figsize=(12, 8))
plt.figure()
for i in range(4):
    plt.subplot(2, 2, i+1)
#     plt.plot(input_ell[2:], input_Dl[2:, i], 'k', label='Input')
    plt.plot(leff[2:], cells_recon[2:, i],'b', label='Recon')
    plt.plot(leff[2:], cells_x0[2:, i],'g', label='x0')
    plt.plot(leff[2:], cells_conv[2:, i], 'r', label='Conv')
    plt.xlabel('$\\ell$')
    plt.ylabel('$D_\\ell$')
    plt.title(clnames[i])
plt.tight_layout()
plt.legend()
```

## Make a fake sky
Old test

```{python}
def scaling_dust(freq1, freq2, sp_index=1.8): 
    '''
    Calculate scaling factor for dust contamination
    Frequencies are in GHz
    '''
    freq1 = float(freq1)
    freq2 = float(freq2)
    x1 = freq1 / 56.78
    x2 = freq2 / 56.78
    S1 = x1**2. * np.exp(x1) / (np.exp(x1) - 1)**2.
    S2 = x2**2. * np.exp(x2) / (np.exp(x2) - 1)**2.
    vd = 375.06 / 18. * 19.6
    scaling_factor_dust = (np.exp(freq1 / vd) - 1) / \
                          (np.exp(freq2 / vd) - 1) * \
                          (freq2 / freq1)**(sp_index + 1)
    scaling_factor_termo = S1 / S2 * scaling_factor_dust
    return scaling_factor_termo


def scaling_synchrotron(freq1, freq2, sp_index=-3): 
    '''
    Calculate scaling factor for synchrotron contamination
    Frequencies are in GHz
    '''
    x1 = freq1 / 56.78
    x2 = freq2 / 56.78
    S1 = x1**2. * np.exp(x1) / (np.exp(x1) - 1)**2.
    S2 = x2**2. * np.exp(x2) / (np.exp(x2) - 1)**2.
    vd = 375.06 / 18. * 19.6
    scaling_factor_synchrotron = S1 / S2 * (np.exp(freq1 / vd) - 1) / \
                                 (np.exp(freq2 / vd) - 1) * \
                                 (freq2 / freq1)**(sp_index + 1)
    return scaling_factor_synchrotron


def cmb_plus_dust_synchrotron(cmb, dust, synchrotron, d):
    '''
    Sum up clean CMB map with dust and synchrotron 
    using proper scaling coefficients
    '''
    nf_sub = d['nf_sub']
    _, _, nus, _, _, _ = qubic.compute_freq(150, nf_sub)
    print(nus)
    
    kind = d['kind']
    nstokes =  len(kind) #Number of stokes parameters used in the simu
    
    npix = 12 * d['nside']**2
    x0 = np.zeros((nf_sub, npix, 3))
    
    # Let's fill the maps:
    for i in range(nf_sub):
        for istokes in range(nstokes):
            if kind == 'QU': #This condition keeps the order IQU in the healpix map
                x0[i, :, istokes+1] = cmb[i, :, istokes+1] \
                                    + dust[i, :, istokes+1] * scaling_dust(150, nus[i])\
                                    + synchrotron[i, :, istokes+1] * scaling_synchrotron(150, nus[i])
            else:
                x0[i, :, istokes] = cmb[i, :, istokes] \
                                    + dust[i, :, istokes] * scaling_dust(150, nus[i], 1.59)\
                                    + synchrotron[i, :, istokes] * scaling_synchrotron(150, nus[i])
    return x0


def create_input_sky(d, skypars):
    Nf = int(d['nf_sub'])
    band = d['filter_nu']/1e9
    filter_relative_bandwidth = d['filter_relative_bandwidth']
    _, _, nus_in, _, _, Nbbands_in = qubic.compute_freq(band, filter_relative_bandwidth, Nf)
    # seed
    if d['seed']:
        np.random.seed(d['seed'])
        
        # Generate the input CMB map
        sp = qubic.read_spectra(skypars['r'])
        cmb = np.array(hp.synfast(sp, d['nside'], new=True, pixwin=True, verbose=False)).T
        
        # Generate the dust map
        coef = skypars['dust_coeff']
        ell = np.arange(1, 3*d['nside'])
        fact = (ell * (ell + 1)) / (2 * np.pi)
        spectra_dust = [np.zeros(len(ell)), 
                        coef * (ell / 80.)**(-0.42) / (fact * 0.52), 
                        coef * (ell / 80.)**(-0.42) / fact, 
                        np.zeros(len(ell))]
        dust = np.array(hp.synfast(spectra_dust, d['nside'], new=True, pixwin=True, verbose=False)).T
        
        # Combine CMB and dust. As output we have N 3-component maps of sky.
        x0 = cmb_plus_dust(cmb, dust, Nbbands_in, nus_in, d['kind'])
        return x0
```

```{python}
with plt.xkcd():
    plt.plot([1, 3, 4])
```

```{python}

```
