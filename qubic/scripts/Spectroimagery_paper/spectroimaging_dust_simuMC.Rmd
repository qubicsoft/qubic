---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# QUBIC spectroimaging

#### Louise Mousset, 2020/06/05


```{python}
# %matplotlib inline
from pylab import *
import os
import sys
import glob

# Specific science modules
import healpy as hp
import numpy as np

# Specific qubic modules
from qubicpack.utilities import Qubic_DataDir
from pysimulators import FitsArray
import pysm
import pysm.units as u

import qubic
from qubic import SpectroImLib as si
from qubic import QubicSkySim as qss
from qubic import NamasterLib as nam

from qubic import fibtools as ft

import ReadMC as rmc
import AnalysisMC as amc

rc('figure', figsize=(13, 10))
rc('font', size=15)
```

# Look at MC simulations

```{python}
# date_name = '20200415_galaxydust'
# date_name = '*_gal'

# # Get the repository where the simulation is
# rep_simu = Qubic_DataDir(datafile='*nfsub*'
#                          , datadir='/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/galaxy_center_d1') + '/'
# print(rep_simu)

rep = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/galaxy_center_d1/test_residuals/31347782/'
# rep = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/29712494/'
# rep = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/galaxy_center_d1/nfsub15/'
dictionary = glob.glob(rep + '/*.dict')[0]
print(dictionary)

# Dictionary saved during the simulation
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictionary)

# # Coordinates of the zone observed in the sky
center = qubic.equ2gal(d['RA_center'], d['DEC_center'])

# # Number of subbands used during the simulation
nf_sub_rec = 5
nf_sub = d['nf_sub']
print('nf_sub = {}, nf_recon = {}'.format(nf_sub, nf_sub_rec))

# Get fits files names in a list
fits_noise = np.sort(glob.glob(rep + '*_nfsub{}_nfrecon{}_noiselessFalse*.fits'.format(nf_sub, nf_sub_rec), 
                              recursive=True))
fits_noiseless = np.sort(glob.glob(rep + '*_nfsub{}_nfrecon{}_noiselessTrue*.fits'.format(nf_sub, nf_sub_rec), 
                              recursive=True))

print(len(fits_noise))
```

```{python}
d['synthbeam_kmax']
```

```{python}
# Number of noise realisations
nreals = len(fits_noise)
print('nreals = ', nreals)

# Get seen map (observed pixels)
seenmap = rmc.get_seenmap(fits_noiseless[0])
print(seenmap.shape)

# Number of pixels and nside
npix = len(seenmap)
ns = d['nside']

```

### Look at the maps

```{python}
# Get the noiseless map
noiseless, _, _ = rmc.get_maps(fits_noiseless[0])
# noiseless = np.expand_dims(noiseless, axis=0)
print(noiseless.shape)

# Get the noise maps
maps_recon = np.empty((nreals, nf_sub_rec, npix, 3))
maps_conv = np.empty((nreals, nf_sub_rec, npix, 3))
for real in range(nreals):
    recon, conv, _ = rmc.get_maps(fits_noise[real])
    maps_recon[real] = recon
    maps_conv[real] = conv

```

```{python}
# Compute residuals in a given way
date_name = 'gal'
residuals = amc.get_residuals(rep, 'noiseless', nf_sub_rec)
print(residuals.shape)

# There is only the patch so you need to put them in a full map to plot with healpy
maps_residuals = np.zeros_like(maps_conv)
maps_residuals[:, :, seenmap, :] = residuals
```

```{python}
istk = 0
real = 0
plt.figure(figsize=(12, 4))
plt.subplots_adjust(wspace=0.2, hspace=0.5)
plt.suptitle('JobID: ' + rep[-9: -1])
rr = 15
min = None
max = None

for band in range(nf_sub_rec):
#     hp.gnomview(maps_conv[real, band, :, istk], cmap='jet', sub=(nf_sub_rec, 3, 3*band+1), rot=center, reso=rr, 
#                 title = '{0} conv {1}'.format(d['kind'][istk], band), min=min, max=max)
#     hp.gnomview(maps_recon[real, band, :, istk], cmap='jet', sub=(nf_sub_rec, 3, 3*band+2), rot=center, reso=rr, 
#                 title = '{0} rec {1}'.format(d['kind'][istk], band), min=min, max=max)
    hp.gnomview(maps_residuals[real, band, :, istk], cmap='jet', sub=(1, nf_sub_rec, band+1), rot=center, reso=rr, 
                title = '{0} Residuals {1}'.format(d['kind'][istk], band), min=-70, max=70)
plt.tight_layout()

```

```{python}
# Get the coverage
from astropy.io import fits
a = fits.open(fits_noise[0])
coverage = a['COVERAGE'].data
hp.mollview(coverage)

coverage_patch = coverage[seenmap]
coverage_patch.shape
```

```{python}
ang = rmc.pix2ang(d['nside'], center, seenmap)
coverage_norm = coverage_patch / np.max(coverage_patch)
inverse_coverage = 1. / (np.sqrt(coverage_norm))

plt.plot(ang, coverage_norm, '.', label='coverage')
plt.plot(ang, np.sqrt(coverage_norm), '.', label='$\sqrt{coverage}$')
plt.xlabel('Angle [deg]')
# plt.ylabel('Coverage normalized')
plt.title('Coverage normalized to the maximum as function of the angle in the patch.')
plt.legend()
```

### Power spectrum

```{python}
# Create a Namaster object
lmin = 20
lmax = 2 * d['nside'] - 1
delta_ell = 20

mask = np.zeros(12 * d['nside']**2)
mask[seenmap] = 1

Namaster = nam.Namaster(mask, lmin=lmin, lmax=lmax, delta_ell=delta_ell)

# Make a mask
mask_apo = Namaster.get_apodized_mask()

# hp.mollview(mask_apo)


```

```{python}
# Auto spectrum
w = None
allcells_recon, allcells_recon_noiseless, allcells_conv, allcells_x0 = [], [], [], []
real = 0

# Get spectra
for isub in range(nf_sub_rec):
    leff, cells_recon, w = Namaster.get_spectra(maps_recon[real, isub, :, :].T, mask_apo, w=w,
                                          purify_e=True, 
                                          purify_b=False, 
                                          beam_correction=None,
                                          pixwin_correction=True)
    
    leff, cells_recon_noiseless, w = Namaster.get_spectra(noiseless[isub, :, :].T, mask_apo, w=w,
                                          purify_e=True, 
                                          purify_b=False, 
                                          beam_correction=None,
                                          pixwin_correction=True)

    leff, cells_conv, w = Namaster.get_spectra(maps_conv[real, isub, :, :].T, mask_apo, w=w, 
                                          purify_e=True, 
                                          purify_b=False, 
                                          beam_correction=None,
                                          pixwin_correction=True)

    allcells_recon.append(cells_recon)
    allcells_recon_noiseless.append(cells_recon_noiseless)
    allcells_conv.append(cells_conv)

allcells_recon = np.array(allcells_recon)
allcells_recon_noiseless = np.array(allcells_recon_noiseless)
allcells_conv = np.array(allcells_conv)
```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']
# with plt.xkcd():
rc('figure', figsize=(12, 8))

fig, axs = plt.subplots(2, 2)
axs = axs.ravel()

color = ['b', 'r', 'g', 'k', 'y', 'orange', 'brown', 'purple']
for i in range(4):
    ax = axs[i]
    for isub in range(nf_sub_rec): 
        c = color[isub]
#         ax.plot(input_ell[2:lmax], input_Dl[2:lmax, i], 'k', label='CMB Input')
        ax.plot(leff[:], allcells_recon[isub, :, i],'o', color=c, 
                 label='Recon {}'.format(isub))
        ax.plot(leff[:], allcells_recon_noiseless[isub, :, i],'--', color=c, 
                 label='Recon Noiseless{}'.format(isub))
#         ax.plot(leff[2:], allcells_x0[isub, 2:, i], color=c, 
#                  label='x0{}'.format(isub))
#         ax.plot(leff[:], allcells_conv[isub, :, i], '--', color=c, 
#                  label='Conv{}'.format(isub))
    ax.set_xlabel('$\\ell$')
    ax.set_ylabel('$D_\\ell$')

    ax.set_title(clnames[i])

plt.tight_layout()
ax.legend(fontsize=8, loc='right')
```

```{python}
from itertools import combinations
# Cross spectrum

nbins = (lmax - lmin) // delta_ell
# ncross = nreals * (nreals - 1) // 2
ncross = nreals // 2
print(nbins, ncross)
cells_cross = np.zeros((ncross, nf_sub_rec, nbins, 4))
cells_conv = np.zeros((ncross, nf_sub_rec, nbins, 4))

# Get spectra
w = None
for isub in range(nf_sub_rec):
    print('isub:', isub)
    cross = 0
#     for c in combinations(np.arange(5), 2):
    for c1 in range(0, nreals-1, 2): # do not mix pairs to avoid correlation 
        c2 = c1 + 1 
        c = (c1, c2)
        print(c)
        leff, cells_cross[cross, isub, :, :], w = Namaster.get_spectra(maps_recon[c[0], isub, :, :].T, 
                                              mask_apo, 
                                              maps_recon[c[1], isub, :, :].T,
                                              w=w,
                                              purify_e=True, 
                                              purify_b=False, 
                                              beam_correction=None,
                                              pixwin_correction=True)
        leff, cells_conv[cross, isub, :, :], w = Namaster.get_spectra(maps_conv[c[0], isub, :, :].T, 
                                              mask_apo,
                                              maps_conv[c[1], isub, :, :].T,
                                              w=w,
                                              purify_e=True, 
                                              purify_b=False, 
                                              beam_correction=None,
                                              pixwin_correction=True)
        
        cross += 1     
```

```{python}
# average over the cross_spectrum
cross_mean = np.mean(cells_cross, axis=0)
cross_std = np.std(cells_cross, axis=0)
print(cross_mean.shape)


mean_conv = np.mean(cells_conv, axis=0)

print(cells_cross[:, 0, 0, 0])
```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']
# with plt.xkcd():
rc('figure', figsize=(12, 8))

fig, axs = plt.subplots(2, 2)
axs = axs.ravel()

color = ['b', 'r', 'g', 'k', 'y', 'orange', 'brown', 'purple']
for i in range(4):
    ax = axs[i]
    for isub in range(0, 7, 2):
        c = color[isub]
        ax.errorbar(leff[:], cross_mean[isub, :, i],
                    yerr=cross_std[isub, :, i] * np.sqrt(2),
                    marker='o', color=c, linestyle='none', 
                    label='Recon cross {}'.format(isub))
        
        ax.plot(leff[:], allcells_recon_noiseless[isub, :, i],'--', 
                color=c,
                 label='Recon Noiseless{}'.format(isub))

#         ax.plot(leff[:], mean_conv[isub, :, i], '--', color=c, 
#                  label='Conv{}'.format(isub))
    ax.set_xlabel('$\\ell$')
    ax.set_ylabel('$D_\\ell$')
#     ax.set_yscale('log')
    ax.set_title(clnames[i])

plt.tight_layout()
# ax.legend(fontsize=8, loc='right')
```

## Correlations between bands

```{python}
# Make a loop over irec and fill dictionnaries
dict_sig2MC = {}
dict_sig2 = {}
ang_th = 15
ang = rmc.pix2ang(d['nside'], center, seenmap)

for irec in [1, 3, 5]:
    print('irec =', irec)   
#     _, recon_patch, _, _ = rmc.get_patch_many_files(rep_simu + date_name, '*nfrecon{}*False*'.format(irec))
    residuals = amc.get_residuals(rep, 'noiseless', irec)
    
    if irec == 1:
        # Remove the single dimension  
        residuals = np.squeeze(residuals)
        print('Residuals shape:', residuals.shape)

        sig2MC_monofreq = np.var(residuals, axis=0) # Variance over realizations
        sig2MCmean_monofreq = amc.average_pix_sig2(sig2MC_monofreq, ang, ang_threshold=ang_th) # Mean over pixels
        dict_sig2MC.update({'{}'.format(irec): sig2MC_monofreq})
        dict_sig2MC.update({'{}mean'.format(irec): sig2MCmean_monofreq})
        
        print('\n')
       
    else:
        if irec == 8:
            doplot = True
        else :
            doplot = False
        Cp = amc.get_Cp(residuals, nfrecon=d['nf_recon'], verbose=False, doplot=doplot)
        Cp_prime = amc.Cp2Cp_prime_viaCorr(Cp, verbose=True) # Average Cp over pixels
#         Cp_prime = amc.Cp2Cp_prime(Cp, verbose=True)
        
        # Compute sig2 and sig2MC 
        # Using Cp or Cp_prime
        weighted_av, sig2 = amc.make_weighted_av(residuals, Cp_prime, verbose=False)
        
        sig2mean = amc.average_pix_sig2(sig2, ang, ang_threshold=ang_th)
        dict_sig2.update({'{}'.format(irec): sig2})
        dict_sig2.update({'{}mean'.format(irec): sig2mean})
        
        sig2MC = np.var(weighted_av, axis=0) # Variance over realisations
        sig2MCmean = amc.average_pix_sig2(sig2MC, ang, ang_threshold=ang_th) # Mean over pixels
        dict_sig2MC.update({'{}'.format(irec): sig2MC})
        dict_sig2MC.update({'{}mean'.format(irec): sig2MCmean})
        
        print('\n')
```

```{python}
print(Cp_prime.shape)
plt.imshow(Cp_prime[:, :, 0, 10])
plt.colorbar()
```

```{python}
plt.plot(np.sqrt(coverage_norm), dict_sig2MC['5'][:, 0], '.')
plt.xlabel('$\sqrt{coverage}$')
plt.ylabel('$\sigma^2$')
limit = (coverage_patch / np.max(coverage_patch)) > 0.6
# plt.plot(dict_sig2['3'][limit, 0], dict_sig2MC['3'][limit, 0], '.')

plt.title('Variance for each pixel (I component)')
```

```{python}
import qubic.fibtools as ft

x = 1 / np.sqrt(coverage_norm)

xc, yc, dx, dy, _ = ft.profile(x, dict_sig2['8'][:, 0], 
                               nbins=30, 
                               plot=False,
                               clip=True)


xcMC, ycMC, dxMC, dyMC, _ = ft.profile(x, dict_sig2MC['8'][:, 0], 
                                       nbins=30, 
                                       plot=False,
                                       clip=True)

plt.errorbar(xc, yc, xerr=dx, yerr=dy, fmt='bo', label='$\sigma^2$')
plt.errorbar(xcMC, ycMC, xerr=dxMC, yerr=dyMC, fmt='ro', label='$\sigma^2 MC$')
# plt.plot(x, dict_sig2['3'][:, 1] , 'b,')
# plt.plot(x, dict_sig2MC['3'][:, 1] , 'r,')
plt.ylim(0, 100)

plt.xlabel('$1 / \sqrt{coverage}$', fontsize=15)
plt.ylabel('$\sigma^2$', fontsize=15)
plt.legend()
```

```{python}
plt.plot(xc, yc / ycMC)
plt.xlabel('$1 / \sqrt{coverage}$', fontsize=15)
plt.ylabel('$\sigma^2 / \sigma_{MC}^2$', fontsize=15)
```

```{python}
cov, corr = amc.get_covcorr_patch(residuals, stokesjoint=True, doplot=True)
```

```{python}
plt.imshow(cov[:, :, 5000])
plt.title('Covariance matrix for one pixel')
```

### Matrix Cp_prime in coverage bins

```{python}
irec = 8
residuals = amc.get_residuals(rep, 'noiseless', irec)
Cp = amc.get_Cp(residuals, nfrecon=d['nf_recon'], verbose=True, doplot=True)
```

```{python}
npix_patch = coverage_norm.shape[0]

step = 0.100001
for b in np.arange(0.1, 1, step):
    print(b, b + step)
    mybin = (coverage_norm > b) & (coverage_norm < b+step)
    npix_bin = np.sum(mybin)
    print('Npix in the bin:', npix_bin)

    Cp_primebin = amc.Cp2Cp_prime_viaCorr(Cp[:, :, :, mybin])
    
    plt.figure()
    plt.imshow(np.mean(Cp_primebin[:, :, 0, :], axis=2))
    plt.colorbar()
    plt.title('Cp_prime I bin coverage {} to {}'.format(b, b+step))

    weighted_avbin, sig2 = amc.make_weighted_av(residuals[:, :, mybin, :], Cp_primebin, verbose=False)
    print('sig2', sig2.shape)
    sig2MC = np.var(weighted_avbin, axis=0)
    if b == 0.1:
        sig2_bin = sig2
        sig2MC_bin = sig2MC
    else:
        sig2_bin = np.concatenate((sig2_bin, sig2))
        sig2MC_bin = np.concatenate((sig2MC_bin, sig2MC))

```

```{python}
x = 1 / np.sqrt(coverage_norm)

xc_bin, yc_bin, dx_bin, dy_bin, _ = ft.profile(x, sig2_bin[:, 0], 
                               nbins=30, 
                               plot=False,
                               clip=True)


xcMC_bin, ycMC_bin, dxMC_bin, dyMC_bin, _ = ft.profile(x, sig2MC_bin[:, 0], 
                                       nbins=30, 
                                       plot=False,
                                       clip=True)

plt.errorbar(xc_bin, yc_bin, xerr=dx_bin, yerr=dy_bin, fmt='bo', label='$\sigma^2$')
plt.errorbar(xcMC_bin, ycMC_bin, xerr=dxMC_bin, yerr=dyMC_bin, fmt='ro', label='$\sigma^2 MC$')
# plt.plot(x, dict_sig2['3'][:, 1] , 'b,')
# plt.plot(x, dict_sig2MC['3'][:, 1] , 'r,')
# plt.ylim(0, 100)

plt.xlabel('$1 / \sqrt{coverage}$', fontsize=15)
plt.ylabel('$\sigma^2$', fontsize=15)
plt.legend()
plt.title('Profile, Weighted average done in 9 coverage bins')
```

```{python}
plt.plot(xc_bin, yc_bin / ycMC_bin)
plt.xlabel('$1 / \sqrt{coverage}$', fontsize=15)
plt.ylabel('$\sigma^2 / \sigma_{MC}^2$', fontsize=15)
plt.title('Ratio, Weighted average done in 9 coverage bins')
```

```{python}
np.mean(yc_bin / ycMC_bin)
```

```{python}

```
