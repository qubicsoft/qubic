---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# QUBIC spectroimaging

#### Louise Mousset, 2020/06/05

This notebook look at maps produced by a full pipeline simulations with severals noise realisations and make the Cls power spectra. 

```{python}
# %matplotlib inline
from pylab import *
import os
import sys
import glob

# Specific science modules
import healpy as hp
import numpy as np
from astropy.io import fits

# Specific qubic modules
from qubicpack.utilities import Qubic_DataDir
from pysimulators import FitsArray
import pysm
import pysm.units as u

import qubic
from qubic import SpectroImLib as si
from qubic import QubicSkySim as qss
from qubic import NamasterLib as nam
from qubic.polyacquisition import compute_freq

from qubic import fibtools as ft

import ReadMC as rmc
import AnalysisMC as amc

rc('figure', figsize=(13, 10))
rc('font', size=15)
```

```{python}
import matplotlib.colors as mcolors
mcolors.TABLEAU_COLORS.keys()

colorlist = list(mcolors.TABLEAU_COLORS.keys())
```

## Choose a simulation

```{python}
# Get the files
# rep = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/galaxy_center_d1/test_residuals/31613089/'
# rep = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/29712494/'
nfrecon = 3

rep = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/galaxy_center_d1/nfrecon{}/'.format(nfrecon)
dictionary = glob.glob(rep + '/*.dict')[0]
print(dictionary)

# Dictionary saved during the simulation
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictionary)

# Coordinates of the zone observed in the sky
center = qubic.equ2gal(d['RA_center'], d['DEC_center'])

# Number of subbands used during the simulation

nfsub = d['nf_sub']
print('nf_sub = {}, nf_recon = {}'.format(nfsub, nfrecon))

# Get fits files names in a list
fits_noise = np.sort(glob.glob(rep + '*_nfsub{}_nfrecon{}_noiselessFalse*.fits'.format(nfsub, nfrecon), 
                              recursive=True))
fits_noiseless = np.sort(glob.glob(rep + '*_nfsub{}_nfrecon{}_noiselessTrue*.fits'.format(nfsub, nfrecon), 
                              recursive=True))

print(fits_noiseless)
```

```{python}
# Frequencies of the reconstructed subbands
Nfreq_edges, nus_edge, nus, deltas, Delta, Nbbands = compute_freq(150, nfrecon)
print(nus)
```

```{python}
# Number of noise realisations
nreals = len(fits_noise)
print('nreals = ', nreals)

# Get seen map (observed pixels)
seenmap = rmc.get_seenmap(fits_noiseless[0])
print('seenmap shape:', seenmap.shape)

# Number of pixels and nside
npix = len(seenmap)
ns = d['nside']

```

### Look at the maps

```{python}
# Get the noiseless map
noiseless, _, _ = rmc.get_maps(fits_noiseless[0])
# noiseless = np.expand_dims(noiseless, axis=0)
print(noiseless.shape)

# Get the noise maps
maps_recon = np.empty((nreals, nfrecon, npix, 3))
maps_conv = np.empty((nreals, nfrecon, npix, 3))
for i, real in enumerate(fits_noise):
    maps_recon[i], maps_conv[i], _ = rmc.get_maps(real)

```

```{python}
# Compute residuals in a given way
residuals = amc.get_residuals(fits_noise, fits_noiseless[0], 'noiseless')
print(residuals.shape)

# There is only the patch so you need to put them in a full map to plot with healpy
maps_residuals = np.ones_like(maps_conv) * hp.UNSEEN
maps_residuals[:, :, seenmap, :] = residuals

```

```{python}
istk = 0
real = 4
plt.figure(figsize=(12, 20))
plt.subplots_adjust(wspace=0.2, hspace=0.5)
# plt.suptitle('JobID: ' + rep[-9: -1])
rr = 15
min = 0
max = 5000

for band in range(nfrecon):
    hp.gnomview(maps_conv[real, band, :, istk], cmap='jet', sub=(nfrecon, 3, 3*band+1), 
                rot=center, reso=rr, notext=True,
                title = '{} conv'.format(d['kind'][istk]), min=min, max=max)
    plt.text(-0.8,0, '{:3.0f} GHz'.format(nus[band]))
    hp.gnomview(maps_recon[real, band, :, istk], cmap='jet', sub=(nfrecon, 3, 3*band+2), 
                rot=center, reso=rr, notext=True,
                title = '{0} rec'.format(d['kind'][istk]), min=min, max=max)
    hp.gnomview(maps_residuals[real, band, :, istk], cmap='jet', sub=(nfrecon, 3, 3*band+3), 
                rot=center, reso=rr, notext=True,
                title = '{0} Residuals'.format(d['kind'][istk]), min=-70, max=70)
plt.tight_layout()

```

#### Difference between mean_recon and noiseless

We expect they are equal but in some simulation they are not. Maybe because of a convergence issue.

```{python}
band = 0
istk = 0
toto = np.zeros_like(noiseless)
toto[:, seenmap, :] = np.mean(maps_recon[:, :, seenmap, :], axis=0) - noiseless[:, seenmap, :]
hp.gnomview(np.mean(maps_recon, axis=0)[band, :, istk], cmap='jet', sub=(131), 
                rot=center, reso=rr, notext=True, min=0, max=5000,
                title = 'Mean_recon')
hp.gnomview(noiseless[band, :, istk], cmap='jet', sub=(132), 
                rot=center, reso=rr, notext=True, min=0, max=5000,
                title = 'Noiseless')
hp.gnomview(toto[band, :, istk], cmap='jet', sub=(133), 
                rot=center, reso=rr, notext=True, min=-70, max=70,
                title = 'Mean_recon - Noiseless')
```

## Coverage

```{python}
fitsfile = fits.open(fits_noise[0])
coverage = fitsfile['COVERAGE'].data
hp.mollview(coverage)

coverage_patch = coverage[seenmap]
coverage_patch.shape
```

```{python}
ang = rmc.pix2ang(d['nside'], center, seenmap)
coverage_norm = coverage_patch / np.max(coverage_patch)
inverse_coverage = 1. / (np.sqrt(coverage_norm))

plt.plot(ang, coverage_norm, '.', label='coverage')
plt.plot(ang, np.sqrt(coverage_norm), '.', label='$\sqrt{coverage}$')
plt.xlabel('Angle [deg]')
# plt.ylabel('Coverage normalized')
plt.title('Coverage normalized to the maximum as function of the angle in the patch.')
plt.legend()
```

## Power spectrum

```{python}
# Create a Namaster object
lmin = 40
lmax = 2 * d['nside'] - 1
delta_ell = 30
print('lmin', lmin)
print('lmax', lmax)
print('delta ell', delta_ell)

mask = np.zeros(12 * d['nside']**2)
mask[seenmap] = 1

Namaster = nam.Namaster(mask, lmin=lmin, lmax=lmax, delta_ell=delta_ell)

# Make a mask
mask_apo = Namaster.get_apodized_mask()
# hp.mollview(mask_apo)

# Binning
ell_binned, b = Namaster.get_binning(d['nside'])
nbins = len(ell_binned)
print('nbins:', nbins)
print('ell binned:', ell_binned)


```

### Auto spectrum

```{python}
toto = [True, False]
np.invert(toto)
```

```{python}
w = None
real = 0

cls_recon = np.zeros((nfrecon, nbins, 4))
cls_recon_nl = np.zeros_like(cls_recon)
cls_conv = np.zeros_like(cls_recon)
# Get spectra
for isub in range(nfrecon):
    leff, cls_recon[isub, :, :], w = Namaster.get_spectra(maps_recon[real, isub, :, :].T, mask_apo, w=w,
                                          purify_e=True, 
                                          purify_b=False, 
                                          beam_correction=None,
                                          pixwin_correction=True)
    
    leff, cls_recon_nl[isub, :, :], w = Namaster.get_spectra(noiseless[isub, :, :].T, mask_apo, w=w,
                                          purify_e=True, 
                                          purify_b=False, 
                                          beam_correction=None,
                                          pixwin_correction=True)

    leff, cls_conv[isub, :, :], w = Namaster.get_spectra(maps_conv[real, isub, :, :].T, mask_apo, w=w, 
                                          purify_e=True, 
                                          purify_b=False, 
                                          beam_correction=None,
                                          pixwin_correction=True)

```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']

rc('figure', figsize=(12, 8))

fig, axs = plt.subplots(2, 2)
axs = axs.ravel()

for i in range(4):
    ax = axs[i]
    for isub in range(nfrecon): 
        c = colorlist[isub]
        ax.plot(leff[:], 
                cls_recon[isub, :, i],
                'o', 
                color=c, 
                label='Recon {}'.format(isub))
        ax.plot(leff[:], 
                cls_recon_nl[isub, :, i],
                '--', 
                color=c, 
                label='Recon Noiseless {}'.format(isub))
        ax.plot(leff[:], cls_conv[isub, :, i], '+', color=c, 
                 label='Conv {}'.format(isub))
    ax.set_xlabel('$\\ell$')
    ax.set_ylabel('$D_\\ell$')

    ax.set_title(clnames[i])

plt.tight_layout()
ax.legend(fontsize=8, loc='right')
```

### Cross spectrum

This will remove the noise bias. We only do cross spectrum between independant pairs in order to avoid corelations. So we only have nreals/2 cross spectra.

```{python}
# from itertools import combinations
# ncross = nreals * (nreals - 1) // 2

ncross = nreals // 2
print('ncross:', ncross)
print('nbins:', nbins)

cls_cross_recon = np.zeros((ncross, nfrecon, nbins, 4))
cls_cross_conv = np.zeros_like(cls_cross_recon)

# Get spectra
w = None
for isub in range(nfrecon):
    print('isub:', isub)
    cross = 0
    for c1 in range(0, nreals-1, 2):
        c2 = c1 + 1 
        c = (c1, c2)
        print(c)
        leff, cls_cross_recon[cross, isub, :, :], w = Namaster.get_spectra(maps_recon[c[0], isub, :, :].T, 
                                              mask_apo, 
                                              maps_recon[c[1], isub, :, :].T,
                                              w=w,
                                              purify_e=True, 
                                              purify_b=False, 
                                              beam_correction=None,
                                              pixwin_correction=True)
        leff, cls_cross_conv[cross, isub, :, :], w = Namaster.get_spectra(maps_conv[c[0], isub, :, :].T, 
                                              mask_apo,
                                              maps_conv[c[1], isub, :, :].T,
                                              w=w,
                                              purify_e=True, 
                                              purify_b=False, 
                                              beam_correction=None,
                                              pixwin_correction=True)
        
        cross += 1     
```

```{python}
# average over the cross_spectrum
cross_mean_recon = np.mean(cls_cross_recon, axis=0)
cross_std_recon = np.std(cls_cross_recon, axis=0)

cross_mean_conv = np.mean(cls_cross_conv, axis=0)

print(cells_cross[:, 0, 0, 0])
```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']
rc('figure', figsize=(12, 8))

fig, axs = plt.subplots(2, 2)
axs = axs.ravel()

for i in range(4):
    ax = axs[i]
    for isub in range(nfrecon):
        c = colorlist[isub]
        ax.errorbar(leff[:], cross_mean_recon[isub, :, i],
                    yerr=cross_std_recon[isub, :, i] * np.sqrt(2),
                    marker='o', color=c, linestyle='none', 
                    label='Recon cross {}'.format(isub))
        
        ax.plot(leff[:], cls_recon_nl[isub, :, i],'--', 
                color=c,
                label='Recon Noiseless {}'.format(isub))

        ax.plot(leff[:], cross_mean_conv[isub, :, i], '--', color=c, 
                 label='Conv {}'.format(isub))
    ax.set_xlabel('$\\ell$')
    ax.set_ylabel('$D_\\ell$')
#     ax.set_yscale('log')
    ax.set_title(clnames[i])
    ax.legend(fontsize=8, loc='right')

plt.tight_layout()

```

### Cross spectrum on the residuals

We expect them to be 0.

```{python}
ncross = nreals // 2
print('ncross:', ncross)
print('nbins:', nbins)
cls_cross_residuals = np.zeros((ncross, nfrecon, nbins, 4))

# Get spectra
w = None
for isub in range(nfrecon):
    print('isub:', isub)
    cross = 0
    for c1 in range(0, nreals-1, 2): # do not mix pairs to avoid correlation 
        c2 = c1 + 1 
        c = (c1, c2)
        print(c)
        map1 = maps_residuals[c[0], isub, :, :]
        map2 = maps_residuals[c[1], isub, :, :]
        leff, cls_cross_residuals[cross, isub, :, :], w = Namaster.get_spectra(map1.T, 
                                              mask_apo, 
                                              map2.T,
                                              w=w,
                                              purify_e=True, 
                                              purify_b=False, 
                                              beam_correction=None,
                                              pixwin_correction=True)
       
        cross += 1     
```

```{python}
# Save cross spectres
cls_cross_residuals.shape
rep_save = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/cls_spectrum_fullpipelinesimu/'

np.save(rep_save + 'cross_residuals_nfrecon{}.npy'.format(nfrecon), cls_cross_residuals)
```

```{python}
# Load cross spectres
# nfrecon = 1
# cls_cross_residuals = np.load(rep_save + 'cross_residuals_nfrecon{}.npy'.format(nfrecon))
```

```{python}
# average over the cross_spectrum
cross_mean_residuals = np.mean(cls_cross_residuals, axis=0)
cross_std_residuals = np.std(cls_cross_residuals, axis=0)
```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']
rc('figure', figsize=(12, 8))

fig, axs = plt.subplots(2, 2)
axs = axs.ravel()

for i in range(4):
    ax = axs[i]
    for isub in range(nfrecon):
        c = color[isub]
        ax.errorbar(leff[:], 
                cross_mean_residuals[isub, :, i],
                yerr=cross_std_residuals[isub, :, i] * np.sqrt(2),
                marker='o', color=colorlist[isub], linestyle='none', 
                label='Recon cross {}'.format(isub))


    ax.set_xlabel('$\\ell$')
    ax.set_ylabel('$D_\\ell$')
#     ax.set_yscale('log')
    ax.set_title(clnames[i])
    ax.legend(fontsize=8, loc='best')

plt.tight_layout()

```

```{python}

```
