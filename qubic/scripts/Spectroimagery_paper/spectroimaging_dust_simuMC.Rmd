---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.0
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# QUBIC spectroimaging

#### Louise Mousset, 2020/06/05


```{python}
# %matplotlib inline
from pylab import *
import os
import sys
import glob

# Specific science modules
import healpy as hp
import numpy as np
from astropy.io import fits

# Specific qubic modules
from qubicpack.utilities import Qubic_DataDir
from pysimulators import FitsArray
import pysm
import pysm.units as u

import qubic
from qubic import SpectroImLib as si
from qubic import QubicSkySim as qss
from qubic import NamasterLib as nam
from qubic.polyacquisition import compute_freq

from qubic import fibtools as ft

import ReadMC as rmc
import AnalysisMC as amc

rc('figure', figsize=(13, 10))
rc('font', size=15)
```

## Choose a simulation

```{python}
# Get the files
# rep = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/galaxy_center_d1/test_residuals/31613089/'
# rep = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/29712494/'
nfrecon = 3

rep = '/home/lmousset/QUBIC/Qubic_work/SpectroImagerie/paper_simu/galaxy_center_d1/nfrecon{}/'.format(nfrecon)
dictionary = glob.glob(rep + '/*.dict')[0]
print(dictionary)

# Dictionary saved during the simulation
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictionary)

# Coordinates of the zone observed in the sky
center = qubic.equ2gal(d['RA_center'], d['DEC_center'])

# Number of subbands used during the simulation

nfsub = d['nf_sub']
print('nf_sub = {}, nf_recon = {}'.format(nfsub, nfrecon))

# Get fits files names in a list
fits_noise = np.sort(glob.glob(rep + '*_nfsub{}_nfrecon{}_noiselessFalse*.fits'.format(nfsub, nfrecon), 
                              recursive=True))
fits_noiseless = np.sort(glob.glob(rep + '*_nfsub{}_nfrecon{}_noiselessTrue*.fits'.format(nfsub, nfrecon), 
                              recursive=True))

print(fits_noiseless)
```

```{python}
# Frequencies of the reconstructed subbands
Nfreq_edges, nus_edge, nus, deltas, Delta, Nbbands = compute_freq(150, nfrecon)
print(nus)
```

```{python}
# Number of noise realisations
nreals = len(fits_noise)
print('nreals = ', nreals)

# Get seen map (observed pixels)
seenmap = rmc.get_seenmap(fits_noiseless[0])
print(seenmap.shape)

# Number of pixels and nside
npix = len(seenmap)
ns = d['nside']

```

### Look at the maps

```{python}
# Get the noiseless map
noiseless, _, _ = rmc.get_maps(fits_noiseless[0])
# noiseless = np.expand_dims(noiseless, axis=0)
print(noiseless.shape)

# Get the noise maps
maps_recon = np.empty((nreals, nfrecon, npix, 3))
maps_conv = np.empty((nreals, nfrecon, npix, 3))
for i, real in enumerate(fits_noise):
    maps_recon[i], maps_conv[i], _ = rmc.get_maps(real)

```

```{python}
# Compute residuals in a given way
residuals = amc.get_residuals(fits_noise, fits_noiseless[0], 'noiseless')
print(residuals.shape)

# There is only the patch so you need to put them in a full map to plot with healpy
maps_residuals = np.ones_like(maps_conv) * hp.UNSEEN
maps_residuals[:, :, seenmap, :] = residuals

```

```{python}
istk = 0
real = 4
plt.figure(figsize=(12, 20))
plt.subplots_adjust(wspace=0.2, hspace=0.5)
# plt.suptitle('JobID: ' + rep[-9: -1])
rr = 15
min = 0
max = 5000

for band in range(nfrecon):
    hp.gnomview(maps_conv[real, band, :, istk], cmap='jet', sub=(nfrecon, 3, 3*band+1), 
                rot=center, reso=rr, notext=True,
                title = '{} conv'.format(d['kind'][istk]), min=min, max=max)
    plt.text(-0.8,0, '{:3.0f} GHz'.format(nus[band]))
    hp.gnomview(maps_recon[real, band, :, istk], cmap='jet', sub=(nfrecon, 3, 3*band+2), 
                rot=center, reso=rr, notext=True,
                title = '{0} rec'.format(d['kind'][istk]), min=min, max=max)
    hp.gnomview(maps_residuals[real, band, :, istk], cmap='jet', sub=(nfrecon, 3, 3*band+3), 
                rot=center, reso=rr, notext=True,
                title = '{0} Residuals'.format(d['kind'][istk]), min=-70, max=70)
plt.tight_layout()

```

```{python}
band = 0
istk = 0
toto = np.zeros_like(noiseless)
toto[:, seenmap, :] = np.mean(maps_recon[:, :, seenmap, :], axis=0) - noiseless[:, seenmap, :]
hp.gnomview(np.mean(maps_recon, axis=0)[band, :, istk], cmap='jet', sub=(131), 
                rot=center, reso=rr, notext=True, min=0, max=5000,
                title = 'Mean_recon')
hp.gnomview(noiseless[band, :, istk], cmap='jet', sub=(132), 
                rot=center, reso=rr, notext=True, min=0, max=5000,
                title = 'Noiseless')
hp.gnomview(toto[band, :, istk], cmap='jet', sub=(133), 
                rot=center, reso=rr, notext=True, min=-20, max=20,
                title = 'Mean_recon - Noiseless')
```

## Coverage

```{python}
fitsfile = fits.open(fits_noise[0])
coverage = fitsfile['COVERAGE'].data
hp.mollview(coverage)

coverage_patch = coverage[seenmap]
coverage_patch.shape
```

```{python}
ang = rmc.pix2ang(d['nside'], center, seenmap)
coverage_norm = coverage_patch / np.max(coverage_patch)
inverse_coverage = 1. / (np.sqrt(coverage_norm))

plt.plot(ang, coverage_norm, '.', label='coverage')
plt.plot(ang, np.sqrt(coverage_norm), '.', label='$\sqrt{coverage}$')
plt.xlabel('Angle [deg]')
# plt.ylabel('Coverage normalized')
plt.title('Coverage normalized to the maximum as function of the angle in the patch.')
plt.legend()
```

### Power spectrum

```{python}
# Create a Namaster object
lmin = 20
lmax = 2 * d['nside'] - 1
delta_ell = 20

mask = np.zeros(12 * d['nside']**2)
mask[seenmap] = 1

Namaster = nam.Namaster(mask, lmin=lmin, lmax=lmax, delta_ell=delta_ell)

# Make a mask
mask_apo = Namaster.get_apodized_mask()

# hp.mollview(mask_apo)


```

```{python}
# Auto spectrum
w = None
allcells_recon, allcells_recon_noiseless, allcells_conv, allcells_x0 = [], [], [], []
real = 0

# Get spectra
for isub in range(nf_sub_rec):
    leff, cells_recon, w = Namaster.get_spectra(maps_recon[real, isub, :, :].T, mask_apo, w=w,
                                          purify_e=True, 
                                          purify_b=False, 
                                          beam_correction=None,
                                          pixwin_correction=True)
    
    leff, cells_recon_noiseless, w = Namaster.get_spectra(noiseless[isub, :, :].T, mask_apo, w=w,
                                          purify_e=True, 
                                          purify_b=False, 
                                          beam_correction=None,
                                          pixwin_correction=True)

    leff, cells_conv, w = Namaster.get_spectra(maps_conv[real, isub, :, :].T, mask_apo, w=w, 
                                          purify_e=True, 
                                          purify_b=False, 
                                          beam_correction=None,
                                          pixwin_correction=True)

    allcells_recon.append(cells_recon)
    allcells_recon_noiseless.append(cells_recon_noiseless)
    allcells_conv.append(cells_conv)

allcells_recon = np.array(allcells_recon)
allcells_recon_noiseless = np.array(allcells_recon_noiseless)
allcells_conv = np.array(allcells_conv)
```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']
# with plt.xkcd():
rc('figure', figsize=(12, 8))

fig, axs = plt.subplots(2, 2)
axs = axs.ravel()

color = ['b', 'r', 'g', 'k', 'y', 'orange', 'brown', 'purple']
for i in range(4):
    ax = axs[i]
    for isub in range(nf_sub_rec): 
        c = color[isub]
#         ax.plot(input_ell[2:lmax], input_Dl[2:lmax, i], 'k', label='CMB Input')
        ax.plot(leff[:], allcells_recon[isub, :, i],'o', color=c, 
                 label='Recon {}'.format(isub))
        ax.plot(leff[:], allcells_recon_noiseless[isub, :, i],'--', color=c, 
                 label='Recon Noiseless{}'.format(isub))
#         ax.plot(leff[2:], allcells_x0[isub, 2:, i], color=c, 
#                  label='x0{}'.format(isub))
#         ax.plot(leff[:], allcells_conv[isub, :, i], '--', color=c, 
#                  label='Conv{}'.format(isub))
    ax.set_xlabel('$\\ell$')
    ax.set_ylabel('$D_\\ell$')

    ax.set_title(clnames[i])

plt.tight_layout()
ax.legend(fontsize=8, loc='right')
```

```{python}
from itertools import combinations
# Cross spectrum

nbins = (lmax - lmin) // delta_ell
# ncross = nreals * (nreals - 1) // 2
ncross = nreals // 2
print(nbins, ncross)
cells_cross = np.zeros((ncross, nf_sub_rec, nbins, 4))
cells_conv = np.zeros((ncross, nf_sub_rec, nbins, 4))

# Get spectra
w = None
for isub in range(nf_sub_rec):
    print('isub:', isub)
    cross = 0
#     for c in combinations(np.arange(5), 2):
    for c1 in range(0, nreals-1, 2): # do not mix pairs to avoid correlation 
        c2 = c1 + 1 
        c = (c1, c2)
        print(c)
        leff, cells_cross[cross, isub, :, :], w = Namaster.get_spectra(maps_recon[c[0], isub, :, :].T, 
                                              mask_apo, 
                                              maps_recon[c[1], isub, :, :].T,
                                              w=w,
                                              purify_e=True, 
                                              purify_b=False, 
                                              beam_correction=None,
                                              pixwin_correction=True)
        leff, cells_conv[cross, isub, :, :], w = Namaster.get_spectra(maps_conv[c[0], isub, :, :].T, 
                                              mask_apo,
                                              maps_conv[c[1], isub, :, :].T,
                                              w=w,
                                              purify_e=True, 
                                              purify_b=False, 
                                              beam_correction=None,
                                              pixwin_correction=True)
        
        cross += 1     
```

```{python}
# average over the cross_spectrum
cross_mean = np.mean(cells_cross, axis=0)
cross_std = np.std(cells_cross, axis=0)
print(cross_mean.shape)


mean_conv = np.mean(cells_conv, axis=0)

print(cells_cross[:, 0, 0, 0])
```

```{python}
clnames = ['TT', 'EE', 'BB', 'TE']
# with plt.xkcd():
rc('figure', figsize=(12, 8))

fig, axs = plt.subplots(2, 2)
axs = axs.ravel()

color = ['b', 'r', 'g', 'k', 'y', 'orange', 'brown', 'purple']
for i in range(4):
    ax = axs[i]
    for isub in range(0, 7, 2):
        c = color[isub]
        ax.errorbar(leff[:], cross_mean[isub, :, i],
                    yerr=cross_std[isub, :, i] * np.sqrt(2),
                    marker='o', color=c, linestyle='none', 
                    label='Recon cross {}'.format(isub))
        
        ax.plot(leff[:], allcells_recon_noiseless[isub, :, i],'--', 
                color=c,
                 label='Recon Noiseless{}'.format(isub))

#         ax.plot(leff[:], mean_conv[isub, :, i], '--', color=c, 
#                  label='Conv{}'.format(isub))
    ax.set_xlabel('$\\ell$')
    ax.set_ylabel('$D_\\ell$')
#     ax.set_yscale('log')
    ax.set_title(clnames[i])

plt.tight_layout()
# ax.legend(fontsize=8, loc='right')
```
