---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
from __future__ import division, print_function
import glob
import os
import healpy as hp
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rc

import ReadMC as rmc
import AnalysisMC as amc

import qubic
from qubic import equ2gal

from qubicpack.utilities import Qubic_DataDir

# %matplotlib inline
rc({'cmap', 'viridis'})
plt.rcParams['figure.figsize'] = (8, 8)

```

***
# Get the simulation files

```{python}
# Simulation date and name
#date_name = simu220[0]
date_name = 'NERSC_runs/24334789/20190903_low_nep'

# Get the repository where the simulation is
rep_simu = Qubic_DataDir(datafile=date_name + '.dict') + '/'
print('rep_simu : ', rep_simu)

# Dictionary saved during the simulation
d = qubic.qubicdict.qubicDict()
d.read_from_file(rep_simu + date_name + '.dict')
```

***
### Number of subbands, NEP and Ptg

```{python}
nf_recon = d['nf_recon']
print('nf_recon', nf_recon)

nep = d['detector_nep']
print('NEP = ', nep)

ptg = d['npointings']
print('ptg = ', ptg)

filter_nu = d['filter_nu']
print('Freq =', filter_nu)

center = equ2gal(d['RA_center'], d['DEC_center'])
stokes = ['I', 'Q', 'U']

```

***
## Choose a number of reconstructed subbands

```{python}
nfrec = 4
index_frec = nf_recon.index(nfrec)
print('index_frec = ', index_frec)
```

## Get full maps
analysis with noise


```{python}
# Remember: get_patch_many_file do seen_map + read each map
files, maps_recon, maps_conv, maps_diff = \
rmc.get_patch_many_files(rep_simu + date_name, '*nfrecon{}*True*'.format(nfrec))

print('Shape maps: {}, Tolerance: {}, NEP: {}, pointings: {}'.format(
    maps_recon.shape, d['tol'], d['detector_nep'], d['npointings'] ))

setpar = {'tol':d['tol'], 'nep':d['detector_nep'], 'npoint':d['npointings']}
```

***
Make noisereal for maps_diff with a random mean

```{python}
npix_patch = maps_recon.shape[2]
nreals = 5
nfreq = maps_recon.shape[1]

noisereal = np.zeros((nreals,nfreq,npix_patch,3))
noisereal = np.random.normal(np.mean(maps_diff)*3, np.std(maps_diff), size = noisereal.shape)

maps_real = maps_diff + noisereal

covariance, _ = amc.get_covcorr_patch(maps_real, stokesjoint=True, doplot=True)

full_matrix = np.empty((nfreq, nfreq, 3, npix_patch))
for istokes in range(3):
    full_matrix[:, :, istokes, :] = covariance[istokes*nfreq:(istokes+1)*nfreq, istokes*nfreq:(istokes+1)*nfreq, :]
```

```{python}
pr = np.empty((nreals, npix_patch, 3))
sig2pr = np.empty((npix_patch, 3))

for ireal in range(nreals):
    for ipix in range(npix_patch):
        for istokes in range(3):
            x = maps_real[ireal, :, ipix, istokes]
            # Only do it if the matrix is not singular...
            if np.linalg.det(full_matrix[:, :, istokes, ipix])!=0.:
                pr[ireal, ipix, istokes], sig2pr[ipix, istokes] = amc.get_weighted_correlation_average(x, 
                                                                        full_matrix[:, :, istokes, ipix])

sig2MC = np.var(pr, axis=0)
sig2MC.shape
```

***
#### Generate correlated noise

```{python}
#Generate correlated noise
corr_mat = np.zeros((npix_patch,npix_patch))
rho = np.arange(npix_patch)

def noise(rho, npix):
    return -rho/npix+1

for j in range(npix_patch):
    corr_mat[j,:] = np.roll(noise(rho,npix_patch), j)

plt.imshow(corr_mat)

from scipy.linalg import cholesky
upp_mat = cholesky(corr_mat)
#plt.plot(corr_mat[1000,:])

```

```{python}
cov_pix = np.empty((npix_patch, npix_patch, 3))
plt.figure(figsize=(12,12))

#Average over realizations
for istokes in range(3):
    cov_pix[:, :, istokes] = np.cov(pr[:, :, istokes], rowvar=False)
    if istokes == 0: 
        aab= cov_pix[:,:,istokes] 
        aab = aab @ upp_mat
        cov_pix[:,:,istokes]=aab
    plt.subplot(1, 3, istokes+1)
    plt.imshow(cov_pix[:, :, istokes])
```

***


```{python}
from scipy.stats import pearsonr

corr_0_1 , _ = pearsonr(cov_pix[0,0], cov_pix[0,-1])
print(corr_0_1)
```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```
