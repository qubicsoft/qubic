---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
from __future__ import division, print_function
import glob
import os
import healpy as hp
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rc

import ReadMC as rmc
import AnalysisMC as amc

import qubic
from qubic import equ2gal

from qubicpack.utilities import Qubic_DataDir

from scipy.stats import pearsonr
from scipy.linalg import cholesky

# %matplotlib inline
rc({'cmap', 'viridis'})
plt.rcParams['figure.figsize'] = (5, 5)

```

# Noisy maps with no correlations

```{python}
nside = 8
npix = 12 * nside**2
nfrec = 8
x0 = np.random.random((nfrec, npix, 3))

x0_mean = np.mean(x0)
x0_std = np.std(x0)

# Make many realizations with gaussian noise (no correlations)
nreals = 200

x0_noisy = [x0 + np.random.normal(x0_mean, x0_std, size=x0.shape) for i in range(nreals)]
x0_noisy = np.array(x0_noisy)

print(x0_noisy.shape)
hp.mollview(x0[0, :, 0])
hp.mollview(x0_noisy[2, 0, :, 0])
```

```{python}
nfrecon = [1, 2, 4, 8]
Cp = amc.get_Cp(x0_noisy, nfrecon=nfrecon)
```

```{python}
Cp_prime = amc.Cp2Cp_prime(Cp, verbose=True)
plt.imshow(Cp_prime[:, :, 1, 2])
```

```{python}
RA_center = 0. #deg
DEC_center = -57. #deg
center = equ2gal(RA_center, DEC_center)

ang = rmc.pix2ang(nside, center)
# print(ang)

weighted_av, sig2, sigmean = amc.make_weighted_av(x0_noisy, Cp, ang, ang_threshold=80, verbose=True)
print(sig2, sigmean)
```

```{python}
hp.mollview(weighted_av[0, :, 0])
```

```{python}
sig2MC, sigMCmean = amc.get_sig2MC(weighted_av, ang, ang_threshold=80)
print(sig2MC, sigMCmean)
plt.plot(sig2MC[:, 2])
```

***
# With correlated noise

```{python}
# Generate correlated matrix between subbands
r = np.zeros((nfrec, nfrec))
rho = np.arange(nfrec)

def noise(rho, nfrec):
    return 1 - rho / nfrec

for j in range(nfrec):
    r[:, j] = np.roll(noise(rho, nfrec), j)

# Here r is not symmetric

# The cov matrix must be symmetric
for i in range(nfrec):
    for j in range(nfrec):
        r[i, j] = r[j, i]

# Construct c, so c*c^T = r

# method = 'cholesky'
method = 'eigenvectors'

if method == 'cholesky':
    # Compute the Cholesky decomposition.
    c = cholesky(r, lower=False)
else:
    # Compute the eigenvalues and eigenvectors.
    evals, evecs = eigh(r)
    c = np.dot(evecs, np.diag(np.sqrt(evals))).T

# Check that c*c^T = r
plt.subplot(131)
plt.imshow(r)
plt.title('r')

plt.subplot(132)
plt.imshow(c)
plt.title('c')

plt.subplot(133)
plt.imshow(c.T @ c)
plt.title('c*c^T')

# Check correlation coeff between lines or columns
corr1 , _ = pearsonr(r[:, 0], r[:, -1])
corr2 , _ = pearsonr(r[0, :], r[2, :])
print(corr1, corr2)
```

```{python}
# Convert the data to correlated random variables. 
x0_noisy_corr = np.empty_like(x0_noisy)
for ipix in range(npix):
    for istokes in range(3):
        x0_noisy_corr[:, :, ipix, istokes] = x0_noisy[:, :, ipix, istokes] @ c

hp.mollview(x0_noisy_corr[0, 0, :, 0])
x0_noisy_corr
```

```{python}
Cp = amc.get_Cp(x0_noisy_corr, nfrecon=nfrecon)
plt.figure()
plt.imshow(Cp[:, :, 1, 0])
plt.colorbar()
```

```{python}
Cp_prime = amc.Cp2Cp_prime(Cp, verbose=True)
plt.imshow(Cp_prime[:, :, 0, 0])
```

```{python}
weighted_av, sig2, sigmean = amc.make_weighted_av(x0_noisy_corr, Cp, ang, ang_threshold=90, 
                                               verbose=True)
print(sig2, sigmean)
```

```{python}
hp.mollview(weighted_av[0, :, 0])
```

```{python}
sig2MC, sigMCmean = amc.get_sig2MC(weighted_av, ang, ang_threshold=80)
print(sig2MC, sigMCmean)
plt.plot(sig2MC[:, 2])
```

```{python}

```
