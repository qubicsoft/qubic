---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
from __future__ import division, print_function
import glob
import os
import sys
import healpy as hp
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rc

import ReadMC as rmc
import AnalysisMC as amc

import qubic
from qubic import equ2gal

from qubicpack.utilities import Qubic_DataDir

from scipy.stats import pearsonr
from scipy.linalg import cholesky

# %matplotlib inline
rc({'cmap', 'viridis'})
plt.rcParams['figure.figsize'] = (5, 5)

```

# Noisy maps with no correlations

```{python}
nside = 16
npix = 12 * nside**2
nfrec = 8
x1_band = np.random.random((1, npix, 3))
xn_band = np.random.random((nfrec, npix, 3))

x1_mean = np.mean(x1_band)
x1_std = np.std(x1_band)
xn_mean = np.mean(xn_band)
xn_std = np.std(xn_band)

# Make many realizations with gaussian noise (no correlations)
nreals = 100
std = 2
#x1_noisy = np.mean([x1_band + np.random.normal(x1_mean, std, 
#                                               size=x1_band.shape) for i in range(nreals)],axis=0)

#x1_noisy = x1_band + np.random.normal(x1_mean, std, size=x1_band.shape)
#x1_noisy = np.array(x1_noisy)

x1_noisy = np.zeros((nreals,1,npix,3))
xn_noisy = np.zeros((nreals,nfrec,npix,3))
for i in range(nreals):
    x1_noisy[i,0,:,:] = x1_band[0,:,:] + np.random.normal(x1_mean, std, size=x1_band[0].shape)
    for j in range(nfrec):
        xn_noisy[i,j,:,:] = xn_band[j,:,:] + np.random.normal(xn_mean, np.sqrt(nfrec)*std, size=xn_band[j].shape)

#hp.mollview(x1_band[0, :, 0], title='x0 realization std = {:3.2}'.format(x1_std))
#hp.mollview(xn_noisy[3,0, :, 0], title='x0 realization + noise (one real.)')
#plt.hist(x1_noisy[50,0,:,0]-x1_band[0,:,0], bins= 60)
#plt.hist(x1_noisy[50,0,:,0], bins= 60,color='r')
```

***
Check noise realizations for 1 and N subbands.. ok..works 

```{python}
#1st sigma over px (sigma_1r) ALL for Stokes I then average variance
def method_a1(x1, nr, stokes=0,sb=0):
    sigma_1r = np.zeros((nr,))
    for ire in range(nr):
        sigma_1r[ire] = np.var(x1[ire,sb,:,stokes], ddof=0)
    sigma_1 = np.mean(sigma_1r)
    return sigma_1
def method_b1(x1, nr, stokes=0,sb=0):
    sigma_1 = np.var(x1[:,sb,:,stokes])
    return sigma_1

print('Shape single band array: {}'.format(x1_noisy.shape))
print('Shape nbands band array: {}'.format(xn_noisy.shape))

print('Variance single band method A {}'.format(method_a1(x1_noisy, nreals,stokes=2)))
print('Variance single band method B {}'.format(method_b1(x1_noisy, nreals,stokes=2)))

print('Variance nbands band method A {}'.format(method_a1(xn_noisy, nreals,stokes=0)))
print('Variance nbands band method B {}'.format(method_b1(xn_noisy, nreals,stokes=0)))
```

***
Compute mean of std in reals for a given subband... ~4, ok!


```{python}
#aux = []
#for ire in range(nreals):
#    aux.append(np.std(xn_noisy[ire,0,:,0]))
#print(np.mean(aux))
```

```{python}
#nfrecon = [1, 2, 4, 8]
Cp = amc.get_Cp(xn_noisy, nfrecon=[8,])
```

```{python}
#Cp_prime = amc.Cp2Cp_prime(Cp, verbose=True)
#plt.imshow(Cp_prime[:, :, 1, 2])
```

```{python}
#Cp_prime_viaCorr = amc.Cp2Cp_prime_viaCorr(Cp, verbose=True)
#plt.imshow(Cp_prime[:, :, 1, 2])
```

```{python}
RA_center = 0. #deg
DEC_center = -57. #deg
center = equ2gal(RA_center, DEC_center)

ang = rmc.pix2ang(nside, center)

weighted_av, sig2, sigmean = amc.make_weighted_av(xn_noisy, Cp, ang, ang_threshold=80, verbose=True)
```

```{python}
#aa=[]
#for ire in range(nreals):
#    aa.append(np.std(weighted_av[ire,:,0]))
#print(np.mean(aa))
```

```{python}
weighted_av.shape
```

```{python}
sig2MC = np.var(weighted_av, axis=0)
sigMCmean = amc.average_pix_sig2(sig2MC, ang, ang_threshold=80)
print(sig2MC)
print(sigMCmean)
```

```{python}
freqs = [1,2,4,8]
std1 = np.array([[1.08, 0.98, 0.96, 0.92],
                [1.08, 0.98, 0.95, 0.91],
                [1.08, 0.99, 0.96, 0.93]])

std2 = np.array([[4.08, 3.93, 3.83, 3.70],
                [4.09, 3.88, 3.82, 3.68],
                [4.10, 3.93, 3.84, 3.66]])

stdarr = std2
plt.ylim(0.5,1.5)
plt.xlabel('nfrec', fontsize=16)
plt.ylabel(r'$\sigma_{fnrec}^2/\sigma_1^2$', fontsize=16)
plt.plot(freqs, stdarr[0,:]/stdarr[0,0], 'b*', label='I comp')
plt.plot(freqs, stdarr[1,:]/stdarr[1,0], 'm*', label='Q ')
plt.plot(freqs, stdarr[2,:]/stdarr[2,0], 'c*', label='U ')
plt.text(4,1.4, 'std=2',fontsize=16)
plt.axhline(1.0, c='k',ls='--',alpha=0.5)
plt.legend()
```

***
# With correlated noise

```{python}
# Generate the covariance matrix between subbands
r = np.zeros((nfrec, nfrec))
rho = np.arange(nfrec)

def noise(rho, nfrec):
    return 1 - rho / nfrec

for j in range(nfrec):
    r[:, j] = np.roll(noise(rho, nfrec), j)

# Here r is not symmetric

# The cov matrix must be symmetric
for i in range(nfrec):
    for j in range(nfrec):
        r[i, j] = r[j, i]

# Construct c, so c*c^T = r

method = 'cholesky'
# method = 'eigenvectors'

if method == 'cholesky':
    # Compute the Cholesky decomposition.
    c = cholesky(r, lower=False)
else:
    # Compute the eigenvalues and eigenvectors.
    evals, evecs = np.linalg.eigh(r)
    c = np.dot(evecs, np.diag(np.sqrt(evals))).T

# Check that c*c^T = r
plt.subplot(131)
plt.imshow(r)
plt.title('r')

plt.subplot(132)
plt.imshow(c)
plt.title('c')

plt.subplot(133)
plt.imshow(c.T @ c)
plt.title('c*c^T')

# Check correlation coeff between lines or columns
corr1 , _ = pearsonr(r[:, 0], r[:, -1])
corr2 , _ = pearsonr(r[0, :], r[2, :])
print(corr1, corr2)
```

```{python}
# Apply the correlations to the maps
x0_noisy_corr = np.empty_like(x0_noisy)
for ipix in range(npix):
    for istokes in range(3):
        x0_noisy_corr[:, :, ipix, istokes] = x0_noisy[:, :, ipix, istokes] @ c

hp.mollview(x0_noisy_corr[0, 0, :, 0])
x0_noisy_corr
```

```{python}
# Check the functions from AnalysisMC
Cp = amc.get_Cp(x0_noisy_corr, nfrecon=nfrecon, verbose=False)
Cp_prime = amc.Cp2Cp_prime(Cp, verbose=True)
Cp_prime_viaCorr = amc.Cp2Cp_prime_viaCorr(Cp, verbose=True)

istokes = 1
ipix = 100
plt.figure()
plt.subplots_adjust(right=2)
plt.subplot(141)
plt.imshow(Cp[:, :, istokes, ipix])
plt.title('Cp')
plt.colorbar()

plt.subplot(142)
plt.imshow(Cp_prime[:, :, istokes, ipix])
plt.title('Cp_prime')
plt.colorbar()

plt.subplot(143)
plt.imshow(Cp_prime_viaCorr[:, :, istokes, ipix])
plt.title('Cp_prime via corr')
plt.colorbar()

plt.subplot(144)
plt.imshow((Cp-Cp_prime_viaCorr)[:, :, istokes, ipix])
plt.title('Cp- Cp_prime via corr')
plt.colorbar()
```

```{python}
# Other method: using np.random.multivariate_normal
x0_noisy_corr = np.empty_like(x0_noisy)
for ipix in range(npix):
    for istokes in range(3):
        x0_noisy_corr[:, :, ipix, istokes] = np.random.multivariate_normal(x0_noisy[0, :, ipix, istokes], r, 
                                                                           size=200)

hp.mollview(x0_noisy_corr[0, 0, :, 0])

# Check it is still ok
Cp = amc.get_Cp(x0_noisy_corr, nfrecon=nfrecon, verbose=False)
Cp_prime = amc.Cp2Cp_prime(Cp, verbose=True)
Cp_prime_viaCorr = amc.Cp2Cp_prime_viaCorr(Cp, verbose=True)

istokes = 0
ipix = 100
plt.figure()
plt.subplots_adjust(right=2)
plt.subplot(141)
plt.imshow(Cp[:, :, istokes, ipix])#, vmin=-0.2, vmax=1)
plt.title('Cp')
plt.colorbar()

plt.subplot(142)
plt.imshow(Cp_prime[:, :, istokes, ipix])#, vmin=-0.2, vmax=1)
plt.title('Cp_prime')
plt.colorbar()

plt.subplot(143)
plt.imshow(Cp_prime_viaCorr[:, :, istokes, ipix])#, vmin=-0.2, vmax=1)
plt.title('Cp_prime via corr')
plt.colorbar()

plt.subplot(144)
plt.imshow((Cp-Cp_prime_viaCorr)[:, :, istokes, ipix])#, vmin=-0.2, vmax=1)
plt.title('Cp- Cp_prime via corr')
plt.colorbar()
```

```{python}
weighted_av, sig2, sigmean = amc.make_weighted_av(x0_noisy_corr, Cp, ang, ang_threshold=90, 
                                               verbose=True)
print(sig2, sigmean)
```

```{python}
hp.mollview(weighted_av[0, :, 0])
```

```{python}
sig2MC = np.var(weighted_av, axis=0)
sigMCmean = amc.average_pix_sig2(sig2MC, ang, ang_threshold=80)
print(sig2MC, sigMCmean)
plt.plot(sig2MC[:, 2])
```

```{python}

```

```{python}

```

```{python}

```
