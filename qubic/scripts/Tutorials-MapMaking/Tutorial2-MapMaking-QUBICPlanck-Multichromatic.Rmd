---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.14.4
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# Map-Making using Planck Acquisition

In this notebook, we describe how to make the map-making process using Planck acquisition to correct edge effects. We will merge QUBIC and Planck acquisition to benefit of both instrument, QUBIC for the Q and U sensitivity and Planck for the large coverage and sensitivity on I.

```{python}
from __future__ import division
from pyoperators import pcg
from pysimulators import profile

# QUBIC packages
import qubic
from qubicpack.utilities import Qubic_DataDir
from qubic.data import PATH
from qubic.io import read_map
from qubic import QubicSkySim as qss
import Acquisition as Acq

# Display packages
import healpy as hp
import matplotlib.pyplot as plt

# FG-Buster packages
import component_model as c
import mixing_matrix as mm

# General packages
import numpy as np
import pysm3
import warnings
from qubic import QubicSkySim as qss
import pysm3.units as u
from importlib import reload
from pysm3 import utils

# PyOperators packages
from pyoperators import (
    BlockColumnOperator, BlockDiagonalOperator, BlockRowOperator,
    CompositionOperator, DiagonalOperator, I, IdentityOperator,
    MPIDistributionIdentityOperator, MPI, proxy_group, ReshapeOperator,
    rule_manager, pcg, Operator)

from pysimulators.interfaces.healpy import HealpixConvolutionGaussianOperator
warnings.filterwarnings("ignore")
# %matplotlib inline

# # %config InlineBackend.figure_format='retina'
from IPython.display import display, HTML
display(HTML("<style>.container { width:95% !important; }</style>"))
```

# QUBIC dictionary

We first import the QUBIC dictionary to define general stuff like pixelization, seen region on the sky, etc... 

```{python}
# Repository for dictionary
global_dir = '/pbs/home/m/mregnier/Libs/qubic/qubic/'#Qubic_DataDir()
print(global_dir)
dictfilename = global_dir + 'dicts/pipeline_demo.dict'

# Read dictionary chosen
d = qubic.qubicdict.qubicDict()
d.read_from_file(dictfilename)

from qubic import SpectroImLib as sp
from importlib import reload

Nf = 3
relative_bandwidth = 0.25
Nbfreq, nus_edge, nus, deltas, Delta, Nbbands = qubic.compute_freq(150, Nfreq=Nf)
print(nus)
print(nus_edge)

d = qubic.qubicdict.qubicDict()
d.read_from_file(dictfilename)
d['nf_recon'] = Nf
d['nf_sub'] = 4*Nf
d['nside'] = 256
npix=12*d['nside']**2
d['RA_center'] = 0
d['DEC_center'] = -57
center = qubic.equ2gal(d['RA_center'], d['DEC_center'])
d['effective_duration'] = 4
#d['dtheta'] = 15
d['npointings'] = 300
d['tol'] = 5e-4
d['filter_nu'] = 150e9
d['photon_noise'] = False
d['noiseless'] = False
d['config'] = 'FI'
d['MultiBand'] = True
d['planck'] = True

d_formaps = qubic.qubicdict.qubicDict()
d_formaps.read_from_file(dictfilename)
d_formaps['nf_recon'] = Nf
d_formaps['nf_sub'] = Nf
d_formaps['nside'] = d['nside']
npix=12*d_formaps['nside']**2
```

Then, we define specific qubic package for Map-Making. The Pointing package define the information on the scanning strategy (random pointing here). The Scene package define things realted to the pixelization. The Instrument package define the QUBIC instrument forexample for systematics effect. Then we define the acquisition for our instrument.

```{python}
reload(Acq)

Qubic_sky = qss.Qubic_sky({'cmb':42}, d_formaps)
mapin = Qubic_sky.get_simple_sky_map()

# Pointing
p = qubic.get_pointing(d)

# Scene
s = qubic.QubicScene(d)

# Instrument
q = qubic.QubicMultibandInstrument(d)

# QUBIC Acquisition
qubic_acquisition = Acq.QubicIntegrated(q, p, s, d, nus_edge)
```

The acquisition allows you to define the QUBIC operator which tak eas input a sky map with shape ($N_{pix}$, $N_{stk}$) and returns TOD after many rotations and transformations. For the next notebook, it will be very inportant to understand the structure of this operator... To be breaf, this operator can be seen as a list of function.

```{python}
H_qubic = qubic_acquisition.get_operator(convolution=False)
H_qubic
```

Here we define $N^{-1}$ the inverse noise covariance matrix in time domain.

```{python}
invntt = qubic_acquisition.get_invntt_operator()
invntt
```

As we said before, we compute our observations using QUBIC operator.

```{python}
n = qubic_acquisition.get_noise()
tod = H_qubic(mapin) + n
```

```{python}
H_qubic
```

In a very generic way, all of this work is done to solve this equation :

$$y = (H^t N^{-1} H)^{-1} H^t N^{-1} d$$

where d is your data and $y$ is the observed sky. In practical, we can not solve that analytical due to the very large size of $H$ and $N^{-1}$, then the PCG is here to solve iteratively. We just define here both side of this equation like : 

$$A = (H^t N^{-1} H)$$
$$b = H^t N^{-1} d$$

```{python}
A = H_qubic.T * invntt * H_qubic
b = H_qubic.T * invntt * tod
```

The PCG (Preconditionned Conjugated Gradient) solve the above equation iteratively, the convergence of the method is conditionnned by $M$ which is called the preconditionner. For QUBIC only acquisition, it can be define as function of the coverage.

```{python}
def get_preconditioner(cov):
    if cov is not None:
        cov_inv = 1 / cov
        cov_inv[np.isinf(cov_inv)] = 0.
        preconditioner = DiagonalOperator(cov_inv, broadcast='rightward')
    else:
        preconditioner = None
    return preconditioner

cov = qubic_acquisition.get_coverage()
pixok = cov > 0
mapin[:, ~pixok, :] = 0
M = get_preconditioner(np.array([cov]))
```

Here we call the PCG from the PyOperators package, we have to mentionned a tolerance.

```{python}
tol=2e-3

solution_qubic = pcg(A, b, x0=None, M=M, tol=tol, disp=True)
```

Now we can see the result of the convergence...

```{python}
def display_maps(inputs, outputs, istk, display=True, rot=None, res=None, min=300, max=300, minr=-300, maxr=300):
    
    r = inputs[:, :, istk] - outputs[:, :, istk]
    Nf = outputs.shape[0]
    
    
    stk=['I', 'Q', 'U']
    k=1
    for i in range(Nf): # Nf
        hp.gnomview(inputs[i, :, istk], rot=rot, reso=res, cmap='jet', min=min, max=max, sub=(Nf, 3, k), title='Input')
        k+=1
        hp.gnomview(outputs[i, :, istk], rot=rot, reso=res, cmap='jet', min=min, max=max, sub=(Nf, 3, k), title='Output')
        k+=1
        hp.gnomview(r[i], rot=rot, reso=res, cmap='jet', min=minr, max=maxr, sub=(Nf, 3, k), title='Residual')
        k+=1
    
    
plt.figure(figsize=(10, 10))
display_maps(mapin, solution_qubic['x'], istk=0, display=True, rot=center, res=25, min=-300, max=300, minr=-30, maxr=30)
plt.show()
```

In the inner part of the coverage, the result is quite good. It seems that the PCG solve correctly the Map-Making equation and so converge to the solution. Unfortunately, on the edge of the coverage the reconstruction is very bad and the error increase a lot... Missing data is the cause and a way to solve this problem is to merge the QUBIC acquisition with the planck aquisition which have seen the whole sky.


We define here the PlanckAcquisition which needs the central frequency that you are using (150 or 220 GHz) and the same scene as before.

```{python}

```

```{python}
# Planck Acquisition
reload(Acq)
mapin_conv = mapin.copy()

for i in range(Nf):
    print(qubic_acquisition.final_fwhm[i])
    C = HealpixConvolutionGaussianOperator(fwhm=qubic_acquisition.final_fwhm[i])
    #C = q[i].get_convolution_peak_operator()#qubic_acquisition[i].get_convolution_peak_operator()
    mapin_conv[i] = C(mapin[i])
print(mapin_conv.shape)
#mapin_conv[:, ~mask, :] = 0
planck_acquisition = qubic.PlanckAcquisition(150, s, true_sky=mapin_conv[0], mask=None)
```

Now we define the multichromatic acquisition for QUBIC using Planck acquisition to correct all the previous effects.

```{python}
qubicplanck_acquisition = Acq.QubicPlanckMultiBandAcquisition(qubic_acquisition, planck_acquisition)
```

Here, we define the QUBIC-Planck Operator. As before, look at this operator is very important for next steps.

```{python}
H = qubicplanck_acquisition.get_operator(convolution=False)
```

```{python}
H
```

```{python}
invntt = qubicplanck_acquisition.get_invntt_operator()
```

Here, we take a look of data. The first part of the TOD is the QUBIC part and the second is the sky seen by Planck.

```{python}
n = qubicplanck_acquisition.get_noise()
tod = H(mapin_conv) + n

plt.figure(figsize=(15, 5))
plt.plot(tod, ls=':')
plt.show()
```

```{python}
A = H.T * invntt * H
b = H.T * invntt * tod
```

Here, the preconditionner is not a function of the QUBIC coverage because Planck acquisition is turn on. The simplest preconditionner is the entire sky itself.

```{python}
M = Acq.get_preconditioner(np.ones(12*d['nside']**2))
cov = qubic_acquisition.get_coverage()
```

```{python}
tol=1e-4

solution_qubic_planck = pcg(A, b, x0=None, M=M, tol=tol, disp=True, maxiter=1000)
```

You can note that the convergence is much faster than before with the QUBIC only acquisition. This is due to the fact that edge effects have disappeared ! Let's take a look of reconstructed maps.

```{python}
plt.figure(figsize=(10, 10))
display_maps(mapin_conv, solution_qubic_planck['x'], istk=1, display=True, rot=center, res=15, min=-8, max=8, minr=-8, maxr=8)
plt.show()
```

```{python}

```

```{python}

```

```{python}

```
